// Generated by CoffeeScript 1.4.0
(function() {
  var main, runTicking, __soran;

  __soran = {
    BUGS_PREFIX: 'bugs',
    NAVER_PREFIX: 'naverMusic',
    TRACK_POSTFIX: "Track",
    EVENT_USER_INIT: 'userInit',
    EVENT_LISTEN: 'listen',
    BUGS_ARTIST_URL: "http://music.bugs.co.kr/artist/",
    BUGS_ALBUM_URL: "http://music.bugs.co.kr/album/",
    NAVER_ARTIST_URL: "http://music.naver.com/artist/home.nhn?artistId=",
    NAVER_ALBUM_URL: "http://music.naver.com/album/index.nhn?albumId=",
    BUGS_TRACK_API_URL: "http://music.bugs.co.kr/player/track/",
    NAVER_TRACK_API_URL: "http://player.music.naver.com/api.nhn?m=songinfo&trackid=",
    BUGS_DOMAIN: 'bugs.co.kr',
    NAVER_DOMAIN: 'naver.com',
    ERROR: 'Error',
    servicePrefix: '',
    isListen: false,
    conn: void 0,
    loggedAt: 80,
    nowPlaying: {
      id: '',
      len: 0
    },
    getNaverTrackInfo: function(n, callback) {
      var options, that, trackIdentifier;
      console.log('getNaverTrackInfo');
      that = this;
      trackIdentifier = this.NAVER_PREFIX + "-" + n;
      options = {
        type: 'GET',
        url: this.NAVER_TRACK_API_URL + n,
        success: function(data) {
          var albumArtist, artistName, d, decoded, nTrack;
          decoded = JSON.parse(decodeURIComponent(data));
          nTrack = decoded.resultvalue[0];
          d = {
            track: {}
          };
          artistName = nTrack.artist[0].artistname.replace('+', ' ');
          albumArtist = nTrack.artist.length === 1 ? artistName : "Various Artist";
          d.track = that.track(trackIdentifier, artistName, nTrack.artist[0].artistid, albumArtist, nTrack.album.albumtitle.replace('+', ' '), nTrack.album.albumid, nTrack.tracktitle.replace('+', ' '), "unknown", jQuery('.progress .total_time').text(), "unknown");
          return callback(d);
        },
        error: function(jqXHR, textStatus, errorThrow) {
          var d;
          console.log('error, ', textStatus);
          d = {
            kind: that.BUGS_PREFIX + that.ERROR,
            msg: "Bugs API dosen't response. error text: " + textStatus
          };
          return callback(d);
        }
      };
      return jQuery.ajax(options);
    },
    getBugsTrackInfo: function(n, callback) {
      var options, that, trackIdentifier;
      console.log('getBugsTrackInfo');
      that = this;
      trackIdentifier = this.BUGS_PREFIX + "-" + n;
      options = {
        type: 'GET',
        url: this.BUGS_TRACK_API_URL + n,
        success: function(data) {
          var d;
          if (data.track !== void 0) {
            d = {
              track: {}
            };
            d.track = that.track(trackIdentifier, data.track.artist_nm, data.track.artist_id, data.track.album_artist_nm, data.track.album_title, data.track.album_id, data.track.track_title, data.track.genre_dtl, data.track.len, data.track.release_ymd);
            return callback(d);
          } else {
            d = {
              kind: that.BUGS_PREFIX + that.ERROR,
              track: {
                id: trackIdentifier
              },
              msg: "Bugs API data isnt valid for soran."
            };
            return callback(d);
          }
        },
        error: function(jqXHR, textStatus, errorThrow) {
          var d;
          console.log('error, ', textStatus);
          d = {
            kind: that.BUGS_PREFIX + that.ERROR,
            msg: "Bugs API dosen't response. error text: " + textStatus
          };
          return callback(d);
        }
      };
      jQuery.ajax(options);
      return true;
    },
    getUserIdentifier: function(n) {
      if (!(this.servicePrefix.length === 0 && n.length === 0)) {
        return "" + n + "@" + this.servicePrefix;
      } else {
        return '';
      }
    },
    init: function(service, conn) {
      var that;
      this.conn = conn;
      that = this;
      return jQuery(document).on('click', function() {
        var $bugsUserNameCover, $naverUserNameCover, cover, d, name, tmpName;
        $bugsUserNameCover = jQuery('.username strong');
        $naverUserNameCover = jQuery('strong#gnb_nicknm_txt');
        cover = null;
        name = "";
        if (service === that.BUGS_PREFIX && $bugsUserNameCover.length !== 0) {
          that.servicePrefix = that.BUGS_PREFIX;
          name = $bugsUserNameCover.text();
        } else if (service === that.NAVER_PREFIX && $naverUserNameCover.length !== 0) {
          that.servicePrefix = that.NAVER_PREFIX;
          tmpName = $naverUserNameCover.text();
          name = tmpName.substring(0, tmpName.length - 1);
        }
        if (that.servicePrefix.length !== 0 && name.length !== 0) {
          d = {
            kind: that.EVENT_USER_INIT,
            identifier: that.getUserIdentifier(name)
          };
          return that.conn.postMessage(d);
        }
      });
    },
    track: function(id, artist, artistId, albumArtist, albumTitle, albumId, title, genre, length, releaseDate) {
      var data;
      data = {
        identifier: id,
        artist: artist,
        artistId: artistId,
        albumArtist: albumArtist,
        albumTitle: albumTitle,
        albumId: albumId,
        title: title,
        genre: genre,
        len: length,
        releaseDate: releaseDate
      };
      return data;
    },
    /*
      일정시간마다 웹플레이어가 노래를 어디까지 틀었나 확인한다. 트랙에 길이 __soran.nowPlaying.len 을 이용해서 다음 호출 시점을 정한다.
      @param {string} kind 서비스 이름 PREFIX (eg. __soran.BUGS_PREFIX, ...)
    */

    tick: function(kind, callback) {
      var $nowPlayingTd, $nowProgressBar, f, min, nowId, nowLen, nowPlaying, nowProgress, nowProgressInt, remainPercentage, remainTime, sec, that, thisService, time, _ref;
      console.log("ticking started, ", kind);
      that = this;
      time = 0;
      nowProgress = 0;
      nowLen = '';
      thisService = '';
      f = function() {
        console.log('applied');
        that.tick.apply(that, [kind, callback]);
        return true;
      };
      if (this.isListen) {
        this.isListen = false;
      }
      switch (kind) {
        case this.BUGS_PREFIX:
          thisService = this.BUGS_PREFIX;
          nowProgress = jQuery('.progress .bar').attr('style').substr(7, 2);
          nowPlaying = jQuery('.nowPlaying').find('.trackInfo');
          if (nowPlaying.length === 0) {
            setTimeout(f, 1000);
            return false;
          } else {
            nowId = nowPlaying.attr('id');
            nowLen = nowPlaying.attr('duration');
            this.nowPlaying.id = nowId;
            console.log('nowProgress, ', nowProgress);
          }
          break;
        case this.NAVER_PREFIX:
          thisService = this.NAVER_PREFIX;
          $nowProgressBar = jQuery('.slider .play_value');
          if ($nowProgressBar.length === 0) {
            setTimeout(f, 1000);
            return false;
          } else {
            nowProgress = $nowProgressBar.attr('style').substr(7, 2);
            $nowPlayingTd = jQuery('.play_list_table tr.playing td.title');
            nowLen = jQuery('.progress .total_time').text();
            this.nowPlaying.id = $nowPlayingTd.attr('class').split(" ")[0].split(",")[1].split(":")[1];
          }
          break;
        default:
          this.isListen = false;
          time = 100000;
          return false;
      }
      _ref = nowLen.split(":"), min = _ref[0], sec = _ref[1];
      min = parseInt(min);
      sec = parseInt(sec);
      this.nowPlaying.len = (sec + (min * 60)) * 1000;
      if (nowProgress.search('%') === 1 || nowProgress.search('p') === 1) {
        time = this.nowPlaying.len * 0.7;
      } else {
        nowProgressInt = parseInt(nowProgress);
        time = this.nowPlaying.len * 0.05;
        if (!this.isListen && this.loggedAt <= nowProgressInt) {
          this.isListen = true;
          remainPercentage = (100 - nowProgressInt) / 100;
          remainTime = this.nowPlaying.len * (remainPercentage + 0.05);
          time = remainTime;
          callback("" + thisService + this.EVENT_LISTEN, this.nowPlaying.id);
        }
      }
      if (time !== 0) {
        setTimeout(f, time);
      } else {
        setTimeout(f, 10000);
      }
      return this;
    }
  };

  runTicking = function(prefix) {
    __soran.tick(prefix, function(e, trackNum) {
      var d;
      switch (e) {
        case __soran.BUGS_PREFIX + __soran.EVENT_LISTEN:
          __soran.getBugsTrackInfo(trackNum, function(d) {
            d.kind = __soran.EVENT_LISTEN;
            return __soran.conn.postMessage(d);
          });
          break;
        case __soran.NAVER_PREFIX + __soran.EVENT_LISTEN:
          __soran.getNaverTrackInfo(trackNum, function(d) {
            d.kind = __soran.EVENT_LISTEN;
            return __soran.conn.postMessage(d);
          });
          break;
        default:
          console.log('errored');
          d = {
            kind: __soran.servicePrefix + __soran.ERROR,
            msg: 'Unknown error occured in f, contentScript.coffee [line: 228]'
          };
          __soran.conn.postMessage(d);
      }
      return true;
    });
    return true;
  };

  main = function(s) {
    var wrap;
    __soran.init(s, chrome.extension.connect());
    if (jQuery('.progress .bar').length !== 0 || jQuery('.slider .play_value').length !== 0) {
      wrap = function() {
        return runTicking(s);
      };
      return setTimeout(wrap, 2000);
    }
  };

  switch (document.domain) {
    case __soran.NAVER_DOMAIN:
      main(__soran.NAVER_PREFIX);
      break;
    case __soran.BUGS_DOMAIN:
      main(__soran.BUGS_PREFIX);
  }

}).call(this);
