package org.osmf.traits {
    import org.osmf.events.*;

    public class SeekTrait extends MediaTraitBase {

        private var _timeTrait:TimeTrait;
        private var _seeking:Boolean;

        public function SeekTrait(_arg1:TimeTrait){
            super(MediaTraitType.SEEK);
            this._timeTrait = _arg1;
        }
        final public function get seeking():Boolean{
            return (this._seeking);
        }
        final public function seek(_arg1:Number):void{
            if (this.canSeekTo(_arg1)){
                this.setSeeking(true, _arg1);
            };
        }
        public function canSeekTo(_arg1:Number):Boolean{
            return (((this._timeTrait) ? (((((isNaN(_arg1) == false)) && ((_arg1 >= 0)))) && ((((_arg1 <= this._timeTrait.duration)) || ((_arg1 <= this._timeTrait.currentTime))))) : false));
        }
        final protected function get timeTrait():TimeTrait{
            return (this._timeTrait);
        }
        final protected function set timeTrait(_arg1:TimeTrait):void{
            this._timeTrait = _arg1;
        }
        final protected function setSeeking(_arg1:Boolean, _arg2:Number):void{
            this.seekingChangeStart(_arg1, _arg2);
            this._seeking = _arg1;
            this.seekingChangeEnd(_arg2);
        }
        protected function seekingChangeStart(_arg1:Boolean, _arg2:Number):void{
        }
        protected function seekingChangeEnd(_arg1:Number):void{
            dispatchEvent(new SeekEvent(SeekEvent.SEEKING_CHANGE, false, false, this.seeking, _arg1));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class PlayTrait extends MediaTraitBase {

        private var _playState:String;
        private var _canPause:Boolean;

        public function PlayTrait(){
            super(MediaTraitType.PLAY);
            this._canPause = true;
            this._playState = PlayState.STOPPED;
        }
        final public function play():void{
            this.attemptPlayStateChange(PlayState.PLAYING);
        }
        public function get canPause():Boolean{
            return (this._canPause);
        }
        final public function pause():void{
            if (this.canPause){
                this.attemptPlayStateChange(PlayState.PAUSED);
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.PAUSE_NOT_SUPPORTED)));
            };
        }
        final public function stop():void{
            this.attemptPlayStateChange(PlayState.STOPPED);
        }
        public function get playState():String{
            return (this._playState);
        }
        final protected function setCanPause(_arg1:Boolean):void{
            if (_arg1 != this._canPause){
                this._canPause = _arg1;
                dispatchEvent(new PlayEvent(PlayEvent.CAN_PAUSE_CHANGE, false, false, this.playState, this._canPause));
            };
        }
        protected function playStateChangeStart(_arg1:String):void{
        }
        protected function playStateChangeEnd():void{
            dispatchEvent(new PlayEvent(PlayEvent.PLAY_STATE_CHANGE, false, false, this.playState));
        }
        private function attemptPlayStateChange(_arg1:String):void{
            if (this._playState != _arg1){
                this.playStateChangeStart(_arg1);
                this._playState = _arg1;
                this.playStateChangeEnd();
            };
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.net.*;
    import org.osmf.utils.*;

    public class AlternativeAudioTrait extends MediaTraitBase {

        protected static const INVALID_TRANSITION_INDEX:int = -2;
        protected static const DEFAULT_TRANSITION_INDEX:int = -1;

        private var _currentIndex:int = -1;
        private var _numAlternativeAudioStreams:int;
        private var _switching:Boolean;
        protected var _indexToSwitchTo:int = -2;

        public function AlternativeAudioTrait(_arg1:int){
            super(MediaTraitType.ALTERNATIVE_AUDIO);
            this._numAlternativeAudioStreams = _arg1;
            this._switching = false;
        }
        public function get numAlternativeAudioStreams():int{
            return (this._numAlternativeAudioStreams);
        }
        public function get currentIndex():int{
            return (this._currentIndex);
        }
        public function getItemForIndex(_arg1:int):StreamingItem{
            if ((((_arg1 <= INVALID_TRANSITION_INDEX)) || ((_arg1 >= this.numAlternativeAudioStreams)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.ALTERNATIVEAUDIO_INVALID_INDEX)));
            };
            return (null);
        }
        public function get switching():Boolean{
            return (this._switching);
        }
        public function switchTo(_arg1:int):void{
            if (_arg1 != this._indexToSwitchTo){
                if ((((_arg1 < INVALID_TRANSITION_INDEX)) || ((_arg1 >= this.numAlternativeAudioStreams)))){
                    throw (new RangeError(OSMFStrings.getString(OSMFStrings.ALTERNATIVEAUDIO_INVALID_INDEX)));
                };
                this.setSwitching(true, _arg1);
            };
        }
        final protected function setCurrentIndex(_arg1:int):void{
            this._currentIndex = _arg1;
        }
        final protected function setSwitching(_arg1:Boolean, _arg2:int):void{
            if (((!((_arg1 == this._switching))) || (!((_arg2 == this._indexToSwitchTo))))){
                this.beginSwitching(_arg1, _arg2);
                this._switching = _arg1;
                if (this._switching == false){
                    this.setCurrentIndex(_arg2);
                };
                this.endSwitching(_arg2);
            };
        }
        protected function beginSwitching(_arg1:Boolean, _arg2:int):void{
            if (_arg1){
                this._indexToSwitchTo = _arg2;
            };
        }
        protected function endSwitching(_arg1:int):void{
            if (!this._switching){
                this._indexToSwitchTo = INVALID_TRANSITION_INDEX;
            };
            dispatchEvent(new AlternativeAudioEvent(AlternativeAudioEvent.AUDIO_SWITCHING_CHANGE, false, false, this.switching));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;

    public class AudioTrait extends MediaTraitBase {

        private var _volume:Number = 1;
        private var _muted:Boolean = false;
        private var _pan:Number = 0;

        public function AudioTrait(){
            super(MediaTraitType.AUDIO);
        }
        public function get volume():Number{
            return (this._volume);
        }
        final public function set volume(_arg1:Number):void{
            if (isNaN(_arg1)){
                _arg1 = 0;
            } else {
                if (_arg1 > 1){
                    _arg1 = 1;
                } else {
                    if (_arg1 < 0){
                        _arg1 = 0;
                    };
                };
            };
            if (_arg1 != this._volume){
                this.volumeChangeStart(_arg1);
                this._volume = _arg1;
                this.volumeChangeEnd();
            };
        }
        public function get muted():Boolean{
            return (this._muted);
        }
        final public function set muted(_arg1:Boolean):void{
            if (_arg1 != this._muted){
                this.mutedChangeStart(_arg1);
                this._muted = _arg1;
                this.mutedChangeEnd();
            };
        }
        public function get pan():Number{
            return (this._pan);
        }
        final public function set pan(_arg1:Number):void{
            if (isNaN(_arg1)){
                _arg1 = 0;
            } else {
                if (_arg1 > 1){
                    _arg1 = 1;
                } else {
                    if (_arg1 < -1){
                        _arg1 = -1;
                    };
                };
            };
            if (_arg1 != this._pan){
                this.panChangeStart(_arg1);
                this._pan = _arg1;
                this.panChangeEnd();
            };
        }
        protected function volumeChangeStart(_arg1:Number):void{
        }
        protected function volumeChangeEnd():void{
            dispatchEvent(new AudioEvent(AudioEvent.VOLUME_CHANGE, false, false, false, this._volume));
        }
        protected function mutedChangeStart(_arg1:Boolean):void{
        }
        protected function mutedChangeEnd():void{
            dispatchEvent(new AudioEvent(AudioEvent.MUTED_CHANGE, false, false, this._muted));
        }
        protected function panChangeStart(_arg1:Number):void{
        }
        protected function panChangeEnd():void{
            dispatchEvent(new AudioEvent(AudioEvent.PAN_CHANGE, false, false, false, NaN, this._pan));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import flash.events.*;

    public class MediaTraitBase extends EventDispatcher {

        private var _traitType:String;

        public function MediaTraitBase(_arg1:String){
            this._traitType = _arg1;
        }
        public function get traitType():String{
            return (this._traitType);
        }
        public function dispose():void{
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import __AS3__.vec.*;

    public final class MediaTraitType {

        public static const AUDIO:String = "audio";
        public static const BUFFER:String = "buffer";
        public static const DRM:String = "drm";
        public static const DYNAMIC_STREAM:String = "dynamicStream";
        public static const ALTERNATIVE_AUDIO:String = "alternativeAudio";
        public static const LOAD:String = "load";
        public static const PLAY:String = "play";
        public static const SEEK:String = "seek";
        public static const TIME:String = "time";
        public static const DISPLAY_OBJECT:String = "displayObject";
        public static const DVR:String = "dvr";
        public static const ALL_TYPES:Vector.<String> = Vector.<String>([AUDIO, BUFFER, DRM, DYNAMIC_STREAM, LOAD, PLAY, SEEK, TIME, DISPLAY_OBJECT, DVR, ALTERNATIVE_AUDIO]);

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {

    public final class PlayState {

        public static const PLAYING:String = "playing";
        public static const PAUSED:String = "paused";
        public static const STOPPED:String = "stopped";

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import flash.utils.*;

    public class TraitEventDispatcher extends EventDispatcher {

        private static var eventMaps:Dictionary;

        private var _mediaElement:MediaElement;

        public function TraitEventDispatcher(){
            if (eventMaps == null){
                eventMaps = new Dictionary();
                eventMaps[TimeEvent.DURATION_CHANGE] = MediaTraitType.TIME;
                eventMaps[TimeEvent.COMPLETE] = MediaTraitType.TIME;
                eventMaps[PlayEvent.PLAY_STATE_CHANGE] = MediaTraitType.PLAY;
                eventMaps[PlayEvent.CAN_PAUSE_CHANGE] = MediaTraitType.PLAY;
                eventMaps[AudioEvent.VOLUME_CHANGE] = MediaTraitType.AUDIO;
                eventMaps[AudioEvent.MUTED_CHANGE] = MediaTraitType.AUDIO;
                eventMaps[AudioEvent.PAN_CHANGE] = MediaTraitType.AUDIO;
                eventMaps[SeekEvent.SEEKING_CHANGE] = MediaTraitType.SEEK;
                eventMaps[DynamicStreamEvent.SWITCHING_CHANGE] = MediaTraitType.DYNAMIC_STREAM;
                eventMaps[DynamicStreamEvent.AUTO_SWITCH_CHANGE] = MediaTraitType.DYNAMIC_STREAM;
                eventMaps[DynamicStreamEvent.NUM_DYNAMIC_STREAMS_CHANGE] = MediaTraitType.DYNAMIC_STREAM;
                eventMaps[AlternativeAudioEvent.AUDIO_SWITCHING_CHANGE] = MediaTraitType.ALTERNATIVE_AUDIO;
                eventMaps[AlternativeAudioEvent.NUM_ALTERNATIVE_AUDIO_STREAMS_CHANGE] = MediaTraitType.ALTERNATIVE_AUDIO;
                eventMaps[DisplayObjectEvent.DISPLAY_OBJECT_CHANGE] = MediaTraitType.DISPLAY_OBJECT;
                eventMaps[DisplayObjectEvent.MEDIA_SIZE_CHANGE] = MediaTraitType.DISPLAY_OBJECT;
                eventMaps[LoadEvent.LOAD_STATE_CHANGE] = MediaTraitType.LOAD;
                eventMaps[LoadEvent.BYTES_LOADED_CHANGE] = MediaTraitType.LOAD;
                eventMaps[LoadEvent.BYTES_TOTAL_CHANGE] = MediaTraitType.LOAD;
                eventMaps[BufferEvent.BUFFERING_CHANGE] = MediaTraitType.BUFFER;
                eventMaps[BufferEvent.BUFFER_TIME_CHANGE] = MediaTraitType.BUFFER;
                eventMaps[DRMEvent.DRM_STATE_CHANGE] = MediaTraitType.DRM;
                eventMaps[DVREvent.IS_RECORDING_CHANGE] = MediaTraitType.DVR;
            };
        }
        public function get media():MediaElement{
            return (this._mediaElement);
        }
        public function set media(_arg1:MediaElement):void{
            var _local2:String;
            if (_arg1 != this._mediaElement){
                if (this._mediaElement != null){
                    this._mediaElement.removeEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                    this._mediaElement.removeEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                    for each (_local2 in this._mediaElement.traitTypes) {
                        this.onTraitChanged(_local2, false);
                    };
                };
                this._mediaElement = _arg1;
                if (this._mediaElement != null){
                    this._mediaElement.addEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                    this._mediaElement.addEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                    for each (_local2 in this._mediaElement.traitTypes) {
                        this.onTraitChanged(_local2, true);
                    };
                };
            };
        }
        override public function addEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false, _arg4:int=0, _arg5:Boolean=false):void{
            var _local6:Boolean = hasEventListener(_arg1);
            super.addEventListener(_arg1, _arg2, _arg3, _arg4, _arg5);
            if (((((this._mediaElement) && (!(_local6)))) && (!((eventMaps[_arg1] == undefined))))){
                this.changeListeners(true, eventMaps[_arg1], _arg1);
            };
        }
        override public function removeEventListener(_arg1:String, _arg2:Function, _arg3:Boolean=false):void{
            super.removeEventListener(_arg1, _arg2, _arg3);
            if (((((this._mediaElement) && (!(hasEventListener(_arg1))))) && (!((eventMaps[_arg1] == undefined))))){
                this.changeListeners(false, eventMaps[_arg1], _arg1);
            };
        }
        private function onTraitAdd(_arg1:MediaElementEvent):void{
            this.onTraitChanged(_arg1.traitType, true);
        }
        private function onTraitRemove(_arg1:MediaElementEvent):void{
            this.onTraitChanged(_arg1.traitType, false);
        }
        private function onTraitChanged(_arg1:String, _arg2:Boolean):void{
            switch (_arg1){
                case MediaTraitType.TIME:
                    this.changeListeners(_arg2, _arg1, TimeEvent.DURATION_CHANGE);
                    this.changeListeners(_arg2, _arg1, TimeEvent.COMPLETE);
                    break;
                case MediaTraitType.PLAY:
                    this.changeListeners(_arg2, _arg1, PlayEvent.PLAY_STATE_CHANGE);
                    this.changeListeners(_arg2, _arg1, PlayEvent.CAN_PAUSE_CHANGE);
                    break;
                case MediaTraitType.AUDIO:
                    this.changeListeners(_arg2, _arg1, AudioEvent.VOLUME_CHANGE);
                    this.changeListeners(_arg2, _arg1, AudioEvent.MUTED_CHANGE);
                    this.changeListeners(_arg2, _arg1, AudioEvent.PAN_CHANGE);
                    break;
                case MediaTraitType.SEEK:
                    this.changeListeners(_arg2, _arg1, SeekEvent.SEEKING_CHANGE);
                    break;
                case MediaTraitType.DYNAMIC_STREAM:
                    this.changeListeners(_arg2, _arg1, DynamicStreamEvent.SWITCHING_CHANGE);
                    this.changeListeners(_arg2, _arg1, DynamicStreamEvent.AUTO_SWITCH_CHANGE);
                    this.changeListeners(_arg2, _arg1, DynamicStreamEvent.NUM_DYNAMIC_STREAMS_CHANGE);
                    break;
                case MediaTraitType.ALTERNATIVE_AUDIO:
                    this.changeListeners(_arg2, _arg1, AlternativeAudioEvent.AUDIO_SWITCHING_CHANGE);
                    this.changeListeners(_arg2, _arg1, AlternativeAudioEvent.NUM_ALTERNATIVE_AUDIO_STREAMS_CHANGE);
                    break;
                case MediaTraitType.DISPLAY_OBJECT:
                    this.changeListeners(_arg2, _arg1, DisplayObjectEvent.DISPLAY_OBJECT_CHANGE);
                    this.changeListeners(_arg2, _arg1, DisplayObjectEvent.MEDIA_SIZE_CHANGE);
                    break;
                case MediaTraitType.LOAD:
                    this.changeListeners(_arg2, _arg1, LoadEvent.LOAD_STATE_CHANGE);
                    this.changeListeners(_arg2, _arg1, LoadEvent.BYTES_TOTAL_CHANGE);
                    this.changeListeners(_arg2, _arg1, LoadEvent.BYTES_LOADED_CHANGE);
                    break;
                case MediaTraitType.BUFFER:
                    this.changeListeners(_arg2, _arg1, BufferEvent.BUFFERING_CHANGE);
                    this.changeListeners(_arg2, _arg1, BufferEvent.BUFFER_TIME_CHANGE);
                    break;
                case MediaTraitType.DRM:
                    this.changeListeners(_arg2, _arg1, DRMEvent.DRM_STATE_CHANGE);
                    break;
                case MediaTraitType.DVR:
                    this.changeListeners(_arg2, _arg1, DVREvent.IS_RECORDING_CHANGE);
                    break;
            };
        }
        private function changeListeners(_arg1:Boolean, _arg2:String, _arg3:String):void{
            if (this._mediaElement.getTrait(_arg2) != null){
                if (((_arg1) && (hasEventListener(_arg3)))){
                    this._mediaElement.getTrait(_arg2).addEventListener(_arg3, this.redispatchEvent);
                } else {
                    this._mediaElement.getTrait(_arg2).removeEventListener(_arg3, this.redispatchEvent);
                };
            };
        }
        private function redispatchEvent(_arg1:Event):void{
            dispatchEvent(_arg1.clone());
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class LoaderBase extends EventDispatcher {

        public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            return (false);
        }
        final public function load(_arg1:LoadTrait):void{
            this.validateLoad(_arg1);
            this.executeLoad(_arg1);
        }
        final public function unload(_arg1:LoadTrait):void{
            this.validateUnload(_arg1);
            this.executeUnload(_arg1);
        }
        protected function executeLoad(_arg1:LoadTrait):void{
        }
        protected function executeUnload(_arg1:LoadTrait):void{
        }
        final protected function updateLoadTrait(_arg1:LoadTrait, _arg2:String):void{
            var _local3:String;
            if (_arg2 != _arg1.loadState){
                _local3 = _arg1.loadState;
                dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_STATE_CHANGE, false, false, this, _arg1, _local3, _arg2));
            };
        }
        private function validateLoad(_arg1:LoadTrait):void{
            if (_arg1 == null){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (_arg1.loadState == LoadState.READY){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_READY)));
            };
            if (_arg1.loadState == LoadState.LOADING){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_LOADING)));
            };
            if (this.canHandleResource(_arg1.resource) == false){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.LOADER_CANT_HANDLE_RESOURCE)));
            };
        }
        private function validateUnload(_arg1:LoadTrait):void{
            if (_arg1 == null){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (_arg1.loadState == LoadState.UNLOADING){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_UNLOADING)));
            };
            if (_arg1.loadState == LoadState.UNINITIALIZED){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_UNLOADED)));
            };
            if (this.canHandleResource(_arg1.resource) == false){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.LOADER_CANT_HANDLE_RESOURCE)));
            };
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {

    public class DRMTrait extends MediaTraitBase {

        private var _drmState:String = "uninitialized";
        private var _period:Number = 0;
        private var _endDate:Date;
        private var _startDate:Date;

        public function DRMTrait(){
            super(MediaTraitType.DRM);
        }
        public function authenticate(_arg1:String=null, _arg2:String=null):void{
        }
        public function authenticateWithToken(_arg1:Object):void{
        }
        public function get drmState():String{
            return (this._drmState);
        }
        public function get startDate():Date{
            return (this._startDate);
        }
        public function get endDate():Date{
            return (this._endDate);
        }
        public function get period():Number{
            return (this._period);
        }
        final protected function setPeriod(_arg1:Number):void{
            this._period = _arg1;
        }
        final protected function setStartDate(_arg1:Date):void{
            this._startDate = _arg1;
        }
        final protected function setEndDate(_arg1:Date):void{
            this._endDate = _arg1;
        }
        final protected function setDrmState(_arg1:String):void{
            this._drmState = _arg1;
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;

    public class DVRTrait extends MediaTraitBase {

        private var _isRecording:Boolean;
        private var _windowDuration:Number;

        public function DVRTrait(_arg1:Boolean=false, _arg2:Number=-1){
            this._isRecording = _arg1;
            this._windowDuration = _arg2;
            super(MediaTraitType.DVR);
        }
        final public function get windowDuration():Number{
            return (this._windowDuration);
        }
        final public function get isRecording():Boolean{
            return (this._isRecording);
        }
        final protected function setIsRecording(_arg1:Boolean):void{
            if (_arg1 != this._isRecording){
                this.isRecordingChangeStart(_arg1);
                this._isRecording = _arg1;
                this.isRecordingChangeEnd();
            };
        }
        protected function isRecordingChangeStart(_arg1:Boolean):void{
        }
        protected function isRecordingChangeEnd():void{
            dispatchEvent(new DVREvent(DVREvent.IS_RECORDING_CHANGE));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class DynamicStreamTrait extends MediaTraitBase {

        private var _autoSwitch:Boolean;
        private var _currentIndex:int = 0;
        private var _maxAllowedIndex:int = 0;
        private var _numDynamicStreams:int;
        private var _switching:Boolean;

        public function DynamicStreamTrait(_arg1:Boolean=true, _arg2:int=0, _arg3:int=1){
            super(MediaTraitType.DYNAMIC_STREAM);
            this._autoSwitch = _arg1;
            this._currentIndex = _arg2;
            this._numDynamicStreams = _arg3;
            this._maxAllowedIndex = (_arg3 - 1);
            this._switching = false;
        }
        public function get autoSwitch():Boolean{
            return (this._autoSwitch);
        }
        final public function set autoSwitch(_arg1:Boolean):void{
            if (this.autoSwitch != _arg1){
                this.autoSwitchChangeStart(_arg1);
                this._autoSwitch = _arg1;
                this.autoSwitchChangeEnd();
            };
        }
        public function get numDynamicStreams():int{
            return (this._numDynamicStreams);
        }
        public function get currentIndex():int{
            return (this._currentIndex);
        }
        public function get maxAllowedIndex():int{
            return (this._maxAllowedIndex);
        }
        final public function set maxAllowedIndex(_arg1:int):void{
            if ((((_arg1 < 0)) || ((_arg1 > (this._numDynamicStreams - 1))))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            if (this.maxAllowedIndex != _arg1){
                this.maxAllowedIndexChangeStart(_arg1);
                this._maxAllowedIndex = _arg1;
                this.maxAllowedIndexChangeEnd();
            };
        }
        public function getBitrateForIndex(_arg1:int):Number{
            if ((((_arg1 > (this._numDynamicStreams - 1))) || ((_arg1 < 0)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            return (0);
        }
        public function get switching():Boolean{
            return (this._switching);
        }
        public function switchTo(_arg1:int):void{
            if (this.autoSwitch){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_STREAM_NOT_IN_MANUAL_MODE)));
            };
            if ((((_arg1 < 0)) || ((_arg1 > this.maxAllowedIndex)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            if (!this.switching){
                this.setSwitching(true, _arg1);
            };
        }
        final protected function setNumDynamicStreams(_arg1:int):void{
            if (_arg1 != this._numDynamicStreams){
                this._numDynamicStreams = _arg1;
                if (this.maxAllowedIndex >= this._numDynamicStreams){
                    this.maxAllowedIndex = Math.max(0, (this._numDynamicStreams - 1));
                };
                dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.NUM_DYNAMIC_STREAMS_CHANGE));
            };
        }
        final protected function setCurrentIndex(_arg1:int):void{
            this._currentIndex = _arg1;
        }
        final protected function setSwitching(_arg1:Boolean, _arg2:int):void{
            this.switchingChangeStart(_arg1, _arg2);
            this._switching = _arg1;
            if (_arg1 == false){
                this.setCurrentIndex(_arg2);
            };
            this.switchingChangeEnd(_arg2);
        }
        protected function autoSwitchChangeStart(_arg1:Boolean):void{
        }
        protected function autoSwitchChangeEnd():void{
            dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.AUTO_SWITCH_CHANGE, false, false, false, this._autoSwitch));
        }
        protected function switchingChangeStart(_arg1:Boolean, _arg2:int):void{
        }
        protected function switchingChangeEnd(_arg1:int):void{
            dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.SWITCHING_CHANGE, false, false, this.switching, this._autoSwitch));
        }
        protected function maxAllowedIndexChangeStart(_arg1:int):void{
        }
        protected function maxAllowedIndexChangeEnd():void{
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {

    public final class DRMState {

        public static const UNINITIALIZED:String = "uninitialized";
        public static const AUTHENTICATION_NEEDED:String = "authenticationNeeded";
        public static const AUTHENTICATING:String = "authenticating";
        public static const AUTHENTICATION_COMPLETE:String = "authenticationComplete";
        public static const AUTHENTICATION_ERROR:String = "authenticationError";
        public static const DRM_SYSTEM_UPDATING:String = "drmSystemUpdating";

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import flash.display.*;

    public class DisplayObjectTrait extends MediaTraitBase {

        private var _displayObject:DisplayObject;
        private var _mediaWidth:Number = 0;
        private var _mediaHeight:Number = 0;

        public function DisplayObjectTrait(_arg1:DisplayObject, _arg2:Number=0, _arg3:Number=0){
            super(MediaTraitType.DISPLAY_OBJECT);
            this._displayObject = _arg1;
            this._mediaWidth = _arg2;
            this._mediaHeight = _arg3;
        }
        public function get displayObject():DisplayObject{
            return (this._displayObject);
        }
        public function get mediaWidth():Number{
            return (this._mediaWidth);
        }
        public function get mediaHeight():Number{
            return (this._mediaHeight);
        }
        final protected function setDisplayObject(_arg1:DisplayObject):void{
            var _local2:DisplayObject;
            if (this._displayObject != _arg1){
                this.displayObjectChangeStart(_arg1);
                _local2 = this._displayObject;
                this._displayObject = _arg1;
                this.displayObjectChangeEnd(_local2);
            };
        }
        final protected function setMediaSize(_arg1:Number, _arg2:Number):void{
            var _local3:Number;
            var _local4:Number;
            if (((!((_arg1 == this._mediaWidth))) || (!((_arg2 == this._mediaHeight))))){
                this.mediaSizeChangeStart(_arg1, _arg2);
                _local3 = this._mediaWidth;
                _local4 = this._mediaHeight;
                this._mediaWidth = _arg1;
                this._mediaHeight = _arg2;
                this.mediaSizeChangeEnd(_local3, _local4);
            };
        }
        protected function displayObjectChangeStart(_arg1:DisplayObject):void{
        }
        protected function displayObjectChangeEnd(_arg1:DisplayObject):void{
            dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.DISPLAY_OBJECT_CHANGE, false, false, _arg1, this._displayObject));
        }
        protected function mediaSizeChangeStart(_arg1:Number, _arg2:Number):void{
        }
        protected function mediaSizeChangeEnd(_arg1:Number, _arg2:Number):void{
            dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.MEDIA_SIZE_CHANGE, false, false, null, null, _arg1, _arg2, this._mediaWidth, this._mediaHeight));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;

    public class BufferTrait extends MediaTraitBase {

        private var _buffering:Boolean = false;
        private var _bufferLength:Number = 0;
        private var _bufferTime:Number = 0;

        public function BufferTrait(){
            super(MediaTraitType.BUFFER);
        }
        public function get buffering():Boolean{
            return (this._buffering);
        }
        public function get bufferLength():Number{
            return (this._bufferLength);
        }
        public function get bufferTime():Number{
            return (this._bufferTime);
        }
        public function set bufferTime(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                _arg1 = 0;
            };
            if (_arg1 != this._bufferTime){
                this.bufferTimeChangeStart(_arg1);
                this._bufferTime = _arg1;
                this.bufferTimeChangeEnd();
            };
        }
        final protected function setBufferLength(_arg1:Number):void{
            if (_arg1 != this._bufferLength){
                this.bufferLengthChangeStart(_arg1);
                this._bufferLength = _arg1;
                this.bufferLengthChangeEnd();
            };
        }
        final protected function setBuffering(_arg1:Boolean):void{
            if (_arg1 != this._buffering){
                this.bufferingChangeStart(_arg1);
                this._buffering = _arg1;
                this.bufferingChangeEnd();
            };
        }
        protected function bufferingChangeStart(_arg1:Boolean):void{
        }
        protected function bufferingChangeEnd():void{
            dispatchEvent(new BufferEvent(BufferEvent.BUFFERING_CHANGE, false, false, this._buffering));
        }
        protected function bufferLengthChangeStart(_arg1:Number):void{
        }
        protected function bufferLengthChangeEnd():void{
        }
        protected function bufferTimeChangeStart(_arg1:Number):void{
        }
        protected function bufferTimeChangeEnd():void{
            dispatchEvent(new BufferEvent(BufferEvent.BUFFER_TIME_CHANGE, false, false, false, this._bufferTime));
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {

    public final class LoadState {

        public static const UNINITIALIZED:String = "uninitialized";
        public static const LOADING:String = "loading";
        public static const UNLOADING:String = "unloading";
        public static const READY:String = "ready";
        public static const LOAD_ERROR:String = "loadError";

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;

    public class TimeTrait extends MediaTraitBase {

        private var _duration:Number;
        private var _currentTime:Number;

        public function TimeTrait(_arg1:Number=NaN){
            super(MediaTraitType.TIME);
            this._duration = _arg1;
        }
        public function get duration():Number{
            return (this._duration);
        }
        public function get currentTime():Number{
            return (this._currentTime);
        }
        protected function durationChangeStart(_arg1:Number):void{
        }
        protected function durationChangeEnd(_arg1:Number):void{
            dispatchEvent(new TimeEvent(TimeEvent.DURATION_CHANGE, false, false, this._duration));
        }
        protected function currentTimeChangeStart(_arg1:Number):void{
        }
        protected function currentTimeChangeEnd(_arg1:Number):void{
        }
        protected function signalComplete():void{
            dispatchEvent(new TimeEvent(TimeEvent.COMPLETE));
        }
        final protected function setCurrentTime(_arg1:Number):void{
            var _local2:Number;
            if (!isNaN(_arg1)){
                if (!isNaN(this._duration)){
                    _arg1 = Math.min(_arg1, this._duration);
                } else {
                    _arg1 = 0;
                };
            };
            if (((!((this._currentTime == _arg1))) && (!(((isNaN(this._currentTime)) && (isNaN(_arg1))))))){
                this.currentTimeChangeStart(_arg1);
                _local2 = this._currentTime;
                this._currentTime = _arg1;
                this.currentTimeChangeEnd(_local2);
                if ((((this.currentTime == this.duration)) && ((this.currentTime > 0)))){
                    this.signalComplete();
                };
            };
        }
        final protected function setDuration(_arg1:Number):void{
            var _local2:Number;
            if (this._duration != _arg1){
                this.durationChangeStart(_arg1);
                _local2 = this._duration;
                this._duration = _arg1;
                this.durationChangeEnd(_local2);
                if (((((!(isNaN(this._currentTime))) && (!(isNaN(this._duration))))) && ((this._currentTime > this._duration)))){
                    this.setCurrentTime(this.duration);
                };
            };
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.traits {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class LoadTrait extends MediaTraitBase {

        private var loader:LoaderBase;
        private var _resource:MediaResourceBase;
        private var _loadState:String;
        private var _bytesLoaded:Number;
        private var _bytesTotal:Number;

        public function LoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            super(MediaTraitType.LOAD);
            this.loader = _arg1;
            this._resource = _arg2;
            this._loadState = LoadState.UNINITIALIZED;
            if (_arg1 != null){
                _arg1.addEventListener(LoaderEvent.LOAD_STATE_CHANGE, this.onLoadStateChange, false, int.MAX_VALUE, true);
            };
        }
        public function get resource():MediaResourceBase{
            return (this._resource);
        }
        public function get loadState():String{
            return (this._loadState);
        }
        public function load():void{
            if (this.loader){
                if (this._loadState == LoadState.READY){
                    throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_READY)));
                };
                if (this._loadState == LoadState.LOADING){
                    throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_LOADING)));
                };
                this.loader.load(this);
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.MUST_SET_LOADER)));
            };
        }
        public function unload():void{
            if (this.loader){
                if (this._loadState == LoadState.UNLOADING){
                    throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_UNLOADING)));
                };
                if (this._loadState == LoadState.UNINITIALIZED){
                    throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.ALREADY_UNLOADED)));
                };
                this.loader.unload(this);
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.MUST_SET_LOADER)));
            };
        }
        public function get bytesLoaded():Number{
            return (this._bytesLoaded);
        }
        public function get bytesTotal():Number{
            return (this._bytesTotal);
        }
        final protected function setLoadState(_arg1:String):void{
            if (this._loadState != _arg1){
                this.loadStateChangeStart(_arg1);
                this._loadState = _arg1;
                this.loadStateChangeEnd();
            };
        }
        final protected function setBytesLoaded(_arg1:Number):void{
            if (((((isNaN(_arg1)) || ((_arg1 > this.bytesTotal)))) || ((_arg1 < 0)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (_arg1 != this._bytesLoaded){
                this.bytesLoadedChangeStart(_arg1);
                this._bytesLoaded = _arg1;
                this.bytesLoadedChangeEnd();
            };
        }
        final protected function setBytesTotal(_arg1:Number):void{
            if ((((_arg1 < this._bytesLoaded)) || ((_arg1 < 0)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (_arg1 != this._bytesTotal){
                this.bytesTotalChangeStart(_arg1);
                this._bytesTotal = _arg1;
                this.bytesTotalChangeEnd();
            };
        }
        protected function bytesLoadedChangeStart(_arg1:Number):void{
        }
        protected function bytesLoadedChangeEnd():void{
        }
        protected function bytesTotalChangeStart(_arg1:Number):void{
        }
        protected function bytesTotalChangeEnd():void{
            dispatchEvent(new LoadEvent(LoadEvent.BYTES_TOTAL_CHANGE, false, false, null, this._bytesTotal));
        }
        protected function loadStateChangeStart(_arg1:String):void{
        }
        protected function loadStateChangeEnd():void{
            dispatchEvent(new LoadEvent(LoadEvent.LOAD_STATE_CHANGE, false, false, this._loadState));
        }
        private function onLoadStateChange(_arg1:LoaderEvent):void{
            if (_arg1.loadTrait == this){
                this.setLoadState(_arg1.newState);
            };
        }

    }
}//package org.osmf.traits 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import org.osmf.elements.audioClasses.*;
    import org.osmf.utils.*;

    public class AudioElement extends LoadableElementBase {

        private var soundAdapter:SoundAdapter;
        private var stream:NetStream;
        private var defaultTimeTrait:ModifiableTimeTrait;
        private var _alternateLoaders:Vector.<LoaderBase>;

        public function AudioElement(_arg1:URLResource=null, _arg2:LoaderBase=null){
            super(_arg1, _arg2);
            if (!(((((_arg2 == null)) || ((_arg2 is NetLoader)))) || ((_arg2 is SoundLoader)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
        }
        public function get defaultDuration():Number{
            return (((this.defaultTimeTrait) ? this.defaultTimeTrait.duration : NaN));
        }
        public function set defaultDuration(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                if (this.defaultTimeTrait != null){
                    removeTraitResolver(MediaTraitType.TIME);
                    this.defaultTimeTrait = null;
                };
            } else {
                if (this.defaultTimeTrait == null){
                    this.defaultTimeTrait = new ModifiableTimeTrait();
                    addTraitResolver(MediaTraitType.TIME, new DefaultTraitResolver(MediaTraitType.TIME, this.defaultTimeTrait));
                };
                this.defaultTimeTrait.duration = _arg1;
            };
        }
        override public function set resource(_arg1:MediaResourceBase):void{
            loader = getLoaderForResource(_arg1, this.alternateLoaders);
            super.resource = _arg1;
        }
        override protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return ((((_arg2 is NetLoader)) ? new NetStreamLoadTrait(_arg2, _arg1) : new SoundLoadTrait(_arg2, _arg1)));
        }
        override protected function processReadyState():void{
            var _local2:TimeTrait;
            var _local4:Boolean;
            var _local5:SoundLoadTrait;
            var _local1:LoadTrait = (getTrait(MediaTraitType.LOAD) as LoadTrait);
            this.soundAdapter = null;
            this.stream = null;
            var _local3:NetStreamLoadTrait = (_local1 as NetStreamLoadTrait);
            if (_local3){
                this.stream = _local3.netStream;
                this.stream.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
                _local3.connection.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent, false, 0, true);
                _local4 = false;
                if ((loader is NetLoader)){
                    _local4 = (loader as NetLoader).reconnectStreams;
                };
                addTrait(MediaTraitType.PLAY, new NetStreamPlayTrait(this.stream, resource, _local4, _local3.connection));
                _local2 = new NetStreamTimeTrait(this.stream, resource, this.defaultDuration);
                addTrait(MediaTraitType.TIME, _local2);
                addTrait(MediaTraitType.SEEK, new NetStreamSeekTrait(_local2, _local1, this.stream));
                addTrait(MediaTraitType.AUDIO, new NetStreamAudioTrait(this.stream));
                addTrait(MediaTraitType.BUFFER, new NetStreamBufferTrait(this.stream));
            } else {
                _local5 = (_local1 as SoundLoadTrait);
                this.soundAdapter = new SoundAdapter(this, _local5.sound);
                addTrait(MediaTraitType.PLAY, new AudioPlayTrait(this.soundAdapter));
                _local2 = new AudioTimeTrait(this.soundAdapter);
                addTrait(MediaTraitType.TIME, _local2);
                addTrait(MediaTraitType.SEEK, new AudioSeekTrait(_local2, this.soundAdapter));
                addTrait(MediaTraitType.AUDIO, new AudioAudioTrait(this.soundAdapter));
            };
        }
        override protected function processUnloadingState():void{
            if (this.stream != null){
                this.stream.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
            };
            var _local1:NetStreamLoadTrait = (getTrait(MediaTraitType.LOAD) as NetStreamLoadTrait);
            if (_local1 != null){
                _local1.connection.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
            };
            removeTrait(MediaTraitType.PLAY);
            removeTrait(MediaTraitType.SEEK);
            removeTrait(MediaTraitType.TIME);
            removeTrait(MediaTraitType.AUDIO);
            removeTrait(MediaTraitType.BUFFER);
            if (this.soundAdapter != null){
                this.soundAdapter.pause();
            };
            this.soundAdapter = null;
            this.stream = null;
        }
        private function onNetStatusEvent(_arg1:NetStatusEvent):void{
            var _local2:MediaError;
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                case NetStreamCodes.NETSTREAM_FAILED:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_PLAY_FAILED, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STREAMNOTFOUND:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_STREAM_NOT_FOUND, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_FILESTRUCTUREINVALID:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_FILE_STRUCTURE_INVALID, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_NOSUPPORTEDTRACKFOUND:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_NO_SUPPORTED_TRACK_FOUND, _arg1.info.description);
                    break;
                case NetConnectionCodes.CONNECT_IDLE_TIME_OUT:
                    _local2 = new MediaError(MediaErrorCodes.NETCONNECTION_TIMEOUT, _arg1.info.description);
                    break;
            };
            if (_local2 != null){
                dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, _local2));
            };
        }
        private function get alternateLoaders():Vector.<LoaderBase>{
            if (this._alternateLoaders == null){
                this._alternateLoaders = new Vector.<LoaderBase>();
                this._alternateLoaders.push(new SoundLoader());
                this._alternateLoaders.push(new NetLoader());
            };
            return (this._alternateLoaders);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements.loaderClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.display.*;
    import flash.net.*;
    import flash.utils.*;
    import flash.geom.*;
    import flash.system.*;
    import flash.errors.*;

    public class LoaderUtils {

        private static const SWF_MIME_TYPE:String = "application/x-shockwave-flash";

        public static function createDisplayObjectTrait(_arg1:Loader, _arg2:MediaElement):DisplayObjectTrait{
            var _local3:DisplayObject;
            var _local4:Number = 0;
            var _local5:Number = 0;
            var _local6:LoaderInfo = _arg1.contentLoaderInfo;
            _local3 = _arg1;
            _local3.scrollRect = new Rectangle(0, 0, _local6.width, _local6.height);
            _local4 = _local6.width;
            _local5 = _local6.height;
            return (new DisplayObjectTrait(_local3, _local4, _local5));
        }
        public static function loadLoadTrait(_arg1:LoadTrait, _arg2:Function, _arg3:Boolean, _arg4:Boolean, _arg5:Function=null):void{
            var loader:* = null;
            var onLoadComplete:* = null;
            var onIOError:* = null;
            var onSecurityError:* = null;
            var loadTrait:* = _arg1;
            var updateLoadTraitFunction:* = _arg2;
            var useCurrentSecurityDomain:* = _arg3;
            var checkPolicyFile:* = _arg4;
            var validateLoadedContentFunction = _arg5;
            var toggleLoaderListeners:* = function (_arg1:Loader, _arg2:Boolean):void{
                if (_arg2){
                    _arg1.contentLoaderInfo.addEventListener(Event.COMPLETE, onLoadComplete);
                    _arg1.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
                    _arg1.contentLoaderInfo.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);
                } else {
                    _arg1.contentLoaderInfo.removeEventListener(Event.COMPLETE, onLoadComplete);
                    _arg1.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
                    _arg1.contentLoaderInfo.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onSecurityError);
                };
            };
            onLoadComplete = function (_arg1:Event):void{
                var validated:* = false;
                var timer:* = null;
                var onTimer:* = null;
                var event:* = _arg1;
                toggleLoaderListeners(loader, false);
                if (loadTrait.loadState == LoadState.LOADING){
                    if (validateLoadedContentFunction != null){
                        validated = validateLoadedContentFunction(loader.content);
                        if (validated){
                            if (Capabilities.isDebugger){
                                onTimer = function (_arg1:TimerEvent):void{
                                    timer.removeEventListener(TimerEvent.TIMER_COMPLETE, onTimer);
                                    timer = null;
                                    loader.unloadAndStop();
                                    loader = null;
                                    loadLoadTrait(loadTrait, updateLoadTraitFunction, useCurrentSecurityDomain, false, null);
                                };
                                timer = new Timer(250, 1);
                                timer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimer);
                                timer.start();
                            } else {
                                loader.unloadAndStop();
                                loader = null;
                                loadLoadTrait(loadTrait, updateLoadTraitFunction, useCurrentSecurityDomain, false, null);
                            };
                        } else {
                            loader.unloadAndStop();
                            loader = null;
                            updateLoadTraitFunction(loadTrait, LoadState.LOAD_ERROR);
                            loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.IO_ERROR)));
                        };
                    } else {
                        updateLoadTraitFunction(loadTrait, LoadState.READY);
                    };
                };
            };
            onIOError = function (_arg1:IOErrorEvent, _arg2:String=null):void{
                toggleLoaderListeners(loader, false);
                loader = null;
                updateLoadTraitFunction(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.IO_ERROR, ((_arg1) ? _arg1.text : _arg2))));
            };
            onSecurityError = function (_arg1:SecurityErrorEvent, _arg2:String=null):void{
                toggleLoaderListeners(loader, false);
                loader = null;
                updateLoadTraitFunction(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.SECURITY_ERROR, ((_arg1) ? _arg1.text : _arg2))));
            };
            var loaderLoadTrait:* = (loadTrait as LoaderLoadTrait);
            loader = new Loader();
            loaderLoadTrait.loader = loader;
            updateLoadTraitFunction(loadTrait, LoadState.LOADING);
            var context:* = new LoaderContext();
            var urlReq:* = new URLRequest((loadTrait.resource as URLResource).url.toString());
            context.checkPolicyFile = checkPolicyFile;
            if (((useCurrentSecurityDomain) && ((urlReq.url.search(/^file:\//i) == -1)))){
                context.securityDomain = SecurityDomain.currentDomain;
            };
            if (validateLoadedContentFunction != null){
                context.applicationDomain = new ApplicationDomain();
            };
            toggleLoaderListeners(loader, true);
            try {
                loader.load(urlReq, context);
            } catch(ioError:IOError) {
                onIOError(null, ioError.message);
            } catch(securityError:SecurityError) {
                onSecurityError(null, securityError.message);
            };
        }
        public static function unloadLoadTrait(_arg1:LoadTrait, _arg2:Function):void{
            var _local3:LoaderLoadTrait = (_arg1 as LoaderLoadTrait);
            _arg2(_arg1, LoadState.UNLOADING);
            _local3.loader.unloadAndStop();
            _arg2(_arg1, LoadState.UNINITIALIZED);
        }

    }
}//package org.osmf.elements.loaderClasses 
﻿package org.osmf.elements.loaderClasses {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.display.*;

    public class LoaderLoadTrait extends LoadTrait {

        private var _loader:Loader;

        public function LoaderLoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            super(_arg1, _arg2);
        }
        public function get loader():Loader{
            return (this._loader);
        }
        public function set loader(_arg1:Loader):void{
            this._loader = _arg1;
        }
        override protected function loadStateChangeStart(_arg1:String):void{
            if (_arg1 == LoadState.LOADING){
                this.loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, this.onContentLoadProgress, false, 0, true);
            } else {
                if (_arg1 == LoadState.READY){
                    setBytesTotal(this.loader.contentLoaderInfo.bytesTotal);
                    setBytesLoaded(this.loader.contentLoaderInfo.bytesLoaded);
                    this.loader.contentLoaderInfo.addEventListener(ProgressEvent.PROGRESS, this.onContentLoadProgress, false, 0, true);
                } else {
                    if (_arg1 == LoadState.UNINITIALIZED){
                        setBytesLoaded(0);
                    };
                };
            };
        }
        private function onContentLoadProgress(_arg1:ProgressEvent):void{
            setBytesTotal(_arg1.bytesTotal);
            setBytesLoaded(_arg1.bytesLoaded);
        }

    }
}//package org.osmf.elements.loaderClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.utils.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class DVRInfoParser extends BaseParser {

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local7:Number;
            var _local8:String;
            var _local9:String;
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            var _local5:Number = (F4MUtils.getVersion(_arg1).major as Number);
            var _local6:DVRInfo = new DVRInfo();
            if (_local4.attribute("id").length() > 0){
                _local6.id = _local4.@id;
            } else {
                _local6.id = F4MUtils.GLOBAL_ELEMENT_ID;
            };
            if (_local4.attribute("url").length() > 0){
                _local8 = _local4.@url;
                if (!URL.isAbsoluteURL(_local8)){
                    _local8 = (URL.normalizeRootURL(_arg2) + URL.normalizeRelativeURL(_local8));
                };
                _local6.url = _local8;
            };
            if (_local5 <= 1){
                if (_local4.attribute("beginOffset").length() > 0){
                    _local6.beginOffset = Math.max(0, parseInt(_local4.@beginOffset));
                };
                if (_local4.attribute("endOffset").length() > 0){
                    _local7 = new Number(_local4.@endOffset);
                    if ((((_local7 > 0)) && ((_local7 < 1)))){
                        _local6.endOffset = 1;
                    } else {
                        _local6.endOffset = Math.max(0, _local7);
                    };
                };
                _local6.windowDuration = -1;
            } else {
                if (_local4.attribute("windowDuration").length() > 0){
                    _local7 = parseInt(_local4.@windowDuration);
                    if (((isNaN(_local7)) || ((_local7 < 0)))){
                        _local6.windowDuration = -1;
                    } else {
                        _local6.windowDuration = _local7;
                    };
                } else {
                    _local6.windowDuration = -1;
                };
            };
            if (_local4.attribute("offline").length() > 0){
                _local9 = _local4.@offline;
                _local6.offline = (_local9.toLowerCase() == "true");
            };
            this.finishLoad(_local6);
        }
        protected function finishLoad(_arg1:DVRInfo):void{
            if (!_arg1){
                return;
            };
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class DRMAdditionalHeaderParser extends BaseParser {

        private var loadingInfo:Dictionary;

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local7:String;
            var _local8:Base64Decoder;
            var _local9:URLLoader;
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            var _local5:DRMAdditionalHeader = new DRMAdditionalHeader();
            var _local6:String;
            if (_local4.attribute("id").length() > 0){
                _local5.id = (_arg3 + _local4.@id);
            } else {
                _local5.id = (_arg3 + F4MUtils.GLOBAL_ELEMENT_ID);
            };
            if (_local4.attribute("url").length() > 0){
                _local6 = _local4.@url;
                if (!URL.isAbsoluteURL(_local6)){
                    _local6 = (URL.normalizeRootURL(_arg2) + URL.normalizeRelativeURL(_local6));
                };
                _local5.url = _local6;
            } else {
                _local7 = _local4.text();
                _local8 = new Base64Decoder();
                _local8.decode(_local7);
                _local5.data = _local8.drain();
            };
            if (_local6 != null){
                if (!this.loadingInfo){
                    this.loadingInfo = new Dictionary(true);
                };
                _local9 = new URLLoader();
                _local9.dataFormat = URLLoaderDataFormat.BINARY;
                _local9.addEventListener(Event.COMPLETE, this.onLoadComplete);
                _local9.addEventListener(IOErrorEvent.IO_ERROR, this.onLoadError);
                _local9.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onLoadError);
                this.loadingInfo[_local9] = _local5;
                _local9.load(new URLRequest(HTTPStreamingUtils.normalizeURL(_local6)));
            } else {
                this.finishLoad(_local5);
            };
        }
        protected function finishLoad(_arg1:DRMAdditionalHeader):void{
            if (!_arg1){
                return;
            };
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }
        private function onLoadComplete(_arg1:Event):void{
            var _local2:URLLoader = (_arg1.target as URLLoader);
            _local2.removeEventListener(Event.COMPLETE, this.onLoadComplete);
            _local2.removeEventListener(IOErrorEvent.IO_ERROR, this.onLoadError);
            _local2.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onLoadError);
            var _local3:DRMAdditionalHeader = this.loadingInfo[_local2];
            _local3.data = _local2.data;
            delete this.loadingInfo[_local2];
            this.finishLoad(_local3);
        }
        private function onLoadError(_arg1:Event):void{
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_ERROR));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import flash.utils.*;

    public class BootstrapInfo {

        public var data:ByteArray;
        public var url:String;
        public var profile:String;
        public var id:String;

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.utils.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class BestEffortFetchInfoParser extends BaseParser {

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local7:Number;
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            var _local5:Number = (F4MUtils.getVersion(_arg1).major as Number);
            var _local6:BestEffortFetchInfo = new BestEffortFetchInfo();
            if (_local4.attribute("segmentDuration").length() > 0){
                _local7 = Math.round((parseFloat(_local4.@segmentDuration) * 1000));
                if (((isNaN(_local7)) || ((_local7 <= 0)))){
                    throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR)));
                };
                _local6.segmentDuration = uint(_local7);
            } else {
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            if (_local4.attribute("fragmentDuration").length() > 0){
                _local7 = Math.round((parseFloat(_local4.@fragmentDuration) * 1000));
                if (((isNaN(_local7)) || ((_local7 <= 0)))){
                    throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR)));
                };
                _local6.fragmentDuration = uint(_local7);
            } else {
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            if (_local4.attribute("maxForwardFetches").length() > 0){
                _local7 = parseInt(_local4.@maxForwardFetches);
                if (((!(isNaN(_local7))) && ((_local7 > 0)))){
                    _local6.maxForwardFetches = uint(_local7);
                };
            };
            if (_local4.attribute("maxBackwardFetches").length() > 0){
                _local7 = parseInt(_local4.@maxBackwardFetches);
                if (((!(isNaN(_local7))) && ((_local7 >= 0)))){
                    _local6.maxBackwardFetches = uint(_local7);
                };
            };
            this.finishLoad(_local6);
        }
        protected function finishLoad(_arg1:BestEffortFetchInfo):void{
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.utils.*;

    public class ExternalMediaParser extends MediaParser {

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            if (_local4.attribute("href").length() > 0){
                dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, null));
            } else {
                super.parse(_arg1, _arg2, _arg3);
            };
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import __AS3__.vec.*;
    import org.osmf.net.httpstreaming.dvr.*;

    public class Manifest {

        public var id:String;
        public var label:String;
        public var lang:String;
        public var baseURL:String;
        public var urlIncludesFMSApplicationInstance:Boolean = false;
        public var duration:Number;
        public var mimeType:String;
        public var streamType:String;
        public var deliveryType:String;
        public var startTime:Date;
        public var bootstrapInfos:Vector.<BootstrapInfo>;
        public var drmAdditionalHeaders:Vector.<DRMAdditionalHeader>;
        public var media:Vector.<Media>;
        public var alternativeMedia:Vector.<Media>;
        public var dvrInfo:DVRInfo = null;
        public var bestEffortFetchInfo:BestEffortFetchInfo = null;

        public function Manifest(){
            this.bootstrapInfos = new Vector.<BootstrapInfo>();
            this.drmAdditionalHeaders = new Vector.<DRMAdditionalHeader>();
            this.media = new Vector.<Media>();
            this.alternativeMedia = new Vector.<Media>();
            super();
        }
    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import org.osmf.net.httpstreaming.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.utils.*;

    public class ManifestParser extends EventDispatcher {

        private var parsing:Boolean = false;
        private var unfinishedLoads:Number = 0;
        private var isMulticast:Boolean;
        private var bitrateMissing:Boolean;
        private var mediaParser:BaseParser;
        private var dvrInfoParser:BaseParser;
        private var drmAdditionalHeaderParser:BaseParser;
        private var bootstrapInfoParser:BaseParser;
        private var bootstraps:Vector.<BootstrapInfo>;
        private var bestEffortFetchInfoParser:BaseParser;
        private var manifest:Manifest;

        public function ManifestParser(){
            this.mediaParser = this.buildMediaParser();
            this.mediaParser.addEventListener(ParseEvent.PARSE_COMPLETE, this.onMediaLoadComplete, false, 0, true);
            this.mediaParser.addEventListener(ParseEvent.PARSE_ERROR, this.onAdditionalLoadError, false, 0, true);
            this.dvrInfoParser = this.buildDVRInfoParser();
            this.dvrInfoParser.addEventListener(ParseEvent.PARSE_COMPLETE, this.onDVRInfoLoadComplete, false, 0, true);
            this.dvrInfoParser.addEventListener(ParseEvent.PARSE_ERROR, this.onAdditionalLoadError, false, 0, true);
            this.drmAdditionalHeaderParser = this.buildDRMAdditionalHeaderParser();
            this.drmAdditionalHeaderParser.addEventListener(ParseEvent.PARSE_COMPLETE, this.onDRMAdditionalHeaderLoadComplete, false, 0, true);
            this.drmAdditionalHeaderParser.addEventListener(ParseEvent.PARSE_ERROR, this.onAdditionalLoadError, false, 0, true);
            this.bootstrapInfoParser = this.buildBootstrapInfoParser();
            this.bootstrapInfoParser.addEventListener(ParseEvent.PARSE_COMPLETE, this.onBootstrapInfoLoadComplete, false, 0, true);
            this.bootstrapInfoParser.addEventListener(ParseEvent.PARSE_ERROR, this.onAdditionalLoadError, false, 0, true);
            this.bestEffortFetchInfoParser = this.buildBestEffortFetchInfoParser();
            this.bestEffortFetchInfoParser.addEventListener(ParseEvent.PARSE_COMPLETE, this.onBestEffortFetchLoadComplete, false, 0, true);
            this.bestEffortFetchInfoParser.addEventListener(ParseEvent.PARSE_ERROR, this.onAdditionalLoadError, false, 0, true);
        }
        public function parse(_arg1:String, _arg2:String=null, _arg3:Manifest=null, _arg4:String=""):void{
            var _local8:XML;
            var _local9:XML;
            var _local10:XML;
            var _local11:XML;
            var _local12:XML;
            if (!_arg1){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            this.parsing = true;
            if (!_arg3){
                _arg3 = new Manifest();
            };
            this.manifest = _arg3;
            this.isMulticast = false;
            this.bitrateMissing = false;
            var _local5:XML = new XML(_arg1);
            var _local6:Namespace = _local5.namespace();
            if (_local5._local6::id.length() > 0){
                _arg3.id = _local5._local6::id.text();
            };
            if (_local5._local6::label.length() > 0){
                _arg3.label = _local5._local6::label.text();
            };
            if (_local5._local6::lang.length() > 0){
                _arg3.lang = _local5._local6::lang.text();
            };
            if (_local5._local6::duration.length() > 0){
                _arg3.duration = _local5._local6::duration.text();
            };
            if (_local5._local6::startTime.length() > 0){
                _arg3.startTime = DateUtil.parseW3CDTF(_local5._local6::startTime.text());
            };
            if (_local5._local6::mimeType.length() > 0){
                _arg3.mimeType = _local5._local6::mimeType.text();
            };
            if (_local5._local6::streamType.length() > 0){
                _arg3.streamType = _local5._local6::streamType.text();
            };
            if (_local5._local6::deliveryType.length() > 0){
                _arg3.deliveryType = _local5._local6::deliveryType.text();
            };
            if (_local5._local6::baseURL.length() > 0){
                _arg3.baseURL = _local5._local6::baseURL.text();
            };
            if (_local5._local6::urlIncludesFMSApplicationInstance.length() > 0){
                _arg3.urlIncludesFMSApplicationInstance = (_local5._local6::urlIncludesFMSApplicationInstance.text() == "true");
            };
            var _local7:String = _arg2;
            if (_arg3.baseURL != null){
                _local7 = _arg3.baseURL;
            };
            _local7 = URL.normalizePathForURL(_local7, false);
            for each (_local8 in _local5._local6::dvrInfo) {
                this.unfinishedLoads++;
                this.parseDVRInfo(_local8, _local7);
                break;
            };
            for each (_local9 in _local5._local6::media) {
                this.unfinishedLoads++;
                this.parseMedia(_local9, _local7, _arg4);
            };
            for each (_local10 in _local5._local6::drmAdditionalHeader) {
                this.unfinishedLoads++;
                this.parseDRMAdditionalHeader(_local10, _local7, _arg4);
            };
            this.bootstraps = new Vector.<BootstrapInfo>();
            for each (_local11 in _local5._local6::bootstrapInfo) {
                this.unfinishedLoads++;
                this.parseBootstrapInfo(_local11, _local7, _arg4);
            };
            for each (_local12 in _local5._local6::bestEffortFetchInfo) {
                this.unfinishedLoads++;
                this.parseBestEffortFetchInfo(_local12, _local7);
                break;
            };
            this.generateRTMPBaseURL(_arg3);
            this.parsing = false;
            this.finishLoad(_arg3);
        }
        public function createResource(_arg1:Manifest, _arg2:MediaResourceBase):MediaResourceBase{
            var _local5:StreamingURLResource;
            var _local6:Media;
            var _local7:Vector.<String>;
            var _local8:String;
            var _local9:String;
            var _local10:URL;
            var _local13:String;
            var _local14:String;
            var _local15:DynamicStreamingResource;
            var _local16:Vector.<DynamicStreamingItem>;
            var _local17:String;
            var _local18:DynamicStreamingItem;
            var _local19:int;
            var _local20:StreamingURLResource;
            var _local21:StreamingXMLResource;
            var _local3:Metadata;
            var _local4:Metadata;
            if ((_arg2 is URLResource)){
                _local10 = new URL((_arg2 as URLResource).url);
            } else {
                if ((_arg2 is StreamingXMLResource)){
                    _local10 = new URL((_arg2 as StreamingXMLResource).url);
                };
            };
            var _local11:String = ("/" + _local10.path);
            _local11 = _local11.substr(0, _local11.lastIndexOf("/"));
            var _local12:String = ((((_local10.protocol + "://") + _local10.host) + ((_local10.port)!="") ? (":" + _local10.port) : "") + _local11);
            if (_arg1.media.length == 1){
                _local6 = (_arg1.media[0] as Media);
                _local8 = _local6.url;
                _local13 = null;
                if (URL.isAbsoluteURL(_local8)){
                    _local13 = _local6.url.substr(0, _local6.url.lastIndexOf("/"));
                } else {
                    if (_arg1.baseURL != null){
                        _local13 = _arg1.baseURL;
                    } else {
                        _local13 = _local12;
                    };
                };
                _local13 = URL.normalizeRootURL(_local13);
                if (((((((!((_local6.multicastGroupspec == null))) && ((_local6.multicastGroupspec.length > 0)))) && (!((_local6.multicastStreamName == null))))) && ((_local6.multicastStreamName.length > 0)))){
                    if (URL.isAbsoluteURL(_local8)){
                        _local5 = new MulticastResource(_local8, this.streamType(_arg1));
                    } else {
                        if (_arg1.baseURL != null){
                            _local5 = new MulticastResource((URL.normalizeRootURL(_arg1.baseURL) + URL.normalizeRelativeURL(_local8)), this.streamType(_arg1));
                        } else {
                            _local5 = new MulticastResource((URL.normalizeRootURL(_local12) + URL.normalizeRelativeURL(_local8)), this.streamType(_arg1));
                        };
                    };
                    MulticastResource(_local5).groupspec = _local6.multicastGroupspec;
                    MulticastResource(_local5).streamName = _local6.multicastStreamName;
                } else {
                    if (URL.isAbsoluteURL(_local8)){
                        _local5 = new StreamingURLResource(_local8, this.streamType(_arg1));
                    } else {
                        if (_arg1.baseURL != null){
                            _local5 = new StreamingURLResource((URL.normalizeRootURL(_arg1.baseURL) + URL.normalizeRelativeURL(_local8)), this.streamType(_arg1));
                        } else {
                            _local5 = new StreamingURLResource((URL.normalizeRootURL(_local12) + URL.normalizeRelativeURL(_local8)), this.streamType(_arg1));
                        };
                    };
                };
                _local5.urlIncludesFMSApplicationInstance = _arg1.urlIncludesFMSApplicationInstance;
                if (((!((_local6.bootstrapInfo == null))) && (((!((_local6.bootstrapInfo.data == null))) || (!((_local6.bootstrapInfo.url == null))))))){
                    _local7 = new Vector.<String>();
                    _local7.push(_local13);
                    _local9 = _local6.bootstrapInfo.url;
                    if (((!((_local6.bootstrapInfo.url == null))) && ((URL.isAbsoluteURL(_local6.bootstrapInfo.url) == false)))){
                        _local9 = (URL.normalizeRootURL(_local12) + URL.normalizeRelativeURL(_local9));
                        _local6.bootstrapInfo.url = _local9;
                    };
                    _local4 = new Metadata();
                    _local4.addValue(MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY, _local6.bootstrapInfo);
                    if (_local7.length > 0){
                        _local4.addValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY, _local7);
                    };
                };
                if (_local6.metadata != null){
                    if (_local4 == null){
                        _local4 = new Metadata();
                    };
                    _local4.addValue(MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY, _local6.metadata);
                };
                if (_local6.xmp != null){
                    if (_local4 == null){
                        _local4 = new Metadata();
                    };
                    _local4.addValue(MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY, _local6.xmp);
                };
                if (_local6.drmAdditionalHeader != null){
                    _local3 = new Metadata();
                    if (((!((Media(_arg1.media[0]).drmAdditionalHeader == null))) && (!((Media(_arg1.media[0]).drmAdditionalHeader.data == null))))){
                        _local3.addValue(MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY, Media(_arg1.media[0]).drmAdditionalHeader.data);
                        _local5.drmContentData = this.extractDRMMetadata(Media(_arg1.media[0]).drmAdditionalHeader.data);
                    };
                };
                if (_local4 != null){
                    _local5.addMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA, _local4);
                };
                if (_local3 != null){
                    _local5.addMetadataValue(MetadataNamespaces.DRM_METADATA, _local3);
                };
            } else {
                if (_arg1.media.length > 1){
                    _local14 = ((_arg1.baseURL)!=null) ? _arg1.baseURL : _local12;
                    _local14 = URL.normalizeRootURL(_local14);
                    _local7 = new Vector.<String>();
                    _local7.push(_local14);
                    _local15 = new DynamicStreamingResource(_local14, this.streamType(_arg1));
                    _local15.urlIncludesFMSApplicationInstance = _arg1.urlIncludesFMSApplicationInstance;
                    _local16 = new Vector.<DynamicStreamingItem>();
                    if (NetStreamUtils.isRTMPStream(_local14) == false){
                        _local4 = new Metadata();
                        _local15.addMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA, _local4);
                        _local4.addValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY, _local7);
                    };
                    for each (_local6 in _arg1.media) {
                        if (URL.isAbsoluteURL(_local6.url)){
                            _local17 = NetStreamUtils.getStreamNameFromURL(_local6.url, _local15.urlIncludesFMSApplicationInstance);
                        } else {
                            _local17 = _local6.url;
                        };
                        _local18 = new DynamicStreamingItem(_local17, _local6.bitrate, _local6.width, _local6.height);
                        _local16.push(_local18);
                        if (_local6.drmAdditionalHeader != null){
                            if (_local15.getMetadataValue(MetadataNamespaces.DRM_METADATA) == null){
                                _local3 = new Metadata();
                                _local15.addMetadataValue(MetadataNamespaces.DRM_METADATA, _local3);
                            };
                            if (((!((_local6.drmAdditionalHeader == null))) && (!((_local6.drmAdditionalHeader.data == null))))){
                                _local3.addValue(_local18.streamName, this.extractDRMMetadata(_local6.drmAdditionalHeader.data));
                                _local3.addValue((MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY + _local18.streamName), _local6.drmAdditionalHeader.data);
                            };
                        };
                        if (((!((_local6.bootstrapInfo == null))) && (((!((_local6.bootstrapInfo.url == null))) || (!((_local6.bootstrapInfo.data == null))))))){
                            _local9 = ((_local6.bootstrapInfo.url) ? _local6.bootstrapInfo.url : null);
                            if (((!((_local6.bootstrapInfo.url == null))) && ((URL.isAbsoluteURL(_local6.bootstrapInfo.url) == false)))){
                                _local9 = (URL.normalizeRootURL(_local12) + URL.normalizeRelativeURL(_local9));
                                _local6.bootstrapInfo.url = _local9;
                            };
                            if (_local4 != null){
                                _local4.addValue((MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY + _local18.streamName), _local6.bootstrapInfo);
                            };
                        };
                        if (_local6.metadata != null){
                            if (_local4 != null){
                                _local4.addValue((MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY + _local18.streamName), _local6.metadata);
                            };
                        };
                        if (_local6.xmp != null){
                            if (_local4 != null){
                                _local4.addValue((MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY + _local18.streamName), _local6.xmp);
                            };
                        };
                    };
                    _local15.streamItems = _local16;
                    if (_arg2.getMetadataValue(MetadataNamespaces.RESOURCE_INITIAL_INDEX) != null){
                        _local19 = (_arg2.getMetadataValue(MetadataNamespaces.RESOURCE_INITIAL_INDEX) as int);
                        if (_local19 < 0){
                            _local15.initialIndex = 0;
                        } else {
                            if (_local19 >= _local15.streamItems.length){
                                _local15.initialIndex = (_local15.streamItems.length - 1);
                            } else {
                                _local15.initialIndex = _local19;
                            };
                        };
                    };
                    _local5 = _local15;
                } else {
                    if (_arg1.baseURL == null){
                        throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_MEDIA_URL_MISSING)));
                    };
                    if (_arg1.media.length == 0){
                        throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_MEDIA_MISSING)));
                    };
                };
            };
            if (_arg1.mimeType != null){
                _local5.mediaType = MediaType.VIDEO;
                _local5.mimeType = _arg1.mimeType;
            };
            if ((_arg2 is URLResource)){
                _local20 = (_arg2 as StreamingURLResource);
                if (_local20 != null){
                    _local5.clipStartTime = _local20.clipStartTime;
                    _local5.clipEndTime = _local20.clipEndTime;
                };
            } else {
                if ((_arg2 is StreamingXMLResource)){
                    _local21 = (_arg2 as StreamingXMLResource);
                    _local5.clipStartTime = _local21.clipStartTime;
                    _local5.clipEndTime = _local21.clipEndTime;
                };
            };
            _local5.addMetadataValue(MetadataNamespaces.DERIVED_RESOURCE_METADATA, _arg2);
            HTTPStreamingUtils.addDVRInfoMetadataToResource(_arg1.dvrInfo, _local5);
            HTTPStreamingUtils.addBestEffortFetchInfoMetadataToResource(_arg1.bestEffortFetchInfo, _local5);
            if (NetStreamUtils.isRTMPStream(_local14) == false){
                this.addAlternativeMedia(_arg1, _local5, _local12);
            };
            this.bootstraps = null;
            return (_local5);
        }
        protected function buildMediaParser():BaseParser{
            return (new MediaParser());
        }
        protected function buildDVRInfoParser():BaseParser{
            return (new DVRInfoParser());
        }
        protected function buildDRMAdditionalHeaderParser():BaseParser{
            return (new DRMAdditionalHeaderParser());
        }
        protected function buildBootstrapInfoParser():BaseParser{
            return (new BootstrapInfoParser());
        }
        protected function buildBestEffortFetchInfoParser():BaseParser{
            return (new BestEffortFetchInfoParser());
        }
        protected function validateManifest(_arg1:Manifest, _arg2:Boolean, _arg3:Boolean):void{
            if ((((_arg1.media.length > 1)) && (_arg2))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.MULTICAST_NOT_SUPPORT_MBR)));
            };
            if (((((_arg1.media.length + _arg1.alternativeMedia.length) > 1)) && (_arg3))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_BITRATE_MISSING)));
            };
            if (_arg2){
                _arg1.streamType = StreamType.LIVE;
            };
        }
        protected function finishLoad(_arg1:Manifest):void{
            if (this.parsing){
                return;
            };
            if (this.unfinishedLoads > 0){
                return;
            };
            if (!_arg1){
                return;
            };
            this.validateManifest(_arg1, this.isMulticast, this.bitrateMissing);
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }
        private function parseMedia(_arg1:XML, _arg2:String, _arg3:String=""):void{
            this.mediaParser.parse(_arg1.toXMLString(), _arg2, _arg3);
        }
        private function parseDVRInfo(_arg1:XML, _arg2:String):void{
            this.dvrInfoParser.parse(_arg1.toXMLString(), _arg2);
        }
        private function parseDRMAdditionalHeader(_arg1:XML, _arg2:String, _arg3:String=""):void{
            this.drmAdditionalHeaderParser.parse(_arg1.toXMLString(), _arg2, _arg3);
        }
        private function parseBootstrapInfo(_arg1:XML, _arg2:String, _arg3:String=""):void{
            this.bootstrapInfoParser.parse(_arg1.toXMLString(), _arg2, _arg3);
        }
        private function parseBestEffortFetchInfo(_arg1:XML, _arg2:String, _arg3:String=""):void{
            this.bestEffortFetchInfoParser.parse(_arg1.toXMLString(), _arg2, _arg3);
        }
        private function generateRTMPBaseURL(_arg1:Manifest):void{
            var _local2:Media;
            if (_arg1.baseURL == null){
                for each (_local2 in _arg1.media) {
                    if (NetStreamUtils.isRTMPStream(_local2.url)){
                        _arg1.baseURL = _local2.url;
                        break;
                    };
                };
            };
        }
        private function isSupportedType(_arg1:String):Boolean{
            return ((((_arg1 == StreamingItemType.VIDEO)) || ((_arg1 == StreamingItemType.AUDIO))));
        }
        private function extractDRMMetadata(_arg1:ByteArray):ByteArray{
            var header:* = null;
            var encryption:* = null;
            var enc:* = null;
            var params:* = null;
            var version:* = null;
            var keyInfo:* = null;
            var keyInfoData:* = null;
            var drmMetadata:* = null;
            var decoder:* = null;
            var data:* = _arg1;
            var metadata:* = null;
            data.position = 0;
            data.objectEncoding = 0;
            try {
                header = data.readObject();
                encryption = data.readObject();
                enc = encryption["Encryption"];
                params = enc["Params"];
                version = enc["Version"].toString();
                keyInfo = params["KeyInfo"];
                keyInfoData = null;
                switch (version){
                    case "2":
                        keyInfoData = keyInfo["FMRMS_METADATA"];
                        break;
                    case "3":
                        keyInfoData = keyInfo["Data"];
                        break;
                };
                if (keyInfoData != null){
                    drmMetadata = (keyInfoData["Metadata"] as String);
                    decoder = new Base64Decoder();
                    decoder.decode(drmMetadata);
                    metadata = decoder.drain();
                };
            } catch(e:Error) {
                metadata = null;
            };
            return (metadata);
        }
        private function addAlternativeMedia(_arg1:Manifest, _arg2:StreamingURLResource, _arg3:String):void{
            var _local5:Metadata;
            var _local7:Media;
            var _local8:String;
            var _local9:Object;
            var _local10:StreamingItem;
            var _local11:String;
            if (_arg1.alternativeMedia.length == 0){
                return;
            };
            var _local4:Metadata = (_arg2.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) as Metadata);
            if (_local4 == null){
                _local4 = new Metadata();
                _arg2.addMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA, _local4);
            };
            var _local6:Vector.<StreamingItem> = new Vector.<StreamingItem>();
            for each (_local7 in _arg1.alternativeMedia) {
                if (URL.isAbsoluteURL(_local7.url)){
                    _local8 = NetStreamUtils.getStreamNameFromURL(_local7.url, _arg2.urlIncludesFMSApplicationInstance);
                } else {
                    _local8 = _local7.url;
                };
                _local9 = new Object();
                _local9.label = _local7.label;
                _local9.language = _local7.language;
                _local10 = new StreamingItem(_local7.type, _local8, _local7.bitrate, _local9);
                _local6.push(_local10);
                if (_local7.drmAdditionalHeader != null){
                    if (_arg2.getMetadataValue(MetadataNamespaces.DRM_METADATA) == null){
                        _local5 = new Metadata();
                        _arg2.addMetadataValue(MetadataNamespaces.DRM_METADATA, _local5);
                    } else {
                        _local5 = (_arg2.getMetadataValue(MetadataNamespaces.DRM_METADATA) as Metadata);
                    };
                    if (((!((_local7.drmAdditionalHeader == null))) && (!((_local7.drmAdditionalHeader.data == null))))){
                        _local5.addValue(_local10.streamName, this.extractDRMMetadata(_local7.drmAdditionalHeader.data));
                        _local5.addValue((MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY + _local10.streamName), _local7.drmAdditionalHeader.data);
                    };
                };
                if (((!((_local7.bootstrapInfo == null))) && (((!((_local7.bootstrapInfo.url == null))) || (!((_local7.bootstrapInfo.data == null))))))){
                    _local11 = ((_local7.bootstrapInfo.url) ? _local7.bootstrapInfo.url : null);
                    if (((!((_local7.bootstrapInfo.url == null))) && ((URL.isAbsoluteURL(_local7.bootstrapInfo.url) == false)))){
                        _local11 = (URL.normalizeRootURL(_arg3) + URL.normalizeRelativeURL(_local11));
                        _local7.bootstrapInfo.url = _local11;
                    };
                    _local4.addValue((MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY + _local10.streamName), _local7.bootstrapInfo);
                };
                if (_local7.metadata != null){
                    _local4.addValue((MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY + _local10.streamName), _local7.metadata);
                };
                if (_local7.xmp != null){
                    _local4.addValue((MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY + _local10.streamName), _local7.xmp);
                };
            };
            _arg2.alternativeAudioStreamItems = _local6;
        }
        private function streamType(_arg1:Manifest):String{
            return ((((((_arg1.streamType == StreamType.LIVE)) && (!((_arg1.dvrInfo == null))))) ? StreamType.DVR : _arg1.streamType));
        }
        private function onMediaLoadComplete(_arg1:ParseEvent):void{
            var _local3:BootstrapInfo;
            var _local2:Media = (_arg1.data as Media);
            if (_local2){
                if (((!((_local2.multicastGroupspec == null))) && ((_local2.multicastGroupspec.length > 0)))){
                    this.isMulticast = true;
                };
                if (this.isSupportedType(_local2.type)){
                    if (_local2.label == null){
                        _local2.label = this.manifest.label;
                    };
                    if (_local2.language == null){
                        _local2.language = this.manifest.lang;
                    };
                    if (_local2.alternate){
                        if (_local2.type == StreamingItemType.AUDIO){
                            this.manifest.alternativeMedia.push(_local2);
                        };
                    } else {
                        this.manifest.media.push(_local2);
                    };
                };
                if (((this.bootstraps) && ((this.bootstraps.length > 0)))){
                    for each (_local3 in this.bootstraps) {
                        if (_local2.bootstrapInfo == null){
                            _local2.bootstrapInfo = _local3;
                            break;
                        };
                        if (_local2.bootstrapInfo.id == _local3.id){
                            _local2.bootstrapInfo = _local3;
                            break;
                        };
                    };
                };
                this.bitrateMissing = ((this.bitrateMissing) || (isNaN(_local2.bitrate)));
            };
            this.onAdditionalLoadComplete(_arg1);
        }
        private function onDVRInfoLoadComplete(_arg1:ParseEvent):void{
            this.manifest.dvrInfo = (_arg1.data as DVRInfo);
            this.onAdditionalLoadComplete(_arg1);
        }
        private function onDRMAdditionalHeaderLoadComplete(_arg1:ParseEvent):void{
            var _local4:Media;
            var _local2:DRMAdditionalHeader = (_arg1.data as DRMAdditionalHeader);
            this.manifest.drmAdditionalHeaders.push(_local2);
            var _local3:Vector.<Media> = this.manifest.media.concat(this.manifest.alternativeMedia);
            for each (_local4 in _local3) {
                if (((!((_local4.drmAdditionalHeader == null))) && ((_local4.drmAdditionalHeader.id == _local2.id)))){
                    _local4.drmAdditionalHeader = _local2;
                };
            };
            this.onAdditionalLoadComplete(_arg1);
        }
        private function onBootstrapInfoLoadComplete(_arg1:ParseEvent):void{
            var _local4:Media;
            var _local2:BootstrapInfo = (_arg1.data as BootstrapInfo);
            this.bootstraps.push(_local2);
            var _local3:Vector.<Media> = this.manifest.media.concat(this.manifest.alternativeMedia);
            for each (_local4 in _local3) {
                if (_local4.bootstrapInfo == null){
                    _local4.bootstrapInfo = _local2;
                } else {
                    if (_local4.bootstrapInfo.id == _local2.id){
                        _local4.bootstrapInfo = _local2;
                    };
                };
            };
            this.onAdditionalLoadComplete(_arg1);
        }
        private function onBestEffortFetchLoadComplete(_arg1:ParseEvent):void{
            this.manifest.bestEffortFetchInfo = (_arg1.data as BestEffortFetchInfo);
            this.onAdditionalLoadComplete(_arg1);
        }
        private function onAdditionalLoadComplete(_arg1:Event):void{
            this.unfinishedLoads--;
            if ((((this.unfinishedLoads == 0)) && (!(this.parsing)))){
                this.finishLoad(this.manifest);
            };
        }
        private function onAdditionalLoadError(_arg1:Event):void{
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_ERROR));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {

    public class BestEffortFetchInfo {

        public static const DEFAULT_MAX_FORWARD_FETCHES:uint = 2;
        public static const DEFAULT_MAX_BACKWARD_FETCHES:uint = 2;

        public var maxForwardFetches:uint = 2;
        public var maxBackwardFetches:uint = 2;
        public var segmentDuration:uint = 0;
        public var fragmentDuration:uint = 0;

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses.builders {
    import org.osmf.elements.f4mClasses.*;

    public class BaseManifestBuilder {

        public function canParse(_arg1:String):Boolean{
            return (false);
        }
        public function build(_arg1:String):ManifestParser{
            return (null);
        }

    }
}//package org.osmf.elements.f4mClasses.builders 
﻿package org.osmf.elements.f4mClasses.builders {
    import org.osmf.elements.f4mClasses.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class ManifestBuilder extends BaseManifestBuilder {

        private static const MINIMUM_VERSION:Object = VersionUtils.parseVersionString("0.0");
        private static const MAXIMUM_VERSION:Object = VersionUtils.parseVersionString("1.9");

        override public function canParse(_arg1:String):Boolean{
            var _local2:Object = this.getVersion(_arg1);
            return ((((((((_local2.major >= MINIMUM_VERSION.major)) && ((_local2.major <= MAXIMUM_VERSION.major)))) && ((_local2.minor >= MINIMUM_VERSION.minor)))) && ((_local2.minor <= MAXIMUM_VERSION.minor))));
        }
        override public function build(_arg1:String):ManifestParser{
            var _local2:ManifestParser = this.createParser();
            return (_local2);
        }
        protected function getVersion(_arg1:String):Object{
            return (F4MUtils.getVersion(_arg1));
        }
        protected function createParser():ManifestParser{
            return (new ManifestParser());
        }

    }
}//package org.osmf.elements.f4mClasses.builders 
﻿package org.osmf.elements.f4mClasses.builders {
    import org.osmf.elements.f4mClasses.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class MultiLevelManifestBuilder extends BaseManifestBuilder {

        private static const MINIMUM_VERSION:Object = VersionUtils.parseVersionString("2.0");

        override public function canParse(_arg1:String):Boolean{
            var _local2:Object = this.getVersion(_arg1);
            return ((((_local2.major >= MINIMUM_VERSION.major)) && ((_local2.minor >= MINIMUM_VERSION.minor))));
        }
        override public function build(_arg1:String):ManifestParser{
            var _local2:ManifestParser = this.createParser();
            return (_local2);
        }
        protected function getVersion(_arg1:String):Object{
            return (F4MUtils.getVersion(_arg1));
        }
        protected function createParser():ManifestParser{
            return (new MultiLevelManifestParser());
        }

    }
}//package org.osmf.elements.f4mClasses.builders 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class MultiLevelManifestParser extends ManifestParser {

        private var parsing:Boolean = false;
        private var unfinishedLoads:Number = 0;
        private var manifest:Manifest;
        private var queue:Array;
        private var baseURLs:Dictionary;
        private var loadingInfo:Dictionary;
        private var externalMediaCount:Number = 0;

        override public function parse(_arg1:String, _arg2:String=null, _arg3:Manifest=null, _arg4:String=""):void{
            var _local8:XML;
            var _local9:String;
            var _local10:URLLoader;
            var _local11:Info;
            this.parsing = true;
            this.manifest = new Manifest();
            var _local5:XML = new XML(_arg1);
            var _local6:Namespace = _local5.namespace();
            this.queue = [];
            this.queue.push(_local5);
            if (!this.baseURLs){
                this.baseURLs = new Dictionary(true);
            };
            var _local7:String = _arg2;
            if (_local5._local6::baseURL.length() > 0){
                _local7 = _local5._local6::baseURL.text();
            };
            _local7 = URL.normalizePathForURL(_local7, false);
            this.baseURLs[_local5] = _local7;
            for each (_local8 in _local5._local6::media) {
                if (_local8.attribute("href").length() > 0){
                    this.unfinishedLoads++;
                    _local9 = _local8.@href;
                    if (!URL.isAbsoluteURL(_local9)){
                        _local9 = (URL.normalizeRootURL(_local7) + URL.normalizeRelativeURL(_local9));
                    };
                    _local10 = new URLLoader();
                    _local10.addEventListener(Event.COMPLETE, this.onLoadComplete);
                    _local10.addEventListener(IOErrorEvent.IO_ERROR, this.onLoadError);
                    _local10.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onLoadError);
                    if (!this.loadingInfo){
                        this.loadingInfo = new Dictionary(true);
                    };
                    _local11 = new Info();
                    _local11.baseURL = URL.normalizeRootURL(URL.getRootUrl(_local9));
                    if (_local8.attribute("bitrate").length() > 0){
                        _local11.attributes.bitrate = _local8.@bitrate;
                    };
                    if (_local8.attribute("width").length() > 0){
                        _local11.attributes.width = _local8.@width;
                    };
                    if (_local8.attribute("height").length() > 0){
                        _local11.attributes.height = _local8.@height;
                    };
                    if (_local8.attribute("type").length() > 0){
                        _local11.attributes.type = _local8.@type;
                    };
                    if (((_local8.hasOwnProperty("@alternate")) || ((_local8.attribute("alternate").length() > 0)))){
                        _local11.attributes.alternate = "true";
                    };
                    if (_local8.attribute("label").length() > 0){
                        _local11.attributes.label = _local8.@label;
                    };
                    if (_local8.attribute("lang").length() > 0){
                        _local11.attributes.lang = _local8.@lang;
                    };
                    this.loadingInfo[_local10] = _local11;
                    _local10.load(new URLRequest(HTTPStreamingUtils.normalizeURL(_local9)));
                };
            };
            this.parsing = false;
            if (this.unfinishedLoads == 0){
                this.processQueue();
            };
        }
        override protected function finishLoad(_arg1:Manifest):void{
            if (!this.processQueue()){
                _arg1.baseURL = null;
                super.finishLoad(_arg1);
            };
        }
        override protected function buildMediaParser():BaseParser{
            return (new ExternalMediaParser());
        }
        private function processQueue():Boolean{
            var _local1:XML;
            var _local2:String;
            var _local3:String;
            if (this.parsing){
                return (true);
            };
            if (this.queue.length > 0){
                _local1 = (this.queue.pop() as XML);
                _local2 = this.baseURLs[_local1];
                this.externalMediaCount = (this.externalMediaCount + 1);
                _local3 = (("external" + this.externalMediaCount) + "_");
                super.parse(_local1.toXMLString(), _local2, this.manifest, _local3);
                return (true);
            };
            return (false);
        }
        private function onLoadComplete(_arg1:Event):void{
            var _local6:XML;
            var _local7:XMLList;
            var _local8:String;
            var _local9:int;
            var _local2:URLLoader = (_arg1.target as URLLoader);
            _local2.removeEventListener(Event.COMPLETE, this.onLoadComplete);
            _local2.removeEventListener(IOErrorEvent.IO_ERROR, this.onLoadError);
            _local2.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onLoadError);
            var _local3:XML = XML(URLLoader(_arg1.target).data);
            var _local4:Namespace = _local3.namespace();
            var _local5:Info = this.loadingInfo[_local2];
            delete this.loadingInfo[_local2];
            for each (_local6 in _local3._local4::media) {
                _local7 = describeType(_local5.attributes)..variable;
                while (_local9 < _local7.length()) {
                    _local8 = _local7[_local9].@name;
                    if (((!((_local5.attributes[_local8] == null))) && ((_local5.attributes[_local8].length > 0)))){
                        _local6.@[_local8] = _local5.attributes[_local8];
                    } else {
                        delete _local6.@[_local8];
                    };
                    _local9++;
                };
            };
            if (!this.baseURLs){
                this.baseURLs = new Dictionary(true);
            };
            this.baseURLs[_local3] = URL.normalizeRootURL(_local5.baseURL);
            this.queue.push(_local3);
            this.unfinishedLoads--;
            if (this.unfinishedLoads == 0){
                this.processQueue();
            };
        }
        private function onLoadError(_arg1:Event):void{
            this.unfinishedLoads--;
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_ERROR));
        }

    }
}//package org.osmf.elements.f4mClasses 

class Info {

    public var baseURL:String;
    public var attributes:Attributes;

    public function Info(){
        this.attributes = new Attributes();
    }
}
class Attributes {

    public var bitrate:String;
    public var width:String;
    public var height:String;
    public var type:String;
    public var alternate:String;
    public var label:String;
    public var lang:String;

    public function Attributes(){
    }
}
﻿package org.osmf.elements.f4mClasses {
    import flash.events.*;

    public class BaseParser extends EventDispatcher {

        public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.elements.f4mClasses.*;
    import flash.utils.*;

    class Media {

        public var url:String;
        public var bitrate:Number;
        public var type:String;
        public var label:String;
        public var language:String;
        public var alternate:Boolean;
        public var drmAdditionalHeader:DRMAdditionalHeader;
        public var bootstrapInfo:BootstrapInfo;
        public var metadata:Object;
        public var xmp:ByteArray;
        public var moov:ByteArray;
        public var width:Number;
        public var height:Number;
        public var multicastGroupspec:String;
        public var multicastStreamName:String;

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.utils.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class BootstrapInfoParser extends BaseParser {

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local7:String;
            var _local8:Base64Decoder;
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            var _local5:BootstrapInfo = new BootstrapInfo();
            var _local6:String;
            if (_local4.attribute("profile").length() > 0){
                _local5.profile = _local4.@profile;
            } else {
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_PROFILE_MISSING)));
            };
            if (_local4.attribute("id").length() > 0){
                _local5.id = (_arg3 + _local4.@id);
            } else {
                _local5.id = (_arg3 + F4MUtils.GLOBAL_ELEMENT_ID);
            };
            if (_local4.attribute("url").length() > 0){
                _local6 = _local4.@url;
                if (!URL.isAbsoluteURL(_local6)){
                    _local6 = (URL.normalizeRootURL(_arg2) + URL.normalizeRelativeURL(_local6));
                };
                _local5.url = _local6;
            } else {
                _local7 = _local4.text();
                _local8 = new Base64Decoder();
                _local8.decode(_local7);
                _local5.data = _local8.drain();
            };
            this.finishLoad(_local5);
        }
        protected function finishLoad(_arg1:BootstrapInfo):void{
            if (!_arg1){
                return;
            };
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import flash.utils.*;

    public class DRMAdditionalHeader {

        public var data:ByteArray;
        public var url:String;
        public var id:String;

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses {
    import org.osmf.events.*;
    import org.osmf.net.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import org.osmf.elements.f4mClasses.utils.*;

    public class MediaParser extends BaseParser {

        override public function parse(_arg1:String, _arg2:String=null, _arg3:String=""):void{
            var _local7:Base64Decoder;
            var _local8:String;
            var _local9:ByteArray;
            var _local10:String;
            var _local11:Object;
            var _local4:XML = new XML(_arg1);
            if (!_local4){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_VALUE_MISSING)));
            };
            var _local5:Media = new Media();
            var _local6:Namespace = _local4.namespace();
            if (_local4.attribute("url").length() > 0){
                _local8 = _local4.@url;
                if (!URL.isAbsoluteURL(_local8)){
                    _local8 = (URL.normalizeRootURL(_arg2) + URL.normalizeRelativeURL(_local8));
                };
                _local5.url = _local8;
            } else {
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.F4M_PARSE_MEDIA_URL_MISSING)));
            };
            if (_local4.attribute("bitrate").length() > 0){
                _local5.bitrate = _local4.@bitrate;
            };
            if (_local4.attribute("drmAdditionalHeaderId").length() > 0){
                _local5.drmAdditionalHeader = new DRMAdditionalHeader();
                _local5.drmAdditionalHeader.id = (_arg3 + _local4.@drmAdditionalHeaderId);
            } else {
                _local5.drmAdditionalHeader = new DRMAdditionalHeader();
                _local5.drmAdditionalHeader.id = (_arg3 + F4MUtils.GLOBAL_ELEMENT_ID);
            };
            if (_local4.attribute("bootstrapInfoId").length() > 0){
                _local5.bootstrapInfo = new BootstrapInfo();
                _local5.bootstrapInfo.id = (_arg3 + _local4.@bootstrapInfoId);
            } else {
                _local5.bootstrapInfo = new BootstrapInfo();
                _local5.bootstrapInfo.id = (_arg3 + F4MUtils.GLOBAL_ELEMENT_ID);
            };
            if (_local4.attribute("height").length() > 0){
                _local5.height = _local4.@height;
            };
            if (_local4.attribute("width").length() > 0){
                _local5.width = _local4.@width;
            };
            if (_local4.attribute("groupspec").length() > 0){
                _local5.multicastGroupspec = _local4.@groupspec;
            };
            if (_local4.attribute("multicastStreamName").length() > 0){
                _local5.multicastStreamName = _local4.@multicastStreamName;
            };
            if (_local4.attribute("label").length() > 0){
                _local5.label = _local4.@label;
            };
            if (_local4.attribute("type").length() > 0){
                _local5.type = _local4.@type;
            } else {
                _local5.type = StreamingItemType.VIDEO;
            };
            if (_local4.attribute("lang").length() > 0){
                _local5.language = _local4.@lang;
            };
            if (((_local4.hasOwnProperty("@alternate")) || ((_local4.attribute("alternate").length() > 0)))){
                _local5.alternate = true;
            };
            if (_local4._local6::moov.length() > 0){
                _local7 = new Base64Decoder();
                _local7.decode(_local4._local6::moov.text());
                _local5.moov = _local7.drain();
            };
            if (_local4._local6::metadata.length() > 0){
                _local7 = new Base64Decoder();
                _local7.decode(_local4._local6::metadata.text());
                _local9 = _local7.drain();
                _local9.position = 0;
                _local9.objectEncoding = 0;
                try {
                    _local10 = (_local9.readObject() as String);
                    _local11 = _local9.readObject();
                    _local5.metadata = _local11;
                    if (((((isNaN(_local5.width)) || ((_local5.width == 0)))) && (_local5.metadata.hasOwnProperty("width")))){
                        _local5.width = _local5.metadata["width"];
                    };
                    if (((((isNaN(_local5.height)) || ((_local5.height == 0)))) && (_local5.metadata.hasOwnProperty("height")))){
                        _local5.height = _local5.metadata["height"];
                    };
                } catch(e:Error) {
                };
            };
            if (_local4._local6::xmpMetadata.length() > 0){
                _local7 = new Base64Decoder();
                _local7.decode(_local4._local6::xmpMetadata.text());
                _local5.xmp = _local7.drain();
            };
            this.validateMedia(_local5);
            this.finishLoad(_local5);
        }
        protected function validateMedia(_arg1:Media):void{
            if (((((_arg1) && (((((!((_arg1.multicastGroupspec == null))) && ((_arg1.multicastGroupspec.length > 0)))) && ((((_arg1.multicastStreamName == null)) || ((_arg1.multicastStreamName.length <= 0)))))))) || (((((!((_arg1.multicastStreamName == null))) && ((_arg1.multicastStreamName.length > 0)))) && ((((_arg1.multicastGroupspec == null)) || ((_arg1.multicastGroupspec.length <= 0)))))))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.MULTICAST_PARAMETER_INVALID)));
            };
        }
        protected function finishLoad(_arg1:Media):void{
            if (!_arg1){
                return;
            };
            dispatchEvent(new ParseEvent(ParseEvent.PARSE_COMPLETE, false, false, _arg1));
        }

    }
}//package org.osmf.elements.f4mClasses 
﻿package org.osmf.elements.f4mClasses.utils {
    import org.osmf.media.pluginClasses.*;

    public class F4MUtils {

        public static const GLOBAL_ELEMENT_ID:String = "global";

        public static function getVersion(_arg1:String):Object{
            var _local4:String;
            var _local2:XML = new XML(_arg1);
            var _local3:String = _local2.namespace().toString();
            var _local5:int = _local3.lastIndexOf("/");
            if (_local5 != -1){
                _local4 = _local3.substr((_local5 + 1));
            } else {
                _local4 = _local3;
            };
            return (VersionUtils.parseVersionString(_local4));
        }

    }
}//package org.osmf.elements.f4mClasses.utils 
﻿package org.osmf.elements {
    import org.osmf.media.*;

    public class F4MElement extends LoadFromDocumentElement {

        public function F4MElement(_arg1:MediaResourceBase=null, _arg2:F4MLoader=null){
            if (_arg2 == null){
                _arg2 = new F4MLoader();
            };
            super(_arg1, _arg2);
        }
    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import flash.net.*;
    import flash.media.*;
    import flash.utils.*;
    import org.osmf.media.videoClasses.*;
    import flash.system.*;
    import org.osmf.utils.*;
    import org.osmf.net.drm.*;

    public class LightweightVideoElement extends LoadableElementBase {

        private static const DRM_STATUS_CODE:String = "DRM.encryptedFLV";
        private static const DRM_NEEDS_AUTHENTICATION:int = 3330;

        private var displayObjectTrait:DisplayObjectTrait;
        private var defaultTimeTrait:ModifiableTimeTrait;
        private var stream:NetStream;
        private var embeddedCuePoints:TimelineMetadata;
        private var _smoothing:Boolean;
        private var _deblocking:int;
        private var videoSurface:VideoSurface;
        private var drmTrait:NetStreamDRMTrait;

        public function LightweightVideoElement(_arg1:MediaResourceBase=null, _arg2:NetLoader=null){
            if (_arg2 == null){
                _arg2 = new NetLoader();
            };
            super(_arg1, _arg2);
            if (!(((_arg1 == null)) || ((_arg1 is URLResource)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
        }
        public function get client():NetClient{
            return (((this.stream)!=null) ? (this.stream.client as NetClient) : null);
        }
        public function get defaultDuration():Number{
            return (((this.defaultTimeTrait) ? this.defaultTimeTrait.duration : NaN));
        }
        public function set defaultDuration(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                if (this.defaultTimeTrait != null){
                    removeTraitResolver(MediaTraitType.TIME);
                    this.defaultTimeTrait = null;
                };
            } else {
                if (this.defaultTimeTrait == null){
                    this.defaultTimeTrait = new ModifiableTimeTrait();
                    addTraitResolver(MediaTraitType.TIME, new DefaultTraitResolver(MediaTraitType.TIME, this.defaultTimeTrait));
                };
                this.defaultTimeTrait.duration = _arg1;
            };
        }
        public function get smoothing():Boolean{
            return (this._smoothing);
        }
        public function set smoothing(_arg1:Boolean):void{
            this._smoothing = _arg1;
            if (this.videoSurface != null){
                this.videoSurface.smoothing = _arg1;
            };
        }
        public function get deblocking():int{
            return (this._deblocking);
        }
        public function set deblocking(_arg1:int):void{
            this._deblocking = _arg1;
            if (this.videoSurface != null){
                this.videoSurface.deblocking = _arg1;
            };
        }
        public function get currentFPS():Number{
            return (((this.stream)!=null) ? this.stream.currentFPS : 0);
        }
        override protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return (new NetStreamLoadTrait(_arg2, _arg1));
        }
        protected function createVideo():Video{
            return (new Video());
        }
        override protected function processReadyState():void{
            var _local2:ByteArray;
            var _local1:NetStreamLoadTrait = (getTrait(MediaTraitType.LOAD) as NetStreamLoadTrait);
            this.stream = _local1.netStream;
            this.videoSurface = new VideoSurface(((OSMFSettings.enableStageVideo) && (OSMFSettings.supportsStageVideo)), this.createVideo);
            this.videoSurface.smoothing = this._smoothing;
            this.videoSurface.deblocking = this._deblocking;
            this.videoSurface.width = (this.videoSurface.height = 0);
            this.videoSurface.attachNetStream(this.stream);
            NetClient(this.stream.client).addHandler(NetStreamCodes.ON_META_DATA, this.onMetaData);
            NetClient(this.stream.client).addHandler(NetStreamCodes.ON_CUE_POINT, this.onCuePoint);
            this.stream.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
            _local1.connection.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent, false, 0, true);
            this.stream.addEventListener(DRMErrorEvent.DRM_ERROR, this.onDRMErrorEvent);
            _local2 = this.getDRMContentData(resource);
            if (((!((_local2 == null))) && ((_local2.bytesAvailable > 0)))){
                this.setupDRMTrait(_local2);
            } else {
                this.stream.addEventListener(StatusEvent.STATUS, this.onStatus);
                this.stream.addEventListener(DRMStatusEvent.DRM_STATUS, this.onDRMStatus);
            };
            this.finishLoad();
        }
        private function finishLoad():void{
            var timeTrait:* = null;
            var seekTrait:* = null;
            var reconnectStreams:* = false;
            var onDurationChange:* = null;
            var dsTrait:* = null;
            var aaTrait:* = null;
            var loadTrait:* = (getTrait(MediaTraitType.LOAD) as NetStreamLoadTrait);
            var dvrTrait:* = (loadTrait.getTrait(MediaTraitType.DVR) as DVRTrait);
            if (dvrTrait != null){
                addTrait(MediaTraitType.DVR, dvrTrait);
            };
            var audioTrait:* = (loadTrait.getTrait(MediaTraitType.AUDIO) as AudioTrait);
            if (audioTrait == null){
                audioTrait = new NetStreamAudioTrait(this.stream);
            };
            addTrait(MediaTraitType.AUDIO, audioTrait);
            var bufferTrait:* = (loadTrait.getTrait(MediaTraitType.BUFFER) as BufferTrait);
            if (bufferTrait == null){
                bufferTrait = new NetStreamBufferTrait(this.stream, this.videoSurface);
            };
            addTrait(MediaTraitType.BUFFER, bufferTrait);
            timeTrait = (loadTrait.getTrait(MediaTraitType.TIME) as TimeTrait);
            if (timeTrait == null){
                timeTrait = new NetStreamTimeTrait(this.stream, loadTrait.resource, this.defaultDuration);
            };
            addTrait(MediaTraitType.TIME, timeTrait);
            var displayObjectTrait:* = (loadTrait.getTrait(MediaTraitType.DISPLAY_OBJECT) as DisplayObjectTrait);
            if (displayObjectTrait == null){
                displayObjectTrait = new NetStreamDisplayObjectTrait(this.stream, this.videoSurface, NaN, NaN);
            };
            addTrait(MediaTraitType.DISPLAY_OBJECT, displayObjectTrait);
            var playTrait:* = (loadTrait.getTrait(MediaTraitType.PLAY) as PlayTrait);
            if (playTrait == null){
                reconnectStreams = false;
                reconnectStreams = (loader as NetLoader).reconnectStreams;
                playTrait = new NetStreamPlayTrait(this.stream, resource, reconnectStreams, loadTrait.connection);
            };
            addTrait(MediaTraitType.PLAY, playTrait);
            seekTrait = (loadTrait.getTrait(MediaTraitType.SEEK) as SeekTrait);
            if ((((seekTrait == null)) && (!((NetStreamUtils.getStreamType(resource) == StreamType.LIVE))))){
                seekTrait = new NetStreamSeekTrait(timeTrait, loadTrait, this.stream, this.videoSurface);
            };
            if (seekTrait != null){
                if (((isNaN(timeTrait.duration)) || ((timeTrait.duration == 0)))){
                    onDurationChange = function (_arg1:TimeEvent):void{
                        timeTrait.removeEventListener(TimeEvent.DURATION_CHANGE, onDurationChange);
                        addTrait(MediaTraitType.SEEK, seekTrait);
                    };
                    timeTrait.addEventListener(TimeEvent.DURATION_CHANGE, onDurationChange);
                } else {
                    addTrait(MediaTraitType.SEEK, seekTrait);
                };
            };
            var dsResource:* = (resource as DynamicStreamingResource);
            if (((!((dsResource == null))) && (!((loadTrait.switchManager == null))))){
                dsTrait = (loadTrait.getTrait(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait);
                if (dsTrait == null){
                    dsTrait = new NetStreamDynamicStreamTrait(this.stream, loadTrait.switchManager, dsResource);
                };
                addTrait(MediaTraitType.DYNAMIC_STREAM, dsTrait);
            };
            var sResource:* = (resource as StreamingURLResource);
            if (((((!((sResource == null))) && (!((sResource.alternativeAudioStreamItems == null))))) && ((sResource.alternativeAudioStreamItems.length > 0)))){
                aaTrait = (loadTrait.getTrait(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait);
                if (aaTrait == null){
                    aaTrait = new NetStreamAlternativeAudioTrait(this.stream, sResource);
                };
                addTrait(MediaTraitType.ALTERNATIVE_AUDIO, aaTrait);
            };
        }
        override protected function processUnloadingState():void{
            if (this.stream != null){
                this.stream.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
                if (this.stream.client != null){
                    NetClient(this.stream.client).removeHandler(NetStreamCodes.ON_META_DATA, this.onMetaData);
                };
            };
            var _local1:NetStreamLoadTrait = (getTrait(MediaTraitType.LOAD) as NetStreamLoadTrait);
            if (((!((_local1 == null))) && (!((_local1.connection == null))))){
                _local1.connection.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
            };
            removeTrait(MediaTraitType.AUDIO);
            removeTrait(MediaTraitType.BUFFER);
            removeTrait(MediaTraitType.PLAY);
            removeTrait(MediaTraitType.TIME);
            removeTrait(MediaTraitType.DISPLAY_OBJECT);
            removeTrait(MediaTraitType.SEEK);
            removeTrait(MediaTraitType.DYNAMIC_STREAM);
            removeTrait(MediaTraitType.ALTERNATIVE_AUDIO);
            removeTrait(MediaTraitType.DVR);
            if (this.stream != null){
                this.stream.removeEventListener(DRMErrorEvent.DRM_ERROR, this.onDRMErrorEvent);
                this.stream.removeEventListener(DRMStatusEvent.DRM_STATUS, this.onDRMStatus);
                this.stream.removeEventListener(StatusEvent.STATUS, this.onStatus);
            };
            if (this.drmTrait != null){
                this.drmTrait.removeEventListener(DRMEvent.DRM_STATE_CHANGE, this.reloadAfterAuth);
                removeTrait(MediaTraitType.DRM);
                this.drmTrait = null;
            };
            if (this.videoSurface != null){
                this.videoSurface.attachNetStream(null);
            };
            this.videoSurface = null;
            this.stream = null;
            this.displayObjectTrait = null;
        }
        private function onMetaData(_arg1:Object):void{
            var _local3:TimelineMetadata;
            var _local4:int;
            var _local5:CuePoint;
            var _local2:Array = _arg1.cuePoints;
            if (((!((_local2 == null))) && ((_local2.length > 0)))){
                _local3 = (getMetadata(CuePoint.DYNAMIC_CUEPOINTS_NAMESPACE) as TimelineMetadata);
                if (_local3 == null){
                    _local3 = new TimelineMetadata(this);
                    addMetadata(CuePoint.DYNAMIC_CUEPOINTS_NAMESPACE, _local3);
                };
                _local4 = 0;
                while (_local4 < _local2.length) {
                    _local5 = new CuePoint(_local2[_local4].type, _local2[_local4].time, _local2[_local4].name, _local2[_local4].parameters);
                    try {
                        _local3.addMarker(_local5);
                    } catch(error:ArgumentError) {
                    };
                    _local4++;
                };
            };
        }
        private function onCuePoint(_arg1:Object):void{
            if (this.embeddedCuePoints == null){
                this.embeddedCuePoints = new TimelineMetadata(this);
                addMetadata(CuePoint.EMBEDDED_CUEPOINTS_NAMESPACE, this.embeddedCuePoints);
            };
            var _local2:CuePoint = new CuePoint(_arg1.type, _arg1.time, _arg1.name, _arg1.parameters);
            try {
                this.embeddedCuePoints.addMarker(_local2);
            } catch(error:ArgumentError) {
            };
        }
        private function onUpdateComplete(_arg1:Event):void{
            (getTrait(MediaTraitType.LOAD) as LoadTrait).unload();
            (getTrait(MediaTraitType.LOAD) as LoadTrait).load();
        }
        private function onNetStatusEvent(_arg1:NetStatusEvent):void{
            var _local2:MediaError;
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                case NetStreamCodes.NETSTREAM_FAILED:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_PLAY_FAILED, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STREAMNOTFOUND:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_STREAM_NOT_FOUND, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_FILESTRUCTUREINVALID:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_FILE_STRUCTURE_INVALID, _arg1.info.description);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_NOSUPPORTEDTRACKFOUND:
                    _local2 = new MediaError(MediaErrorCodes.NETSTREAM_NO_SUPPORTED_TRACK_FOUND, _arg1.info.description);
                    break;
                case NetConnectionCodes.CONNECT_IDLE_TIME_OUT:
                    _local2 = new MediaError(MediaErrorCodes.NETCONNECTION_TIMEOUT, _arg1.info.description);
                    break;
            };
            if (_arg1.info.code == NetStreamCodes.NETSTREAM_DRM_UPDATE){
                this.update(SystemUpdaterType.DRM);
            };
            if (_local2 != null){
                dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, _local2));
            };
        }
        private function getDRMContentData(_arg1:MediaResourceBase):ByteArray{
            var _local3:Metadata;
            var _local4:String;
            var _local5:DynamicStreamingResource;
            var _local6:ByteArray;
            var _local7:Vector.<String>;
            var _local8:int;
            var _local9:String;
            var _local2:StreamingURLResource = (_arg1 as StreamingURLResource);
            if (_local2 != null){
                if (_local2.drmContentData != null){
                    return (_local2.drmContentData);
                };
                _local3 = (_arg1.getMetadataValue(MetadataNamespaces.DRM_METADATA) as Metadata);
                if (((!((_local3 == null))) && ((_local3.keys.length > 0)))){
                    _local4 = null;
                    _local5 = (_arg1 as DynamicStreamingResource);
                    if (((((!((_local5 == null))) && ((_local5.initialIndex > -1)))) && ((_local5.initialIndex < _local5.streamItems.length)))){
                        _local4 = _local5.streamItems[_local5.initialIndex].streamName;
                    };
                    _local6 = null;
                    if (_local4 != null){
                        _local6 = (_local3.getValue(_local4) as ByteArray);
                    };
                    if (_local6 == null){
                        _local7 = _local3.keys;
                        _local8 = 0;
                        do  {
                            _local9 = _local7[_local8];
                            if (_local9.indexOf(MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY) != 0){
                                _local6 = _local3.getValue(_local9);
                            };
                            _local8++;
                        } while ((((_local6 == null)) && ((_local8 < _local7.length))));
                    };
                    return (_local6);
                };
            };
            return (null);
        }
        private function onStatus(_arg1:StatusEvent):void{
            if ((((_arg1.code == DRM_STATUS_CODE)) && ((getTrait(MediaTraitType.DRM) == null)))){
                this.createDRMTrait();
            };
        }
        private function onDRMStatus(_arg1:DRMStatusEvent):void{
            this.drmTrait.inlineOnVoucher(_arg1);
        }
        private function reloadAfterAuth(_arg1:DRMEvent):void{
            var _local2:NetStreamLoadTrait;
            if (this.drmTrait.drmState == DRMState.AUTHENTICATION_COMPLETE){
                _local2 = (getTrait(MediaTraitType.LOAD) as NetStreamLoadTrait);
                if (_local2.loadState == LoadState.READY){
                    _local2.unload();
                };
                _local2.load();
            };
        }
        private function createDRMTrait():void{
            this.drmTrait = new NetStreamDRMTrait();
            addTrait(MediaTraitType.DRM, this.drmTrait);
        }
        private function setupDRMTrait(_arg1:ByteArray):void{
            this.createDRMTrait();
            this.drmTrait.drmMetadata = _arg1;
        }
        private function onDRMErrorEvent(_arg1:DRMErrorEvent):void{
            if (_arg1.errorID == DRM_NEEDS_AUTHENTICATION){
                this.drmTrait.addEventListener(DRMEvent.DRM_STATE_CHANGE, this.reloadAfterAuth);
                this.drmTrait.drmMetadata = _arg1.contentData;
            } else {
                if (_arg1.drmUpdateNeeded){
                    this.update(SystemUpdaterType.DRM);
                } else {
                    if (_arg1.systemUpdateNeeded){
                        this.update(SystemUpdaterType.SYSTEM);
                    } else {
                        this.drmTrait.inlineDRMFailed(new MediaError(_arg1.errorID));
                    };
                };
            };
        }
        private function update(_arg1:String):void{
            if (this.drmTrait == null){
                this.createDRMTrait();
            };
            var _local2:SystemUpdater = this.drmTrait.update(_arg1);
            _local2.addEventListener(Event.COMPLETE, this.onUpdateComplete);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import org.osmf.elements.loaderClasses.*;

    public class SWFElement extends LoadableElementBase {

        public function SWFElement(_arg1:URLResource=null, _arg2:SWFLoader=null){
            if (_arg2 == null){
                _arg2 = new SWFLoader();
            };
            super(_arg1, _arg2);
        }
        override protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return (new LoaderLoadTrait(_arg2, _arg1));
        }
        override protected function processReadyState():void{
            var _local1:LoaderLoadTrait = (getTrait(MediaTraitType.LOAD) as LoaderLoadTrait);
            addTrait(MediaTraitType.DISPLAY_OBJECT, LoaderUtils.createDisplayObjectTrait(_local1.loader, this));
        }
        override protected function processUnloadingState():void{
            removeTrait(MediaTraitType.DISPLAY_OBJECT);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.elements.f4mClasses.*;
    import org.osmf.elements.f4mClasses.builders.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import org.osmf.elements.proxyClasses.*;

    public class ManifestLoaderBase extends LoaderBase {

        protected var factory:MediaFactory;
        protected var builders:Vector.<BaseManifestBuilder>;
        protected var loadTrait:LoadTrait;
        protected var parserTimer:Timer;
        protected var parser:ManifestParser;

        protected function onParserTimerComplete(_arg1:TimerEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer = null;
            };
            updateLoadTrait(this.loadTrait, LoadState.LOAD_ERROR);
            this.loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR))));
        }
        protected function onParserLoadComplete(_arg1:ParseEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer.stop();
                this.parserTimer = null;
            };
            this.parser.removeEventListener(ParseEvent.PARSE_COMPLETE, this.onParserLoadComplete);
            this.parser.removeEventListener(ParseEvent.PARSE_ERROR, this.onParserLoadError);
            var _local2:Manifest = (_arg1.data as Manifest);
            this.finishManifestLoad(_local2);
        }
        protected function onParserLoadError(_arg1:ParseEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer.stop();
                this.parserTimer = null;
            };
            this.parser.removeEventListener(ParseEvent.PARSE_COMPLETE, this.onParserLoadComplete);
            this.parser.removeEventListener(ParseEvent.PARSE_ERROR, this.onParserLoadError);
            updateLoadTrait(this.loadTrait, LoadState.LOAD_ERROR);
            this.loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR))));
        }
        protected function finishManifestLoad(_arg1:Manifest):void{
            var netResource:* = null;
            var loadedElem:* = null;
            var manifest:* = _arg1;
            try {
                netResource = this.parser.createResource(manifest, this.loadTrait.resource);
                loadedElem = this.factory.createMediaElement(netResource);
                if (((loadedElem.hasOwnProperty("defaultDuration")) && (!(isNaN(manifest.duration))))){
                    loadedElem["defaultDuration"] = manifest.duration;
                };
                LoadFromDocumentLoadTrait(this.loadTrait).mediaElement = loadedElem;
                updateLoadTrait(this.loadTrait, LoadState.READY);
            } catch(error:Error) {
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, error.message)));
            };
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.UNINITIALIZED);
        }
        protected function getBuilders():Vector.<BaseManifestBuilder>{
            var _local1:Vector.<BaseManifestBuilder> = new Vector.<BaseManifestBuilder>();
            _local1.push(new MultiLevelManifestBuilder());
            _local1.push(new ManifestBuilder());
            return (_local1);
        }
        protected function getParser(_arg1:String):ManifestParser{
            var _local2:ManifestParser;
            var _local3:BaseManifestBuilder;
            for each (_local3 in this.builders) {
                if (_local3.canParse(_arg1)){
                    _local2 = (_local3.build(_arg1) as ManifestParser);
                    break;
                };
            };
            return (_local2);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class XMLLoader extends ManifestLoaderBase {

        public function XMLLoader(_arg1:MediaFactory=null){
            if (_arg1 == null){
                _arg1 = new DefaultMediaFactory();
            };
            this.factory = _arg1;
            this.builders = getBuilders();
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            if ((_arg1 is StreamingXMLResource)){
                return (true);
            };
            return (false);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            var manifest:* = null;
            var resourceData:* = null;
            var loadTrait:* = _arg1;
            this.loadTrait = loadTrait;
            updateLoadTrait(loadTrait, LoadState.LOADING);
            try {
                resourceData = (loadTrait.resource as StreamingXMLResource).manifest;
                parser = getParser(resourceData);
                parser.addEventListener(ParseEvent.PARSE_COMPLETE, onParserLoadComplete);
                parser.addEventListener(ParseEvent.PARSE_ERROR, onParserLoadError);
                parserTimer = new Timer(OSMFSettings.f4mParseTimeout, 1);
                parserTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onParserTimerComplete);
                parserTimer.start();
                parser.parse(resourceData, URL.normalizePathForURL(StreamingXMLResource(loadTrait.resource).url, true));
            } catch(parseError:Error) {
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(parseError.errorID, parseError.message)));
            };
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import flash.media.*;

    public class SoundAdapter extends EventDispatcher {

        public static const DOWNLOAD_COMPLETE:String = "downloadComplete";

        private var owner:MediaElement;
        private var _soundTransform:SoundTransform;
        private var sound:Sound;
        private var playing:Boolean = false;
        private var channel:SoundChannel;
        private var lastStartTime:Number = 0;

        public function SoundAdapter(_arg1:MediaElement, _arg2:Sound){
            this.owner = _arg1;
            this.sound = _arg2;
            this._soundTransform = new SoundTransform();
            _arg2.addEventListener(Event.COMPLETE, this.onDownloadComplete, false, 0, true);
            _arg2.addEventListener(ProgressEvent.PROGRESS, this.onProgress, false, 0, true);
            _arg2.addEventListener(IOErrorEvent.IO_ERROR, this.onIOError, false, 0, true);
        }
        public function get currentTime():Number{
            return (((this.channel)!=null) ? (this.channel.position / 1000) : (this.lastStartTime / 1000));
        }
        public function get estimatedDuration():Number{
            return ((this.sound.length / ((1000 * this.sound.bytesLoaded) / this.sound.bytesTotal)));
        }
        public function get soundTransform():SoundTransform{
            return (this._soundTransform);
        }
        public function set soundTransform(_arg1:SoundTransform):void{
            this._soundTransform = _arg1;
            if (this.channel != null){
                this.channel.soundTransform = _arg1;
            };
        }
        public function play(_arg1:Number=-1):Boolean{
            var time:int = _arg1;
            var success:* = false;
            if (this.channel == null){
                try {
                    this.channel = this.sound.play(((time)!=-1) ? time : this.lastStartTime);
                } catch(error:ArgumentError) {
                    channel = null;
                };
                if (this.channel != null){
                    this.playing = true;
                    this.channel.soundTransform = this._soundTransform;
                    this.channel.addEventListener(Event.SOUND_COMPLETE, this.onSoundComplete);
                    success = true;
                } else {
                    this.owner.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.SOUND_PLAY_FAILED)));
                };
            };
            return (success);
        }
        public function pause():void{
            if (this.channel != null){
                this.lastStartTime = this.channel.position;
                this.clearChannel();
                this.playing = false;
            };
        }
        public function stop():void{
            if (this.channel != null){
                this.lastStartTime = 0;
                this.clearChannel();
                this.playing = false;
            };
        }
        public function seek(_arg1:Number):void{
            var _local2:Boolean = this.playing;
            if (this.channel != null){
                this.clearChannel();
            };
            this.play((_arg1 * 1000));
            if (_local2 == false){
                this.pause();
            };
        }
        private function clearChannel():void{
            if (this.channel != null){
                this.channel.removeEventListener(Event.SOUND_COMPLETE, this.onSoundComplete);
                this.channel.stop();
                this.channel = null;
            };
        }
        private function onSoundComplete(_arg1:Event):void{
            this.lastStartTime = this.channel.position;
            this.clearChannel();
            this.playing = false;
            dispatchEvent(new Event(Event.COMPLETE));
        }
        private function onDownloadComplete(_arg1:Event):void{
            dispatchEvent(new Event(DOWNLOAD_COMPLETE));
        }
        private function onProgress(_arg1:ProgressEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function onIOError(_arg1:IOErrorEvent):void{
            this.owner.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.IO_ERROR)));
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.traits.*;

    public class AudioSeekTrait extends SeekTrait {

        private var soundAdapter:SoundAdapter;

        public function AudioSeekTrait(_arg1:TimeTrait, _arg2:SoundAdapter){
            super(_arg1);
            this.soundAdapter = _arg2;
        }
        override protected function seekingChangeStart(_arg1:Boolean, _arg2:Number):void{
            if (_arg1){
                this.soundAdapter.seek(_arg2);
            };
        }
        override protected function seekingChangeEnd(_arg1:Number):void{
            super.seekingChangeEnd(_arg1);
            if (seeking == true){
                setSeeking(false, _arg1);
            };
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.media.*;

    public class SoundLoadTrait extends LoadTrait {

        private var lastBytesTotal:Number;
        private var _sound:Sound;

        public function SoundLoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            super(_arg1, _arg2);
        }
        public function get sound():Sound{
            return (this._sound);
        }
        public function set sound(_arg1:Sound):void{
            this._sound = _arg1;
        }
        override protected function loadStateChangeStart(_arg1:String):void{
            if (_arg1 == LoadState.READY){
                if (this._sound != null){
                    this._sound.addEventListener(Event.OPEN, this.bytesTotalCheckingHandler, false, 0, true);
                    this._sound.addEventListener(ProgressEvent.PROGRESS, this.bytesTotalCheckingHandler, false, 0, true);
                };
            } else {
                if (_arg1 == LoadState.UNINITIALIZED){
                    this._sound = null;
                };
            };
        }
        override public function get bytesLoaded():Number{
            return (((this._sound) ? this._sound.bytesLoaded : NaN));
        }
        override public function get bytesTotal():Number{
            return (((this._sound) ? this._sound.bytesTotal : NaN));
        }
        private function bytesTotalCheckingHandler(_arg1:Event):void{
            var _local2:LoadEvent;
            if (this.lastBytesTotal != this._sound.bytesTotal){
                _local2 = new LoadEvent(LoadEvent.BYTES_TOTAL_CHANGE, false, false, null, this._sound.bytesTotal);
                this.lastBytesTotal = this._sound.bytesTotal;
                dispatchEvent(_local2);
            };
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.traits.*;
    import flash.events.*;

    public class AudioTimeTrait extends TimeTrait {

        private var soundAdapter:SoundAdapter;

        public function AudioTimeTrait(_arg1:SoundAdapter){
            this.soundAdapter = _arg1;
            _arg1.addEventListener(ProgressEvent.PROGRESS, this.onDownloadProgress, false, 0, true);
            _arg1.addEventListener(SoundAdapter.DOWNLOAD_COMPLETE, this.onDownloadComplete, false, 0, true);
            _arg1.addEventListener(Event.COMPLETE, this.onPlaybackComplete, false, 0, true);
        }
        override public function get currentTime():Number{
            return (this.soundAdapter.currentTime);
        }
        private function onDownloadProgress(_arg1:Event):void{
            if (((!(isNaN(this.soundAdapter.estimatedDuration))) && ((this.soundAdapter.estimatedDuration > 0)))){
                this.soundAdapter.removeEventListener(ProgressEvent.PROGRESS, this.onDownloadProgress);
                setDuration(this.soundAdapter.estimatedDuration);
            };
        }
        private function onDownloadComplete(_arg1:Event):void{
            setDuration(this.soundAdapter.estimatedDuration);
        }
        private function onPlaybackComplete(_arg1:Event):void{
            signalComplete();
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.traits.*;
    import flash.media.*;

    public class AudioAudioTrait extends AudioTrait {

        private var soundAdapter:SoundAdapter;

        public function AudioAudioTrait(_arg1:SoundAdapter){
            this.soundAdapter = _arg1;
            _arg1.soundTransform.volume = volume;
            _arg1.soundTransform.pan = pan;
        }
        override protected function volumeChangeStart(_arg1:Number):void{
            var _local2:SoundTransform = this.soundAdapter.soundTransform;
            _local2.volume = ((muted) ? 0 : _arg1);
            this.soundAdapter.soundTransform = _local2;
        }
        override protected function mutedChangeStart(_arg1:Boolean):void{
            var _local2:SoundTransform = this.soundAdapter.soundTransform;
            _local2.volume = ((_arg1) ? 0 : volume);
            this.soundAdapter.soundTransform = _local2;
        }
        override protected function panChangeStart(_arg1:Number):void{
            var _local2:SoundTransform = this.soundAdapter.soundTransform;
            _local2.pan = _arg1;
            this.soundAdapter.soundTransform = _local2;
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements.audioClasses {
    import org.osmf.traits.*;
    import flash.events.*;

    public class AudioPlayTrait extends PlayTrait {

        private var lastPlayFailed:Boolean = false;
        private var soundAdapter:SoundAdapter;

        public function AudioPlayTrait(_arg1:SoundAdapter){
            this.soundAdapter = _arg1;
            _arg1.addEventListener(Event.COMPLETE, this.onPlaybackComplete, false, 1, true);
        }
        override protected function playStateChangeStart(_arg1:String):void{
            if (_arg1 == PlayState.PLAYING){
                this.lastPlayFailed = !(this.soundAdapter.play());
            } else {
                if (_arg1 == PlayState.PAUSED){
                    this.soundAdapter.pause();
                } else {
                    if (_arg1 == PlayState.STOPPED){
                        this.soundAdapter.stop();
                    };
                };
            };
        }
        override protected function playStateChangeEnd():void{
            if (this.lastPlayFailed){
                stop();
                this.lastPlayFailed = false;
            } else {
                super.playStateChangeEnd();
            };
        }
        private function onPlaybackComplete(_arg1:Event):void{
            stop();
        }

    }
}//package org.osmf.elements.audioClasses 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import org.osmf.elements.f4mClasses.*;
    import org.osmf.elements.f4mClasses.builders.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import org.osmf.elements.proxyClasses.*;

    public class F4MLoader extends LoaderBase {

        public static const F4M_MIME_TYPE:String = "application/f4m+xml";
        private static const F4M_EXTENSION:String = "f4m";

        private var supportedMimeTypes:Vector.<String>;
        private var factory:MediaFactory;
        private var parser:ManifestParser;
        private var parserTimer:Timer;
        private var builders:Vector.<BaseManifestBuilder>;
        private var loadTrait:LoadTrait;

        public function F4MLoader(_arg1:MediaFactory=null){
            this.supportedMimeTypes = new Vector.<String>();
            super();
            this.supportedMimeTypes.push(F4M_MIME_TYPE);
            if (_arg1 == null){
                _arg1 = new DefaultMediaFactory();
            };
            this.factory = _arg1;
            this.builders = this.getBuilders();
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local3:URLResource;
            var _local4:String;
            var _local5:DynamicStreamingResource;
            var _local2:int = MediaTypeUtil.checkMetadataMatchWithResource(_arg1, new Vector.<String>(), this.supportedMimeTypes);
            if (_local2 == MediaTypeUtil.METADATA_MATCH_FOUND){
                return (true);
            };
            if ((_arg1 is URLResource)){
                if ((_arg1 is DynamicStreamingResource)){
                    _local5 = DynamicStreamingResource(_arg1);
                    if (_local5.streamItems.length > 0){
                        return (false);
                    };
                };
                _local3 = URLResource(_arg1);
                _local4 = new URL(_local3.url).extension;
                return ((_local4 == F4M_EXTENSION));
            };
            return (false);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            var manifest:* = null;
            var manifestLoader:* = null;
            var onError:* = null;
            var onComplete:* = null;
            var loadTrait:* = _arg1;
            onError = function (_arg1:ErrorEvent):void{
                manifestLoader.removeEventListener(Event.COMPLETE, onComplete);
                manifestLoader.removeEventListener(IOErrorEvent.IO_ERROR, onError);
                manifestLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(0, _arg1.text)));
            };
            onComplete = function (_arg1:Event):void{
                var resourceData:* = null;
                var event:* = _arg1;
                manifestLoader.removeEventListener(Event.COMPLETE, onComplete);
                manifestLoader.removeEventListener(IOErrorEvent.IO_ERROR, onError);
                manifestLoader.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
                try {
                    resourceData = String((event.target as URLLoader).data);
                    parser = getParser(resourceData);
                    parser.addEventListener(ParseEvent.PARSE_COMPLETE, onParserLoadComplete);
                    parser.addEventListener(ParseEvent.PARSE_ERROR, onParserLoadError);
                    parserTimer = new Timer(OSMFSettings.f4mParseTimeout, 1);
                    parserTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onParserTimerComplete);
                    parserTimer.start();
                    parser.parse(resourceData, URL.normalizePathForURL(URLResource(loadTrait.resource).url, true));
                } catch(parseError:Error) {
                    updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                    loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(parseError.errorID, parseError.message)));
                };
            };
            this.loadTrait = loadTrait;
            updateLoadTrait(loadTrait, LoadState.LOADING);
            manifestLoader = new URLLoader(new URLRequest(URLResource(loadTrait.resource).url));
            manifestLoader.addEventListener(Event.COMPLETE, onComplete);
            manifestLoader.addEventListener(IOErrorEvent.IO_ERROR, onError);
            manifestLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onError);
        }
        private function onParserTimerComplete(_arg1:TimerEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer = null;
            };
            updateLoadTrait(this.loadTrait, LoadState.LOAD_ERROR);
            this.loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR))));
        }
        private function onParserLoadComplete(_arg1:ParseEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer.stop();
                this.parserTimer = null;
            };
            this.parser.removeEventListener(ParseEvent.PARSE_COMPLETE, this.onParserLoadComplete);
            this.parser.removeEventListener(ParseEvent.PARSE_ERROR, this.onParserLoadError);
            var _local2:Manifest = (_arg1.data as Manifest);
            this.finishManifestLoad(_local2);
        }
        private function onParserLoadError(_arg1:ParseEvent):void{
            if (this.parserTimer){
                this.parserTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onParserTimerComplete);
                this.parserTimer.stop();
                this.parserTimer = null;
            };
            this.parser.removeEventListener(ParseEvent.PARSE_COMPLETE, this.onParserLoadComplete);
            this.parser.removeEventListener(ParseEvent.PARSE_ERROR, this.onParserLoadError);
            updateLoadTrait(this.loadTrait, LoadState.LOAD_ERROR);
            this.loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, OSMFStrings.getString(OSMFStrings.F4M_PARSE_ERROR))));
        }
        private function finishManifestLoad(_arg1:Manifest):void{
            var netResource:* = null;
            var loadedElem:* = null;
            var manifest:* = _arg1;
            try {
                netResource = this.parser.createResource(manifest, URLResource(this.loadTrait.resource));
                loadedElem = this.factory.createMediaElement(netResource);
                if (((loadedElem.hasOwnProperty("defaultDuration")) && (!(isNaN(manifest.duration))))){
                    loadedElem["defaultDuration"] = manifest.duration;
                };
                LoadFromDocumentLoadTrait(this.loadTrait).mediaElement = loadedElem;
                updateLoadTrait(this.loadTrait, LoadState.READY);
            } catch(error:Error) {
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.F4M_FILE_INVALID, error.message)));
            };
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.UNINITIALIZED);
        }
        protected function getBuilders():Vector.<BaseManifestBuilder>{
            var _local1:Vector.<BaseManifestBuilder> = new Vector.<BaseManifestBuilder>();
            _local1.push(new MultiLevelManifestBuilder());
            _local1.push(new ManifestBuilder());
            return (_local1);
        }
        private function getParser(_arg1:String):ManifestParser{
            var _local2:ManifestParser;
            var _local3:BaseManifestBuilder;
            for each (_local3 in this.builders) {
                if (_local3.canParse(_arg1)){
                    _local2 = (_local3.build(_arg1) as ManifestParser);
                    break;
                };
            };
            return (_local2);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.net.rtmpstreaming.*;
    import org.osmf.net.httpstreaming.*;

    public class VideoElement extends LightweightVideoElement {

        private var _alternateLoaders:Vector.<LoaderBase>;

        public function VideoElement(_arg1:MediaResourceBase=null, _arg2:NetLoader=null){
            super(null, null);
            super.loader = _arg2;
            this.resource = _arg1;
        }
        override public function set resource(_arg1:MediaResourceBase):void{
            loader = getLoaderForResource(_arg1, this.alternateLoaders);
            super.resource = _arg1;
        }
        private function get alternateLoaders():Vector.<LoaderBase>{
            if (this._alternateLoaders == null){
                this._alternateLoaders = new Vector.<LoaderBase>();
                this._alternateLoaders.push(new HTTPStreamingNetLoader());
                this._alternateLoaders.push(new RTMPDynamicStreamingNetLoader());
                this._alternateLoaders.push(new NetLoader());
            };
            return (this._alternateLoaders);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import __AS3__.vec.*;
    import org.osmf.utils.*;
    import org.osmf.elements.loaderClasses.*;

    public class ImageLoader extends LoaderBase {

        private static const MIME_TYPES_SUPPORTED:Vector.<String> = Vector.<String>(["image/png", "image/gif", "image/jpeg"]);
        private static const MEDIA_TYPES_SUPPORTED:Vector.<String> = Vector.<String>([MediaType.IMAGE]);

        private var checkPolicyFile:Boolean;

        public function ImageLoader(_arg1:Boolean=true){
            this.checkPolicyFile = _arg1;
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local4:URL;
            var _local2:int = MediaTypeUtil.checkMetadataMatchWithResource(_arg1, MEDIA_TYPES_SUPPORTED, MIME_TYPES_SUPPORTED);
            if (_local2 != MediaTypeUtil.METADATA_MATCH_UNKNOWN){
                return ((_local2 == MediaTypeUtil.METADATA_MATCH_FOUND));
            };
            var _local3:URLResource = (_arg1 as URLResource);
            if (((!((_local3 == null))) && (!((_local3.url == null))))){
                _local4 = new URL(_local3.url);
                return (!((_local4.path.search(/\.gif$|\.jpg$|\.png$/i) == -1)));
            };
            return (false);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            LoaderUtils.loadLoadTrait(_arg1, updateLoadTrait, false, this.checkPolicyFile);
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            LoaderUtils.unloadLoadTrait(_arg1, updateLoadTrait);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.display.*;
    import org.osmf.elements.loaderClasses.*;

    public class ImageElement extends LoadableElementBase {

        private var _smoothing:Boolean;

        public function ImageElement(_arg1:URLResource=null, _arg2:ImageLoader=null){
            if (_arg2 == null){
                _arg2 = new ImageLoader();
            };
            super(_arg1, _arg2);
        }
        public function get smoothing():Boolean{
            return (this._smoothing);
        }
        public function set smoothing(_arg1:Boolean):void{
            if (this._smoothing != _arg1){
                this._smoothing = _arg1;
                this.applySmoothingSetting();
            };
        }
        override protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return (new LoaderLoadTrait(_arg2, _arg1));
        }
        override protected function processReadyState():void{
            var _local1:LoaderLoadTrait = (getTrait(MediaTraitType.LOAD) as LoaderLoadTrait);
            addTrait(MediaTraitType.DISPLAY_OBJECT, LoaderUtils.createDisplayObjectTrait(_local1.loader, this));
            this.applySmoothingSetting();
        }
        override protected function processUnloadingState():void{
            removeTrait(MediaTraitType.DISPLAY_OBJECT);
        }
        private function applySmoothingSetting():void{
            var _local2:Loader;
            var _local3:Bitmap;
            var _local1:DisplayObjectTrait = (getTrait(MediaTraitType.DISPLAY_OBJECT) as DisplayObjectTrait);
            if (_local1){
                _local2 = (_local1.displayObject as Loader);
                if (_local2 != null){
                    try {
                        _local3 = (_local2.content as Bitmap);
                        if (_local3 != null){
                            _local3.smoothing = this._smoothing;
                        };
                    } catch(error:SecurityError) {
                    };
                };
            };
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements.proxyClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;

    public class LoadFromDocumentLoadTrait extends LoadTrait {

        private var _mediaElement:MediaElement;

        public function LoadFromDocumentLoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            super(_arg1, _arg2);
        }
        override protected function loadStateChangeEnd():void{
            dispatchEvent(new LoadEvent(LoadEvent.LOAD_STATE_CHANGE, false, false, loadState));
        }
        public function set mediaElement(_arg1:MediaElement):void{
            this._mediaElement = _arg1;
        }
        public function get mediaElement():MediaElement{
            return (this._mediaElement);
        }

    }
}//package org.osmf.elements.proxyClasses 
﻿package org.osmf.elements.proxyClasses {
    import org.osmf.events.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;

    public class ProxyMetadata extends Metadata {

        private var proxiedMetadata:Metadata;

        public function ProxyMetadata(){
            this.proxiedMetadata = new Metadata();
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_ADD, this.redispatchEvent);
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_CHANGE, this.redispatchEvent);
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_REMOVE, this.redispatchEvent);
        }
        public function set metadata(_arg1:Metadata):void{
            var _local2:String;
            this.proxiedMetadata.removeEventListener(MetadataEvent.VALUE_ADD, this.redispatchEvent);
            this.proxiedMetadata.removeEventListener(MetadataEvent.VALUE_CHANGE, this.redispatchEvent);
            this.proxiedMetadata.removeEventListener(MetadataEvent.VALUE_REMOVE, this.redispatchEvent);
            for each (_local2 in this.proxiedMetadata.keys) {
                _arg1.addValue(_local2, this.proxiedMetadata.getValue(_local2));
            };
            this.proxiedMetadata = _arg1;
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_ADD, this.redispatchEvent);
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_CHANGE, this.redispatchEvent);
            this.proxiedMetadata.addEventListener(MetadataEvent.VALUE_REMOVE, this.redispatchEvent);
        }
        override public function getValue(_arg1:String){
            return (this.proxiedMetadata.getValue(_arg1));
        }
        override public function addValue(_arg1:String, _arg2:Object):void{
            this.proxiedMetadata.addValue(_arg1, _arg2);
        }
        override public function removeValue(_arg1:String){
            return (this.proxiedMetadata.removeValue(_arg1));
        }
        override public function get keys():Vector.<String>{
            return (this.proxiedMetadata.keys);
        }
        private function redispatchEvent(_arg1:Event):void{
            dispatchEvent(_arg1.clone());
        }

    }
}//package org.osmf.elements.proxyClasses 
﻿package org.osmf.elements {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import __AS3__.vec.*;
    import org.osmf.utils.*;
    import org.osmf.elements.loaderClasses.*;

    public class SWFLoader extends LoaderBase {

        private static const MIME_TYPES_SUPPORTED:Vector.<String> = Vector.<String>(["application/x-shockwave-flash"]);
        private static const MEDIA_TYPES_SUPPORTED:Vector.<String> = Vector.<String>([MediaType.SWF]);

        public static var allowValidationOfLoadedContent:Boolean = true;

        private var useCurrentSecurityDomain:Boolean = false;
        private var _validateLoadedContentFunction:Function = null;

        public function SWFLoader(_arg1:Boolean=false){
            this.useCurrentSecurityDomain = _arg1;
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local4:URL;
            var _local2:int = MediaTypeUtil.checkMetadataMatchWithResource(_arg1, MEDIA_TYPES_SUPPORTED, MIME_TYPES_SUPPORTED);
            if (_local2 != MediaTypeUtil.METADATA_MATCH_UNKNOWN){
                return ((_local2 == MediaTypeUtil.METADATA_MATCH_FOUND));
            };
            var _local3:URLResource = (_arg1 as URLResource);
            if (((!((_local3 == null))) && (!((_local3.url == null))))){
                _local4 = new URL(_local3.url);
                return (!((_local4.path.search(/\.swf$/i) == -1)));
            };
            return (false);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            LoaderUtils.loadLoadTrait(_arg1, updateLoadTrait, this.useCurrentSecurityDomain, false, this.validateLoadedContentFunction);
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            LoaderUtils.unloadLoadTrait(_arg1, updateLoadTrait);
        }
        public function get validateLoadedContentFunction():Function{
            return (((allowValidationOfLoadedContent) ? this._validateLoadedContentFunction : null));
        }
        public function set validateLoadedContentFunction(_arg1:Function):void{
            this._validateLoadedContentFunction = _arg1;
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import org.osmf.utils.*;
    import org.osmf.elements.proxyClasses.*;

    public class ProxyElement extends MediaElement {

        private var _proxiedMetadata:ProxyMetadata;
        private var _proxiedElement:MediaElement;
        private var _blockedTraits:Vector.<String>;

        public function ProxyElement(_arg1:MediaElement=null){
            this.addEventListener(MediaElementEvent.TRAIT_ADD, this.onProxyTraitAdd, false, int.MAX_VALUE);
            this.addEventListener(MediaElementEvent.TRAIT_REMOVE, this.onProxyTraitRemove, false, int.MAX_VALUE);
            this.addEventListener(ContainerChangeEvent.CONTAINER_CHANGE, this.onProxyContainerChange);
            this.proxiedElement = _arg1;
        }
        public function get proxiedElement():MediaElement{
            return (this._proxiedElement);
        }
        public function set proxiedElement(_arg1:MediaElement):void{
            var _local2:String;
            if (_arg1 != this._proxiedElement){
                if (this._proxiedElement != null){
                    this.toggleMediaElementListeners(this._proxiedElement, false);
                    for each (_local2 in this._proxiedElement.traitTypes) {
                        if ((((super.hasTrait(_local2) == false)) && ((((this._blockedTraits == null)) || ((this._blockedTraits.indexOf(_local2) == -1)))))){
                            super.dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_REMOVE, false, false, _local2));
                        };
                    };
                };
                this._proxiedElement = _arg1;
                if (this._proxiedElement != null){
                    ProxyMetadata(metadata).metadata = this._proxiedElement.metadata;
                    this._proxiedElement.dispatchEvent(new ContainerChangeEvent(ContainerChangeEvent.CONTAINER_CHANGE, false, false, this._proxiedElement.container, container));
                    this.toggleMediaElementListeners(this._proxiedElement, true);
                    for each (_local2 in this._proxiedElement.traitTypes) {
                        if ((((super.hasTrait(_local2) == false)) && ((((this._blockedTraits == null)) || ((this._blockedTraits.indexOf(_local2) == -1)))))){
                            super.dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_ADD, false, false, _local2));
                        };
                    };
                };
            };
        }
        override public function get traitTypes():Vector.<String>{
            var _local2:String;
            var _local1:Vector.<String> = new Vector.<String>();
            for each (_local2 in MediaTraitType.ALL_TYPES) {
                if (this.hasTrait(_local2)){
                    _local1.push(_local2);
                };
            };
            return (_local1);
        }
        override public function hasTrait(_arg1:String):Boolean{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return (!((this.getTrait(_arg1) == null)));
        }
        override public function getTrait(_arg1:String):MediaTraitBase{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local2:MediaTraitBase;
            if (this.blocksTrait(_arg1) == false){
                _local2 = ((super.getTrait(_arg1)) || (((this.proxiedElement)!=null) ? this.proxiedElement.getTrait(_arg1) : null));
            };
            return (_local2);
        }
        override public function get resource():MediaResourceBase{
            return (((this.proxiedElement) ? this.proxiedElement.resource : null));
        }
        override public function set resource(_arg1:MediaResourceBase):void{
            if (this.proxiedElement != null){
                this.proxiedElement.resource = _arg1;
            };
        }
        override protected function addTrait(_arg1:String, _arg2:MediaTraitBase):void{
            if ((((((this.blocksTrait(_arg1) == false)) && (!((this.proxiedElement == null))))) && ((this.proxiedElement.hasTrait(_arg1) == true)))){
                super.dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_REMOVE, false, false, _arg1));
            };
            super.addTrait(_arg1, _arg2);
        }
        override protected function removeTrait(_arg1:String):MediaTraitBase{
            var _local2:MediaTraitBase = super.removeTrait(_arg1);
            if ((((((this.blocksTrait(_arg1) == false)) && (!((this.proxiedElement == null))))) && ((this.proxiedElement.hasTrait(_arg1) == true)))){
                super.dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_ADD, false, false, _arg1));
            };
            return (_local2);
        }
        override protected function createMetadata():Metadata{
            return (new ProxyMetadata());
        }
        final protected function get blockedTraits():Vector.<String>{
            if (this._blockedTraits == null){
                this._blockedTraits = new Vector.<String>();
            };
            return (this._blockedTraits);
        }
        final protected function set blockedTraits(_arg1:Vector.<String>):void{
            var _local4:String;
            if (_arg1 == this._blockedTraits){
                return;
            };
            var _local2:Array = [];
            var _local3:Array = [];
            if (this._proxiedElement != null){
                for each (_local4 in MediaTraitType.ALL_TYPES) {
                    if (_arg1.indexOf(_local4) != -1){
                        if ((((this._blockedTraits == null)) || ((this._blockedTraits.indexOf(_local4) == -1)))){
                            _local2.push(_local4);
                        };
                    } else {
                        if (((!((this._blockedTraits == null))) && (!((this._blockedTraits.indexOf(_local4) == -1))))){
                            _local3.push(_local4);
                        };
                    };
                };
            };
            if (this._proxiedElement != null){
                for each (_local4 in _local2) {
                    if (((this.proxiedElement.hasTrait(_local4)) || (super.hasTrait(_local4)))){
                        dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_REMOVE, false, false, _local4));
                    };
                };
                this._blockedTraits = _arg1;
                for each (_local4 in _local3) {
                    if (((this.proxiedElement.hasTrait(_local4)) || (super.hasTrait(_local4)))){
                        dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_ADD, false, false, _local4));
                    };
                };
            } else {
                this._blockedTraits = _arg1;
            };
        }
        private function toggleMediaElementListeners(_arg1:MediaElement, _arg2:Boolean):void{
            if (_arg2){
                this._proxiedElement.addEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                this._proxiedElement.addEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                this._proxiedElement.addEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                this._proxiedElement.addEventListener(MediaElementEvent.METADATA_ADD, this.onMetadataEvent);
                this._proxiedElement.addEventListener(MediaElementEvent.METADATA_REMOVE, this.onMetadataEvent);
            } else {
                this._proxiedElement.removeEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                this._proxiedElement.removeEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                this._proxiedElement.removeEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                this._proxiedElement.removeEventListener(MediaElementEvent.METADATA_ADD, this.onMetadataEvent);
                this._proxiedElement.removeEventListener(MediaElementEvent.METADATA_REMOVE, this.onMetadataEvent);
            };
        }
        private function onMediaError(_arg1:MediaErrorEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function onTraitAdd(_arg1:MediaElementEvent):void{
            this.processTraitsChangeEvent(_arg1);
        }
        private function onTraitRemove(_arg1:MediaElementEvent):void{
            this.processTraitsChangeEvent(_arg1);
        }
        private function onMetadataEvent(_arg1:MediaElementEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function onProxyContainerChange(_arg1:ContainerChangeEvent):void{
            if (this.proxiedElement != null){
                this.proxiedElement.dispatchEvent(_arg1.clone());
            };
        }
        private function onProxyTraitAdd(_arg1:MediaElementEvent):void{
            this.processProxyTraitsChangeEvent(_arg1);
        }
        private function onProxyTraitRemove(_arg1:MediaElementEvent):void{
            this.processProxyTraitsChangeEvent(_arg1);
        }
        private function processTraitsChangeEvent(_arg1:MediaElementEvent):void{
            if ((((this.blocksTrait(_arg1.traitType) == false)) && ((super.hasTrait(_arg1.traitType) == false)))){
                super.dispatchEvent(_arg1.clone());
            };
        }
        private function processProxyTraitsChangeEvent(_arg1:MediaElementEvent):void{
            if (this.blocksTrait(_arg1.traitType) == true){
                _arg1.stopImmediatePropagation();
            };
        }
        private function blocksTrait(_arg1:String):Boolean{
            return (((this._blockedTraits) && (!((this._blockedTraits.indexOf(_arg1) == -1)))));
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import org.osmf.utils.*;
    import org.osmf.elements.proxyClasses.*;

    public class LoadFromDocumentElement extends ProxyElement {

        private var _resource:MediaResourceBase;
        private var loadTrait:LoadFromDocumentLoadTrait;
        private var loader:LoaderBase;

        public function LoadFromDocumentElement(_arg1:MediaResourceBase=null, _arg2:LoaderBase=null){
            super(null);
            this.loader = _arg2;
            this.resource = _arg1;
            if (_arg2 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
        }
        override public function set resource(_arg1:MediaResourceBase):void{
            if (((!((this._resource == _arg1))) && (!((_arg1 == null))))){
                this._resource = _arg1;
                if ((_arg1 is StreamingXMLResource)){
                    this.loader = new XMLLoader();
                };
                this.loadTrait = new LoadFromDocumentLoadTrait(this.loader, this.resource);
                this.loadTrait.addEventListener(LoadEvent.LOAD_STATE_CHANGE, this.onLoadStateChange, false, int.MAX_VALUE);
                if (super.getTrait(MediaTraitType.LOAD) != null){
                    super.removeTrait(MediaTraitType.LOAD);
                };
                super.addTrait(MediaTraitType.LOAD, this.loadTrait);
            };
        }
        override public function get resource():MediaResourceBase{
            return (this._resource);
        }
        private function onLoaderStateChange(_arg1:Event):void{
            removeTrait(MediaTraitType.LOAD);
            proxiedElement = this.loadTrait.mediaElement;
        }
        private function onLoadStateChange(_arg1:LoadEvent):void{
            var proxiedLoadTrait:* = null;
            var onProxiedElementLoadStateChange:* = null;
            var event:* = _arg1;
            if (event.loadState == LoadState.READY){
                onProxiedElementLoadStateChange = function (_arg1:LoadEvent):void{
                    if (_arg1.loadState == LoadState.LOADING){
                        _arg1.stopImmediatePropagation();
                    } else {
                        proxiedLoadTrait.removeEventListener(LoadEvent.LOAD_STATE_CHANGE, onProxiedElementLoadStateChange);
                    };
                };
                event.stopImmediatePropagation();
                removeTrait(MediaTraitType.LOAD);
                proxiedLoadTrait = (this.loadTrait.mediaElement.getTrait(MediaTraitType.LOAD) as LoadTrait);
                proxiedLoadTrait.addEventListener(LoadEvent.LOAD_STATE_CHANGE, onProxiedElementLoadStateChange, false, int.MAX_VALUE);
                proxiedElement = this.loadTrait.mediaElement;
                if (proxiedLoadTrait.loadState == LoadState.UNINITIALIZED){
                    proxiedLoadTrait.load();
                };
            };
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.elements.compositeClasses {

    public final class CompositionMode {

        public static const PARALLEL:String = "parallel";
        public static const SERIAL:String = "serial";

    }
}//package org.osmf.elements.compositeClasses 
﻿package org.osmf.elements {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import flash.media.*;
    import org.osmf.elements.audioClasses.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class SoundLoader extends LoaderBase {

        private static const MIME_TYPES_SUPPORTED:Vector.<String> = Vector.<String>(["audio/mpeg"]);
        private static const MEDIA_TYPES_SUPPORTED:Vector.<String> = Vector.<String>([MediaType.AUDIO]);
        private static const MIN_BYTES_TO_RECEIVE:int = 16;

        private var checkPolicyFile:Boolean;

        public function SoundLoader(_arg1:Boolean=false){
            this.checkPolicyFile = _arg1;
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local2:int = MediaTypeUtil.checkMetadataMatchWithResource(_arg1, MEDIA_TYPES_SUPPORTED, MIME_TYPES_SUPPORTED);
            if (_local2 != MediaTypeUtil.METADATA_MATCH_UNKNOWN){
                return ((_local2 == MediaTypeUtil.METADATA_MATCH_FOUND));
            };
            var _local3:URLResource = (_arg1 as URLResource);
            if ((((((_local3 == null)) || ((_local3.url == null)))) || ((_local3.url.length <= 0)))){
                return (false);
            };
            var _local4:URL = new URL(_local3.url);
            if (_local4.protocol == ""){
                return (!((_local4.path.search(/\.mp3$|\.m4a$/i) == -1)));
            };
            if (_local4.protocol.search(/file$|http$|https$/i) != -1){
                return ((((((((_local4.path == null)) || ((_local4.path.length <= 0)))) || ((_local4.path.indexOf(".") == -1)))) || (!((_local4.path.search(/\.mp3$|\.m4a$/i) == -1)))));
            };
            return (false);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            var soundLoadTrait:* = null;
            var sound:* = null;
            var onProgress:* = null;
            var onIOError:* = null;
            var loadTrait:* = _arg1;
            var toggleSoundListeners:* = function (_arg1:Sound, _arg2:Boolean):void{
                if (_arg2){
                    _arg1.addEventListener(ProgressEvent.PROGRESS, onProgress);
                    _arg1.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
                } else {
                    _arg1.removeEventListener(ProgressEvent.PROGRESS, onProgress);
                    _arg1.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
                };
            };
            onProgress = function (_arg1:ProgressEvent):void{
                if ((((_arg1.bytesTotal >= MIN_BYTES_TO_RECEIVE)) && ((soundLoadTrait.loadState == LoadState.LOADING)))){
                    toggleSoundListeners(sound, false);
                    soundLoadTrait.sound = sound;
                    updateLoadTrait(soundLoadTrait, LoadState.READY);
                };
            };
            onIOError = function (_arg1:IOErrorEvent, _arg2:String=null):void{
                toggleSoundListeners(sound, false);
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.IO_ERROR, ((_arg1) ? _arg1.text : _arg2))));
            };
            var handleSecurityError:* = function (_arg1:String):void{
                toggleSoundListeners(sound, false);
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.SECURITY_ERROR, _arg1)));
            };
            soundLoadTrait = (loadTrait as SoundLoadTrait);
            updateLoadTrait(soundLoadTrait, LoadState.LOADING);
            sound = new Sound();
            toggleSoundListeners(sound, true);
            var urlRequest:* = new URLRequest((soundLoadTrait.resource as URLResource).url.toString());
            var context:* = new SoundLoaderContext(1000, this.checkPolicyFile);
            try {
                sound.load(urlRequest, context);
            } catch(ioError:IOError) {
                onIOError(null, ioError.message);
            } catch(securityError:SecurityError) {
                handleSecurityError(securityError.message);
            };
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            var _local2:SoundLoadTrait = (_arg1 as SoundLoadTrait);
            updateLoadTrait(_local2, LoadState.UNLOADING);
            try {
                if (_local2.sound != null){
                    _local2.sound.close();
                };
            } catch(error:IOError) {
            };
            updateLoadTrait(_local2, LoadState.UNINITIALIZED);
        }

    }
}//package org.osmf.elements 
﻿package org.osmf.metadata {

    public class TimelineMarker {

        private var _time:Number;
        private var _duration:Number;

        public function TimelineMarker(_arg1:Number, _arg2:Number=NaN){
            this._time = _arg1;
            this._duration = _arg2;
        }
        public function get time():Number{
            return (this._time);
        }
        public function get duration():Number{
            return (this._duration);
        }

    }
}//package org.osmf.metadata 
﻿package org.osmf.metadata {

    public class CuePoint extends TimelineMarker {

        public static const EMBEDDED_CUEPOINTS_NAMESPACE:String = "http://www.osmf.org/timeline/embeddedCuePoints/1.0";
        public static const DYNAMIC_CUEPOINTS_NAMESPACE:String = "http://www.osmf.org/timeline/dynamicCuePoints/1.0";

        private var _name:String;
        private var _type:String;
        private var _parameters:Object;

        public function CuePoint(_arg1:String, _arg2:Number, _arg3:String, _arg4:Object, _arg5:Number=NaN){
            super(_arg2, _arg5);
            this._type = _arg1;
            this._name = _arg3;
            this._parameters = _arg4;
        }
        public function get type():String{
            return (this._type);
        }
        public function get name():String{
            return (this._name);
        }
        public function get parameters():Object{
            return (this._parameters);
        }

    }
}//package org.osmf.metadata 
﻿package org.osmf.metadata {
    import org.osmf.events.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class Metadata extends EventDispatcher {

        private var data:Dictionary;

        public function getValue(_arg1:String){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            return (((this.data)!=null) ? this.data[_arg1] : null);
        }
        public function addValue(_arg1:String, _arg2:Object):void{
            var _local4:Event;
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (this.data == null){
                this.data = new Dictionary();
            };
            var _local3:* = this.data[_arg1];
            this.data[_arg1] = _arg2;
            if (_local3 != _arg2){
                _local4 = (((_local3 === undefined)) ? new MetadataEvent(MetadataEvent.VALUE_ADD, false, false, _arg1, _arg2) : new MetadataEvent(MetadataEvent.VALUE_CHANGE, false, false, _arg1, _arg2, _local3));
                dispatchEvent(_local4);
            };
        }
        public function removeValue(_arg1:String){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            var _local2:* = this.data[_arg1];
            if (_local2 !== undefined){
                delete this.data[_arg1];
                dispatchEvent(new MetadataEvent(MetadataEvent.VALUE_REMOVE, false, false, _arg1, _local2));
            };
            return (_local2);
        }
        public function get keys():Vector.<String>{
            var _local2:Object;
            var _local1:Vector.<String> = new Vector.<String>();
            if (this.data != null){
                for (_local2 in this.data) {
                    _local1.push(_local2);
                };
            };
            return (_local1);
        }
        public function get synthesizer():MetadataSynthesizer{
            return (null);
        }

    }
}//package org.osmf.metadata 
﻿package org.osmf.metadata {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class TimelineMetadata extends Metadata {

        private static const CHECK_INTERVAL:Number = 100;
        private static const TOLERANCE:Number = 0.25;

        private var temporalKeyCollection:Vector.<Number>;
        private var temporalValueCollection:Vector.<TimelineMarker>;
        private var media:MediaElement;
        private var timeTrait:TimeTrait;
        private var seekTrait:SeekTrait;
        private var playTrait:PlayTrait;
        private var lastFiredTemporalMetadataIndex:int;
        private var intervalTimer:Timer;
        private var restartTimer:Boolean;
        private var _enabled:Boolean;
        private var durationTimers:Dictionary;

        public function TimelineMetadata(_arg1:MediaElement){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.media = _arg1;
            this._enabled = true;
            this.intervalTimer = new Timer(CHECK_INTERVAL);
            this.intervalTimer.addEventListener(TimerEvent.TIMER, this.onIntervalTimer);
            this.timeTrait = (_arg1.getTrait(MediaTraitType.TIME) as TimeTrait);
            this.seekTrait = (_arg1.getTrait(MediaTraitType.SEEK) as SeekTrait);
            this.setupTraitEventListener(MediaTraitType.SEEK);
            this.playTrait = (_arg1.getTrait(MediaTraitType.PLAY) as PlayTrait);
            this.setupTraitEventListener(MediaTraitType.PLAY);
            _arg1.addEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
            _arg1.addEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
        }
        public function get numMarkers():int{
            return (((this.temporalValueCollection) ? this.temporalValueCollection.length : 0));
        }
        public function getMarkerAt(_arg1:int):TimelineMarker{
            if ((((((_arg1 >= 0)) && (!((this.temporalValueCollection == null))))) && ((_arg1 < this.temporalValueCollection.length)))){
                return (this.temporalValueCollection[_arg1]);
            };
            return (null);
        }
        public function addMarker(_arg1:TimelineMarker):void{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this.addValue(("" + _arg1.time), _arg1);
        }
        public function removeMarker(_arg1:TimelineMarker):TimelineMarker{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return (this.removeValue(("" + _arg1.time)));
        }
        override public function addValue(_arg1:String, _arg2:Object):void{
            var _local5:int;
            var _local3:Number = new Number(_arg1);
            var _local4:TimelineMarker = (_arg2 as TimelineMarker);
            if ((((((((_arg1 == null)) || (isNaN(_local3)))) || ((_local3 < 0)))) || ((_local4 == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (this.temporalValueCollection == null){
                this.temporalKeyCollection = new Vector.<Number>();
                this.temporalKeyCollection.push(_local3);
                this.temporalValueCollection = new Vector.<TimelineMarker>();
                this.temporalValueCollection.push(_arg2);
            } else {
                _local5 = this.findTemporalMetadata(0, (this.temporalValueCollection.length - 1), _local3);
                if (_local5 < 0){
                    _local5 = (_local5 * -1);
                    this.temporalKeyCollection.splice(_local5, 0, _local3);
                    this.temporalValueCollection.splice(_local5, 0, _local4);
                } else {
                    if ((((_local5 == 0)) && (!((_local3 == this.temporalKeyCollection[0]))))){
                        this.temporalKeyCollection.splice(_local5, 0, _local3);
                        this.temporalValueCollection.splice(_local5, 0, _local4);
                    } else {
                        this.temporalKeyCollection[_local5] = _local3;
                        this.temporalValueCollection[_local5] = _local4;
                    };
                };
            };
            this.enabled = true;
            dispatchEvent(new MetadataEvent(MetadataEvent.VALUE_ADD, false, false, _arg1, _local4));
            dispatchEvent(new TimelineMetadataEvent(TimelineMetadataEvent.MARKER_ADD, false, false, _local4));
        }
        override public function removeValue(_arg1:String){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            var _local2:Number = new Number(_arg1);
            var _local3:* = null;
            var _local4:int = ((this.temporalValueCollection) ? this.findTemporalMetadata(0, (this.temporalValueCollection.length - 1), _local2) : -1);
            if (_local4 >= 0){
                this.temporalKeyCollection.splice(_local4, 1);
                _local3 = this.temporalValueCollection.splice(_local4, 1)[0];
                if (this.temporalValueCollection.length == 0){
                    this.reset(false);
                    this.temporalValueCollection = null;
                    this.temporalKeyCollection = null;
                };
                dispatchEvent(new MetadataEvent(MetadataEvent.VALUE_REMOVE, false, false, _arg1, _local3));
                dispatchEvent(new TimelineMetadataEvent(TimelineMetadataEvent.MARKER_REMOVE, false, false, (_local3 as TimelineMarker)));
            };
            return (_local3);
        }
        override public function getValue(_arg1:String){
            var _local3:int;
            var _local4:Number;
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            var _local2:Number = new Number(_arg1);
            if (!isNaN(_local2)){
                _local3 = 0;
                while (_local3 < this.temporalKeyCollection.length) {
                    _local4 = this.temporalKeyCollection[_local3];
                    if (_local4 == _local2){
                        return (this.temporalValueCollection[_local3]);
                    };
                    _local3++;
                };
            };
            return (null);
        }
        public function get enabled():Boolean{
            return (this._enabled);
        }
        public function set enabled(_arg1:Boolean):void{
            this._enabled = _arg1;
            this.reset(_arg1);
        }
        private function startTimer(_arg1:Boolean=true):void{
            if (!_arg1){
                this.intervalTimer.stop();
            } else {
                if (((((((((((!((this.timeTrait == null))) && (!((this.temporalValueCollection == null))))) && ((this.temporalValueCollection.length > 0)))) && (this.restartTimer))) && (this.enabled))) && (!(this.intervalTimer.running)))){
                    if (((!((this.playTrait == null))) && ((this.playTrait.playState == PlayState.PLAYING)))){
                        this.intervalTimer.start();
                    };
                };
            };
        }
        private function reset(_arg1:Boolean):void{
            this.lastFiredTemporalMetadataIndex = -1;
            this.restartTimer = true;
            this.intervalTimer.reset();
            this.intervalTimer.delay = CHECK_INTERVAL;
            if (_arg1){
                this.startTimer();
            };
        }
        private function checkForTemporalMetadata():void{
            var _local1:Number = this.timeTrait.currentTime;
            var _local2:int = this.findTemporalMetadata((this.lastFiredTemporalMetadataIndex + 1), (this.temporalValueCollection.length - 1), _local1);
            if (_local2 <= 0){
                _local2 = (_local2 * -1);
                _local2 = ((_local2)>0) ? (_local2 - 1) : 0;
            };
            if (((!(this.checkTemporalMetadata(_local2, _local1))) && (((_local2 + 1) < this.temporalValueCollection.length)))){
                this.checkTemporalMetadata((_local2 + 1), _local1);
            };
        }
        private function setupTraitEventListener(_arg1:String, _arg2:Boolean=true):void{
            var _local3:PlayEvent;
            if (_arg2){
                if ((((_arg1 == MediaTraitType.SEEK)) && (!((this.seekTrait == null))))){
                    this.seekTrait.addEventListener(SeekEvent.SEEKING_CHANGE, this.onSeekingChange);
                } else {
                    if ((((_arg1 == MediaTraitType.PLAY)) && (!((this.playTrait == null))))){
                        this.playTrait.addEventListener(PlayEvent.PLAY_STATE_CHANGE, this.onPlayStateChange);
                        if (this.playTrait.playState == PlayState.PLAYING){
                            _local3 = new PlayEvent(PlayEvent.PLAY_STATE_CHANGE, false, false, PlayState.PLAYING);
                            this.onPlayStateChange(_local3);
                        };
                    };
                };
            } else {
                if ((((_arg1 == MediaTraitType.SEEK)) && (!((this.seekTrait == null))))){
                    this.seekTrait.removeEventListener(SeekEvent.SEEKING_CHANGE, this.onSeekingChange);
                } else {
                    if ((((_arg1 == MediaTraitType.PLAY)) && (!((this.playTrait == null))))){
                        this.playTrait.removeEventListener(PlayEvent.PLAY_STATE_CHANGE, this.onPlayStateChange);
                    };
                };
            };
        }
        private function onSeekingChange(_arg1:SeekEvent):void{
            if (_arg1.seeking){
                this.reset(true);
            };
        }
        private function onPlayStateChange(_arg1:PlayEvent):void{
            var _local2:Timer;
            if (_arg1.playState == PlayState.PLAYING){
                if (this.durationTimers != null){
                    for each (_local2 in this.durationTimers) {
                        _local2.start();
                    };
                };
                this.startTimer();
            } else {
                if (this.durationTimers != null){
                    for each (_local2 in this.durationTimers) {
                        _local2.stop();
                    };
                };
                this.startTimer(false);
            };
        }
        private function findTemporalMetadata(_arg1:int, _arg2:int, _arg3:Number):int{
            var _local4:int;
            if (_arg1 <= _arg2){
                _local4 = ((_arg1 + _arg2) / 2);
                if (_arg3 == this.temporalKeyCollection[_local4]){
                    return (_local4);
                };
                if (_arg3 < this.temporalKeyCollection[_local4]){
                    return (this.findTemporalMetadata(_arg1, (_local4 - 1), _arg3));
                };
                return (this.findTemporalMetadata((_local4 + 1), _arg2, _arg3));
            };
            return (-(_arg1));
        }
        private function dispatchTemporalEvents(_arg1:int):void{
            var marker:* = null;
            var timer:* = null;
            var endTime:* = NaN;
            var onDurationTimer:* = null;
            var index:* = _arg1;
            marker = this.temporalValueCollection[index];
            dispatchEvent(new TimelineMetadataEvent(TimelineMetadataEvent.MARKER_TIME_REACHED, false, false, marker));
            if (marker.duration > 0){
                onDurationTimer = function (_arg1:TimerEvent):void{
                    if (((timeTrait) && ((timeTrait.currentTime >= endTime)))){
                        timer.removeEventListener(TimerEvent.TIMER, onDurationTimer);
                        delete durationTimers[marker];
                        dispatchEvent(new TimelineMetadataEvent(TimelineMetadataEvent.MARKER_DURATION_REACHED, false, false, marker));
                    };
                };
                timer = new Timer(CHECK_INTERVAL);
                endTime = (marker.time + marker.duration);
                if (this.durationTimers == null){
                    this.durationTimers = new Dictionary();
                };
                this.durationTimers[marker] = timer;
                timer.addEventListener(TimerEvent.TIMER, onDurationTimer);
                timer.start();
            };
        }
        private function checkTemporalMetadata(_arg1:int, _arg2:Number):Boolean{
            var _local4:Number;
            var _local5:Number;
            var _local6:Number;
            if (((!(this.temporalValueCollection)) || (!(this.temporalValueCollection.length)))){
                return (false);
            };
            var _local3:Boolean;
            if ((((((this.temporalValueCollection[_arg1].time >= (_arg2 - TOLERANCE))) && ((this.temporalValueCollection[_arg1].time <= (_arg2 + TOLERANCE))))) && (!((_arg1 == this.lastFiredTemporalMetadataIndex))))){
                this.lastFiredTemporalMetadataIndex = _arg1;
                this.dispatchTemporalEvents(_arg1);
                _local4 = this.temporalKeyCollection[_arg1];
                _local5 = this.calcNextTime(_arg1);
                _local6 = (((_local5 - _local4) * 1000) / 4);
                _local6 = ((_local6)>CHECK_INTERVAL) ? _local6 : CHECK_INTERVAL;
                if (_local4 == _local5){
                    this.startTimer(false);
                    this.restartTimer = false;
                } else {
                    if (_local6 != this.intervalTimer.delay){
                        this.intervalTimer.reset();
                        this.intervalTimer.delay = _local6;
                        this.startTimer();
                    };
                };
                _local3 = true;
            } else {
                if (((!((this.intervalTimer.delay == CHECK_INTERVAL))) && (((_arg2 + (this.intervalTimer.delay / 1000)) > this.calcNextTime(_arg1))))){
                    this.intervalTimer.reset();
                    this.intervalTimer.delay = CHECK_INTERVAL;
                    this.startTimer();
                };
            };
            return (_local3);
        }
        private function calcNextTime(_arg1:int):Number{
            return (this.temporalValueCollection[((((_arg1 + 1) < this.temporalKeyCollection.length)) ? (_arg1 + 1) : (this.temporalKeyCollection.length - 1))].time);
        }
        private function onIntervalTimer(_arg1:TimerEvent):void{
            this.checkForTemporalMetadata();
        }
        private function onTraitAdd(_arg1:MediaElementEvent):void{
            switch (_arg1.traitType){
                case MediaTraitType.TIME:
                    this.timeTrait = (this.media.getTrait(MediaTraitType.TIME) as TimeTrait);
                    this.startTimer();
                    break;
                case MediaTraitType.SEEK:
                    this.seekTrait = (this.media.getTrait(MediaTraitType.SEEK) as SeekTrait);
                    break;
                case MediaTraitType.PLAY:
                    this.playTrait = (this.media.getTrait(MediaTraitType.PLAY) as PlayTrait);
                    break;
            };
            this.setupTraitEventListener(_arg1.traitType);
        }
        private function onTraitRemove(_arg1:MediaElementEvent):void{
            this.setupTraitEventListener(_arg1.traitType, false);
            switch (_arg1.traitType){
                case MediaTraitType.TIME:
                    this.timeTrait = null;
                    if (this.media.hasOwnProperty("numChildren") == false){
                        this.startTimer(false);
                    };
                    break;
                case MediaTraitType.SEEK:
                    this.seekTrait = null;
                    break;
                case MediaTraitType.PLAY:
                    this.playTrait = null;
                    break;
            };
        }

    }
}//package org.osmf.metadata 
﻿package org.osmf.metadata {
    import __AS3__.vec.*;
    import org.osmf.elements.compositeClasses.*;

    public class MetadataSynthesizer {

        public function synthesize(_arg1:String, _arg2:Metadata, _arg3:Vector.<Metadata>, _arg4:String, _arg5:Metadata):Metadata{
            var _local6:Metadata;
            if ((((_arg4 == CompositionMode.SERIAL)) && (_arg5))){
                _local6 = (_arg5.getValue(_arg1) as Metadata);
            } else {
                _local6 = ((_arg3.length)>=1) ? _arg3[0] : null;
            };
            return (_local6);
        }

    }
}//package org.osmf.metadata 
﻿package org.osmf.metadata {

    public final class MetadataNamespaces {

        public static const MEDIA_ELEMENT_METADATA:String = "http://www.osmf.org/mediaElement/1.0";
        public static const DERIVED_RESOURCE_METADATA:String = "http://www.osmf.org/derivedResource/1.0";
        public static const FMS_SERVER_VERSION_METADATA:String = "http://www.osmf.org/fmsServerVersion/1.0";
        public static const ELEMENT_ID:String = "http://www.osmf.org/layout/elementId/1.0";
        public static const LAYOUT_RENDERER_TYPE:String = "http://www.osmf.org/layout/renderer_type/1.0";
        public static const ABSOLUTE_LAYOUT_PARAMETERS:String = "http://www.osmf.org/layout/absolute/1.0";
        public static const RELATIVE_LAYOUT_PARAMETERS:String = "http://www.osmf.org/layout/relative/1.0";
        public static const ANCHOR_LAYOUT_PARAMETERS:String = "http://www.osmf.org/layout/anchor/1.0";
        public static const PADDING_LAYOUT_PARAMETERS:String = "http://www.osmf.org/layout/padding/1.0";
        public static const LAYOUT_ATTRIBUTES:String = "http://www.osmf.org/layout/attributes/1.0";
        public static const OVERLAY_LAYOUT_PARAMETERS:String = "http://www.osmf.org/layout/overlay/1.0";
        public static const BOX_LAYOUT_ATTRIBUTES:String = "http://www.osmf.org/layout/attributes/box/1.0";
        public static const DRM_METADATA:String = "http://www.osmf.org/drm/1.0";
        public static const MULTICAST_INFO:String = "http://www.osmf.org/multicast/info/1.0";
        public static const MULTICAST_NET_LOADER:String = "http://www.osmf.org/multicast/netloader/1.0";
        public static const DVR_METADATA:String = "http://www.osmf.org/dvr/1.0";
        public static const DRM_ADDITIONAL_HEADER_KEY:String = "DRMAdditionalHeader";
        public static const HTTP_STREAMING_METADATA:String = "http://www.osmf.org/httpstreaming/1.0";
        public static const HTTP_STREAMING_BOOTSTRAP_KEY:String = "bootstrap";
        public static const HTTP_STREAMING_STREAM_METADATA_KEY:String = "streamMetadata";
        public static const HTTP_STREAMING_XMP_METADATA_KEY:String = "xmpMetadata";
        public static const HTTP_STREAMING_SERVER_BASE_URLS_KEY:String = "serverBaseUrls";
        public static const HTTP_STREAMING_DVR_BEGIN_OFFSET_KEY:String = "beginOffset";
        public static const HTTP_STREAMING_DVR_END_OFFSET_KEY:String = "endOffset";
        public static const HTTP_STREAMING_DVR_WINDOW_DURATION_KEY:String = "windowDuration";
        public static const HTTP_STREAMING_DVR_OFFLINE_KEY:String = "dvrOffline";
        public static const HTTP_STREAMING_DVR_ID_KEY:String = "dvrId";
        public static const RESOURCE_INITIAL_INDEX:String = "resourceInitialIndex";
        public static const BEST_EFFORT_FETCH_METADATA:String = "http://www.osmf.org/bestEffortFetch/1.0";
        public static const HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_FORWARD_FETCHES:String = "bestEffortFetchMaxForwardFetches";
        public static const HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_BACKWARD_FETCHES:String = "bestEffortFetchMaxBackwardFetches";
        public static const HTTP_STREAMING_BEST_EFFORT_FETCH_SEGMENT_DURATION:String = "bestEffortFetchSegmentDuration";
        public static const HTTP_STREAMING_BEST_EFFORT_FETCH_FRAGMENT_DURATION:String = "bestEffortFetchFragmentDuration";

    }
}//package org.osmf.metadata 
﻿package org.osmf.media {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import flash.display.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class MediaPlayer extends TraitEventDispatcher {

        private static const DEFAULT_UPDATE_INTERVAL:Number = 250;

        private var lastCurrentTime:Number = 0;
        private var lastBytesLoaded:Number = NaN;
        private var _autoPlay:Boolean = true;
        private var _autoRewind:Boolean = true;
        private var _loop:Boolean = false;
        private var _currentTimeUpdateInterval:Number = 250;
        private var _currentTimeTimer:Timer;
        private var _state:String;
        private var _bytesLoadedUpdateInterval:Number = 250;
        private var _bytesLoadedTimer:Timer;
        private var inExecuteAutoRewind:Boolean = false;
        private var inSeek:Boolean = false;
        private var mediaAtEnd:Boolean = false;
        private var mediaPlayerVolume:Number = 1;
        private var mediaPlayerVolumeSet:Boolean = false;
        private var mediaPlayerMuted:Boolean = false;
        private var mediaPlayerMutedSet:Boolean = false;
        private var mediaPlayerAudioPan:Number = 0;
        private var mediaPlayerAudioPanSet:Boolean = false;
        private var mediaPlayerBufferTime:Number = 0;
        private var mediaPlayerBufferTimeSet:Boolean = false;
        private var mediaPlayerMaxAllowedDynamicStreamIndex:int = 0;
        private var mediaPlayerMaxAllowedDynamicStreamIndexSet:Boolean = false;
        private var mediaPlayerAutoDynamicStreamSwitch:Boolean = true;
        private var mediaPlayerAutoDynamicStreamSwitchSet:Boolean = false;
        private var _canPlay:Boolean;
        private var _canSeek:Boolean;
        private var _temporal:Boolean;
        private var _hasAudio:Boolean;
        private var _hasDisplayObject:Boolean;
        private var _canLoad:Boolean;
        private var _canBuffer:Boolean;
        private var _isDynamicStream:Boolean;
        private var _hasAlternativeAudio:Boolean;
        private var _hasDRM:Boolean;

        public function MediaPlayer(_arg1:MediaElement=null){
            this._currentTimeTimer = new Timer(DEFAULT_UPDATE_INTERVAL);
            this._bytesLoadedTimer = new Timer(DEFAULT_UPDATE_INTERVAL);
            super();
            this._state = MediaPlayerState.UNINITIALIZED;
            this.media = _arg1;
            this._currentTimeTimer.addEventListener(TimerEvent.TIMER, this.onCurrentTimeTimer, false, 0, true);
            this._bytesLoadedTimer.addEventListener(TimerEvent.TIMER, this.onBytesLoadedTimer, false, 0, true);
        }
        override public function set media(_arg1:MediaElement):void{
            var _local2:String;
            var _local3:LoadTrait;
            if (_arg1 != media){
                this.mediaAtEnd = false;
                if (media != null){
                    this.inExecuteAutoRewind = false;
                    if (this.playing){
                        (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).stop();
                    };
                    if (this.canLoad){
                        _local3 = (media.getTrait(MediaTraitType.LOAD) as LoadTrait);
                        if (_local3.loadState == LoadState.READY){
                            _local3.unload();
                        };
                    };
                    this.setState(MediaPlayerState.UNINITIALIZED);
                    if (media){
                        media.removeEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                        media.removeEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                        media.removeEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                        for each (_local2 in media.traitTypes) {
                            this.updateTraitListeners(_local2, false);
                        };
                    };
                };
                super.media = _arg1;
                if (media != null){
                    media.addEventListener(MediaElementEvent.TRAIT_ADD, this.onTraitAdd);
                    media.addEventListener(MediaElementEvent.TRAIT_REMOVE, this.onTraitRemove);
                    media.addEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                    if (media.hasTrait(MediaTraitType.LOAD) == false){
                        this.processReadyState();
                    };
                    for each (_local2 in media.traitTypes) {
                        this.updateTraitListeners(_local2, true);
                    };
                };
                dispatchEvent(new MediaElementChangeEvent(MediaElementChangeEvent.MEDIA_ELEMENT_CHANGE));
            };
        }
        public function set autoRewind(_arg1:Boolean):void{
            this._autoRewind = _arg1;
        }
        public function get autoRewind():Boolean{
            return (this._autoRewind);
        }
        public function set autoPlay(_arg1:Boolean):void{
            this._autoPlay = _arg1;
        }
        public function get autoPlay():Boolean{
            return (this._autoPlay);
        }
        public function set loop(_arg1:Boolean):void{
            this._loop = _arg1;
        }
        public function get loop():Boolean{
            return (this._loop);
        }
        public function set currentTimeUpdateInterval(_arg1:Number):void{
            if (this._currentTimeUpdateInterval != _arg1){
                this._currentTimeUpdateInterval = _arg1;
                if (((isNaN(this._currentTimeUpdateInterval)) || ((this._currentTimeUpdateInterval <= 0)))){
                    this._currentTimeTimer.stop();
                } else {
                    this._currentTimeTimer.delay = this._currentTimeUpdateInterval;
                    if (this.temporal){
                        this._currentTimeTimer.start();
                    };
                };
            };
        }
        public function get currentTimeUpdateInterval():Number{
            return (this._currentTimeUpdateInterval);
        }
        public function set bytesLoadedUpdateInterval(_arg1:Number):void{
            if (this._bytesLoadedUpdateInterval != _arg1){
                this._bytesLoadedUpdateInterval = _arg1;
                if (((isNaN(this._bytesLoadedUpdateInterval)) || ((this._bytesLoadedUpdateInterval <= 0)))){
                    this._bytesLoadedTimer.stop();
                } else {
                    this._bytesLoadedTimer.delay = this._bytesLoadedUpdateInterval;
                    if (this.canLoad){
                        this._bytesLoadedTimer.start();
                    };
                };
            };
        }
        public function get bytesLoadedUpdateInterval():Number{
            return (this._bytesLoadedUpdateInterval);
        }
        public function get state():String{
            return (this._state);
        }
        public function get canPlay():Boolean{
            return (this._canPlay);
        }
        public function get canPause():Boolean{
            return (((this.canPlay) ? (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).canPause : false));
        }
        public function get canSeek():Boolean{
            return (this._canSeek);
        }
        public function get temporal():Boolean{
            return (this._temporal);
        }
        public function get hasAudio():Boolean{
            return (this._hasAudio);
        }
        public function get isDynamicStream():Boolean{
            return (this._isDynamicStream);
        }
        public function get hasAlternativeAudio():Boolean{
            return (this._hasAlternativeAudio);
        }
        public function get canLoad():Boolean{
            return (this._canLoad);
        }
        public function get canBuffer():Boolean{
            return (this._canBuffer);
        }
        public function get hasDRM():Boolean{
            return (this._hasDRM);
        }
        public function get volume():Number{
            return (((this.hasAudio) ? AudioTrait(this.getTraitOrThrow(MediaTraitType.AUDIO)).volume : this.mediaPlayerVolume));
        }
        public function set volume(_arg1:Number):void{
            var _local2:Boolean;
            if (this.hasAudio){
                (this.getTraitOrThrow(MediaTraitType.AUDIO) as AudioTrait).volume = _arg1;
            } else {
                if (_arg1 != this.mediaPlayerVolume){
                    _local2 = true;
                };
            };
            this.mediaPlayerVolume = _arg1;
            this.mediaPlayerVolumeSet = true;
            if (_local2){
                dispatchEvent(new AudioEvent(AudioEvent.VOLUME_CHANGE, false, false, false, _arg1));
            };
        }
        public function get muted():Boolean{
            return (((this.hasAudio) ? AudioTrait(this.getTraitOrThrow(MediaTraitType.AUDIO)).muted : this.mediaPlayerMuted));
        }
        public function set muted(_arg1:Boolean):void{
            var _local2:Boolean;
            if (this.hasAudio){
                (this.getTraitOrThrow(MediaTraitType.AUDIO) as AudioTrait).muted = _arg1;
            } else {
                if (_arg1 != this.mediaPlayerMuted){
                    _local2 = true;
                };
            };
            this.mediaPlayerMuted = _arg1;
            this.mediaPlayerMutedSet = true;
            if (_local2){
                dispatchEvent(new AudioEvent(AudioEvent.MUTED_CHANGE, false, false, _arg1));
            };
        }
        public function get audioPan():Number{
            return (((this.hasAudio) ? AudioTrait(this.getTraitOrThrow(MediaTraitType.AUDIO)).pan : this.mediaPlayerAudioPan));
        }
        public function set audioPan(_arg1:Number):void{
            var _local2:Boolean;
            if (this.hasAudio){
                (this.getTraitOrThrow(MediaTraitType.AUDIO) as AudioTrait).pan = _arg1;
            } else {
                if (_arg1 != this.mediaPlayerAudioPan){
                    _local2 = true;
                };
            };
            this.mediaPlayerAudioPan = _arg1;
            this.mediaPlayerAudioPanSet = true;
            if (_local2){
                dispatchEvent(new AudioEvent(AudioEvent.PAN_CHANGE, false, false, false, NaN, _arg1));
            };
        }
        public function get paused():Boolean{
            return (((this.canPlay) ? ((this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).playState == PlayState.PAUSED) : false));
        }
        public function pause():void{
            (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).pause();
        }
        public function get playing():Boolean{
            return (((this.canPlay) ? ((this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).playState == PlayState.PLAYING) : false));
        }
        public function play():void{
            if (((((((this.canPlay) && (this.canSeek))) && (this.canSeekTo(0)))) && (this.mediaAtEnd))){
                this.executeAutoRewind(true);
            } else {
                (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).play();
            };
        }
        public function get seeking():Boolean{
            return (((this.canSeek) ? (this.getTraitOrThrow(MediaTraitType.SEEK) as SeekTrait).seeking : false));
        }
        public function seek(_arg1:Number):void{
            this.inSeek = true;
            (this.getTraitOrThrow(MediaTraitType.SEEK) as SeekTrait).seek(_arg1);
            this.inSeek = false;
        }
        public function canSeekTo(_arg1:Number):Boolean{
            return (((this.canSeek) ? (this.getTraitOrThrow(MediaTraitType.SEEK) as SeekTrait).canSeekTo(_arg1) : false));
        }
        public function stop():void{
            (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).stop();
            if (this.canSeek){
                this.executeAutoRewind(false);
            };
        }
        public function get mediaWidth():Number{
            return (((this._hasDisplayObject) ? (this.getTraitOrThrow(MediaTraitType.DISPLAY_OBJECT) as DisplayObjectTrait).mediaWidth : NaN));
        }
        public function get mediaHeight():Number{
            return (((this._hasDisplayObject) ? (this.getTraitOrThrow(MediaTraitType.DISPLAY_OBJECT) as DisplayObjectTrait).mediaHeight : NaN));
        }
        public function get autoDynamicStreamSwitch():Boolean{
            return (((this.isDynamicStream) ? (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).autoSwitch : this.mediaPlayerAutoDynamicStreamSwitch));
        }
        public function set autoDynamicStreamSwitch(_arg1:Boolean):void{
            var _local2:Boolean;
            if (this.isDynamicStream){
                (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).autoSwitch = _arg1;
            } else {
                if (_arg1 != this.mediaPlayerAutoDynamicStreamSwitch){
                    _local2 = true;
                };
            };
            this.mediaPlayerAutoDynamicStreamSwitch = _arg1;
            this.mediaPlayerAutoDynamicStreamSwitchSet = true;
            if (_local2){
                dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.AUTO_SWITCH_CHANGE, false, false, this.dynamicStreamSwitching, this.mediaPlayerAutoDynamicStreamSwitch));
            };
        }
        public function get currentDynamicStreamIndex():int{
            return (((this.isDynamicStream) ? (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).currentIndex : 0));
        }
        public function get numDynamicStreams():int{
            return (((this.isDynamicStream) ? (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).numDynamicStreams : 0));
        }
        public function getBitrateForDynamicStreamIndex(_arg1:int):Number{
            return ((this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).getBitrateForIndex(_arg1));
        }
        public function get currentAlternativeAudioStreamIndex():int{
            return (((this.hasAlternativeAudio) ? (this.getTraitOrThrow(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait).currentIndex : -1));
        }
        public function get numAlternativeAudioStreams():int{
            return (((this.hasAlternativeAudio) ? (this.getTraitOrThrow(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait).numAlternativeAudioStreams : 0));
        }
        public function getAlternativeAudioItemAt(_arg1:int):StreamingItem{
            return ((this.getTraitOrThrow(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait).getItemForIndex(_arg1));
        }
        public function get maxAllowedDynamicStreamIndex():int{
            return (((this.isDynamicStream) ? (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).maxAllowedIndex : this.mediaPlayerMaxAllowedDynamicStreamIndex));
        }
        public function set maxAllowedDynamicStreamIndex(_arg1:int):void{
            if (this.isDynamicStream){
                (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).maxAllowedIndex = _arg1;
            };
            this.mediaPlayerMaxAllowedDynamicStreamIndex = _arg1;
            this.mediaPlayerMaxAllowedDynamicStreamIndexSet = true;
        }
        public function get dynamicStreamSwitching():Boolean{
            return (((this.isDynamicStream) ? (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).switching : false));
        }
        public function get alternativeAudioStreamSwitching():Boolean{
            return (((this.hasAlternativeAudio) ? (this.getTraitOrThrow(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait).switching : false));
        }
        public function switchDynamicStreamIndex(_arg1:int):void{
            (this.getTraitOrThrow(MediaTraitType.DYNAMIC_STREAM) as DynamicStreamTrait).switchTo(_arg1);
        }
        public function switchAlternativeAudioIndex(_arg1:int):void{
            (this.getTraitOrThrow(MediaTraitType.ALTERNATIVE_AUDIO) as AlternativeAudioTrait).switchTo(_arg1);
        }
        public function get displayObject():DisplayObject{
            return (((this._hasDisplayObject) ? (this.getTraitOrThrow(MediaTraitType.DISPLAY_OBJECT) as DisplayObjectTrait).displayObject : null));
        }
        public function get duration():Number{
            return (((this.temporal) ? (this.getTraitOrThrow(MediaTraitType.TIME) as TimeTrait).duration : 0));
        }
        public function get currentTime():Number{
            return (((this.temporal) ? (this.getTraitOrThrow(MediaTraitType.TIME) as TimeTrait).currentTime : 0));
        }
        public function get buffering():Boolean{
            return (((this.canBuffer) ? (this.getTraitOrThrow(MediaTraitType.BUFFER) as BufferTrait).buffering : false));
        }
        public function get bufferLength():Number{
            return (((this.canBuffer) ? (this.getTraitOrThrow(MediaTraitType.BUFFER) as BufferTrait).bufferLength : 0));
        }
        public function get bufferTime():Number{
            return (((this.canBuffer) ? (this.getTraitOrThrow(MediaTraitType.BUFFER) as BufferTrait).bufferTime : this.mediaPlayerBufferTime));
        }
        public function set bufferTime(_arg1:Number):void{
            var _local2:Boolean;
            if (this.canBuffer){
                (this.getTraitOrThrow(MediaTraitType.BUFFER) as BufferTrait).bufferTime = _arg1;
            } else {
                if (_arg1 != this.mediaPlayerBufferTime){
                    _local2 = true;
                };
            };
            this.mediaPlayerBufferTime = _arg1;
            this.mediaPlayerBufferTimeSet = true;
            if (_local2){
                dispatchEvent(new BufferEvent(BufferEvent.BUFFER_TIME_CHANGE, false, false, this.buffering, this.mediaPlayerBufferTime));
            };
        }
        public function get bytesLoaded():Number{
            var _local1:Number = 0;
            if (this.canLoad){
                _local1 = (this.getTraitOrThrow(MediaTraitType.LOAD) as LoadTrait).bytesLoaded;
                if (isNaN(_local1)){
                    _local1 = 0;
                };
            };
            return (_local1);
        }
        public function get bytesTotal():Number{
            var _local1:Number = 0;
            if (this.canLoad){
                _local1 = (this.getTraitOrThrow(MediaTraitType.LOAD) as LoadTrait).bytesTotal;
                if (isNaN(_local1)){
                    _local1 = 0;
                };
            };
            return (_local1);
        }
        public function authenticate(_arg1:String=null, _arg2:String=null):void{
            (this.getTraitOrThrow(MediaTraitType.DRM) as DRMTrait).authenticate(_arg1, _arg2);
        }
        public function authenticateWithToken(_arg1:Object):void{
            (this.getTraitOrThrow(MediaTraitType.DRM) as DRMTrait).authenticateWithToken(_arg1);
        }
        public function get drmState():String{
            return (((this.hasDRM) ? DRMTrait(media.getTrait(MediaTraitType.DRM)).drmState : DRMState.UNINITIALIZED));
        }
        public function get drmStartDate():Date{
            return (((this.hasDRM) ? DRMTrait(media.getTrait(MediaTraitType.DRM)).startDate : null));
        }
        public function get drmEndDate():Date{
            return (((this.hasDRM) ? DRMTrait(media.getTrait(MediaTraitType.DRM)).endDate : null));
        }
        public function get drmPeriod():Number{
            return (((this.hasDRM) ? DRMTrait(media.getTrait(MediaTraitType.DRM)).period : NaN));
        }
        public function get isDVRRecording():Boolean{
            var _local1:DVRTrait = ((media)!=null) ? (media.getTrait(MediaTraitType.DVR) as DVRTrait) : null;
            return (((_local1)!=null) ? _local1.isRecording : false);
        }
        private function getTraitOrThrow(_arg1:String):MediaTraitBase{
            var _local2:String;
            var _local3:String;
            if (((!(media)) || (!(media.hasTrait(_arg1))))){
                _local2 = OSMFStrings.getString(OSMFStrings.CAPABILITY_NOT_SUPPORTED);
                _local3 = _arg1.replace("[class ", "");
                _local3 = _local3.replace("]", "").toLowerCase();
                _local2 = _local2.replace("*trait*", _local3);
                throw (new IllegalOperationError(_local2));
            };
            return (media.getTrait(_arg1));
        }
        private function onMediaError(_arg1:MediaErrorEvent):void{
            this.setState(MediaPlayerState.PLAYBACK_ERROR);
            dispatchEvent(_arg1.clone());
        }
        private function onTraitAdd(_arg1:MediaElementEvent):void{
            this.updateTraitListeners(_arg1.traitType, true);
        }
        private function onTraitRemove(_arg1:MediaElementEvent):void{
            this.updateTraitListeners(_arg1.traitType, false);
        }
        private function updateTraitListeners(_arg1:String, _arg2:Boolean, _arg3:Boolean=true):void{
            var _local4:TimeTrait;
            var _local5:PlayTrait;
            var _local6:AudioTrait;
            var _local7:DynamicStreamTrait;
            var _local8:AlternativeAudioTrait;
            var _local9:DisplayObjectTrait;
            var _local10:LoadTrait;
            var _local11:BufferTrait;
            var _local12:String;
            if ((((((this.state == MediaPlayerState.PLAYBACK_ERROR)) && (_arg3))) && (!((_arg1 == MediaTraitType.LOAD))))){
                return;
            };
            if (_arg2){
                this.updateCapabilityForTrait(_arg1, _arg2);
            };
            switch (_arg1){
                case MediaTraitType.TIME:
                    this.changeListeners(_arg2, _arg1, TimeEvent.COMPLETE, this.onComplete);
                    this._temporal = _arg2;
                    if (((((_arg2) && ((this._currentTimeUpdateInterval > 0)))) && (!(isNaN(this._currentTimeUpdateInterval))))){
                        this._currentTimeTimer.start();
                    } else {
                        this._currentTimeTimer.stop();
                    };
                    _local4 = TimeTrait(media.getTrait(MediaTraitType.TIME));
                    if (((((!((_local4.currentTime == 0))) && ((this._currentTimeUpdateInterval > 0)))) && (!(isNaN(this._currentTimeUpdateInterval))))){
                        dispatchEvent(new TimeEvent(TimeEvent.CURRENT_TIME_CHANGE, false, false, this.currentTime));
                    };
                    if (_local4.duration != 0){
                        dispatchEvent(new TimeEvent(TimeEvent.DURATION_CHANGE, false, false, this.duration));
                    };
                    break;
                case MediaTraitType.PLAY:
                    this.changeListeners(_arg2, _arg1, PlayEvent.PLAY_STATE_CHANGE, this.onPlayStateChange);
                    this.changeListeners(_arg2, _arg1, PlayEvent.LIVE_STALL, this.onLiveStall);
                    this.changeListeners(_arg2, _arg1, PlayEvent.LIVE_RESUME, this.onLiveResume);
                    this._canPlay = _arg2;
                    _local5 = PlayTrait(media.getTrait(MediaTraitType.PLAY));
                    if (((((((this.autoPlay) && (this.canPlay))) && (!(this.playing)))) && (!(this.inSeek)))){
                        this.play();
                    } else {
                        if (_local5.playState != PlayState.STOPPED){
                            dispatchEvent(new PlayEvent(PlayEvent.PLAY_STATE_CHANGE, false, false, ((_arg2) ? _local5.playState : PlayState.STOPPED)));
                        };
                    };
                    if (_local5.canPause){
                        dispatchEvent(new PlayEvent(PlayEvent.CAN_PAUSE_CHANGE, false, false, null, _arg2));
                    };
                    break;
                case MediaTraitType.AUDIO:
                    this._hasAudio = _arg2;
                    _local6 = AudioTrait(media.getTrait(MediaTraitType.AUDIO));
                    if (this.mediaPlayerVolumeSet){
                        this.volume = this.mediaPlayerVolume;
                    } else {
                        if (this.mediaPlayerVolume != _local6.volume){
                            dispatchEvent(new AudioEvent(AudioEvent.VOLUME_CHANGE, false, false, this.muted, this.volume, this.audioPan));
                        };
                    };
                    if (this.mediaPlayerMutedSet){
                        this.muted = this.mediaPlayerMuted;
                    } else {
                        if (this.mediaPlayerMuted != _local6.muted){
                            dispatchEvent(new AudioEvent(AudioEvent.MUTED_CHANGE, false, false, this.muted, this.volume, this.audioPan));
                        };
                    };
                    if (this.mediaPlayerAudioPanSet){
                        this.audioPan = this.mediaPlayerAudioPan;
                    } else {
                        if (this.mediaPlayerAudioPan != _local6.pan){
                            dispatchEvent(new AudioEvent(AudioEvent.PAN_CHANGE, false, false, this.muted, this.volume, this.audioPan));
                        };
                    };
                    break;
                case MediaTraitType.SEEK:
                    this.changeListeners(_arg2, _arg1, SeekEvent.SEEKING_CHANGE, this.onSeeking);
                    this._canSeek = _arg2;
                    if (((SeekTrait(media.getTrait(MediaTraitType.SEEK)).seeking) && (!(this.inExecuteAutoRewind)))){
                        dispatchEvent(new SeekEvent(SeekEvent.SEEKING_CHANGE, false, false, _arg2));
                    };
                    break;
                case MediaTraitType.DYNAMIC_STREAM:
                    this._isDynamicStream = _arg2;
                    _local7 = DynamicStreamTrait(media.getTrait(MediaTraitType.DYNAMIC_STREAM));
                    if (this.mediaPlayerMaxAllowedDynamicStreamIndexSet){
                        this.maxAllowedDynamicStreamIndex = this.mediaPlayerMaxAllowedDynamicStreamIndex;
                    };
                    if (this.mediaPlayerAutoDynamicStreamSwitchSet){
                        this.autoDynamicStreamSwitch = this.mediaPlayerAutoDynamicStreamSwitch;
                    } else {
                        if (this.mediaPlayerAutoDynamicStreamSwitch != _local7.autoSwitch){
                            dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.AUTO_SWITCH_CHANGE, false, false, this.dynamicStreamSwitching, this.autoDynamicStreamSwitch));
                        };
                    };
                    if (_local7.switching){
                        dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.SWITCHING_CHANGE, false, false, this.dynamicStreamSwitching, this.autoDynamicStreamSwitch));
                    };
                    dispatchEvent(new DynamicStreamEvent(DynamicStreamEvent.NUM_DYNAMIC_STREAMS_CHANGE, false, false, this.dynamicStreamSwitching, this.autoDynamicStreamSwitch));
                    break;
                case MediaTraitType.ALTERNATIVE_AUDIO:
                    this._hasAlternativeAudio = _arg2;
                    _local8 = AlternativeAudioTrait(media.getTrait(MediaTraitType.ALTERNATIVE_AUDIO));
                    if (((_local8.switching) && (_arg2))){
                        dispatchEvent(new AlternativeAudioEvent(AlternativeAudioEvent.AUDIO_SWITCHING_CHANGE, false, false, _local8.switching));
                    };
                    dispatchEvent(new AlternativeAudioEvent(AlternativeAudioEvent.NUM_ALTERNATIVE_AUDIO_STREAMS_CHANGE, false, false, ((_local8.switching) && (_arg2))));
                    break;
                case MediaTraitType.DISPLAY_OBJECT:
                    this._hasDisplayObject = _arg2;
                    _local9 = DisplayObjectTrait(media.getTrait(MediaTraitType.DISPLAY_OBJECT));
                    if (_local9.displayObject != null){
                        dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.DISPLAY_OBJECT_CHANGE, false, false, null, this.displayObject, NaN, NaN, this.mediaWidth, this.mediaHeight));
                    };
                    if (((!(isNaN(_local9.mediaHeight))) || (!(isNaN(_local9.mediaWidth))))){
                        dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.MEDIA_SIZE_CHANGE, false, false, null, this.displayObject, NaN, NaN, this.mediaWidth, this.mediaHeight));
                    };
                    break;
                case MediaTraitType.LOAD:
                    this.changeListeners(_arg2, _arg1, LoadEvent.LOAD_STATE_CHANGE, this.onLoadState);
                    this._canLoad = _arg2;
                    _local10 = LoadTrait(media.getTrait(MediaTraitType.LOAD));
                    if (_local10.bytesLoaded > 0){
                        dispatchEvent(new LoadEvent(LoadEvent.BYTES_LOADED_CHANGE, false, false, null, this.bytesLoaded));
                    };
                    if (_local10.bytesTotal > 0){
                        dispatchEvent(new LoadEvent(LoadEvent.BYTES_TOTAL_CHANGE, false, false, null, this.bytesTotal));
                    };
                    if (_arg2){
                        _local12 = (media.getTrait(_arg1) as LoadTrait).loadState;
                        if (((!((_local12 == LoadState.READY))) && (!((_local12 == LoadState.LOADING))))){
                            this.load();
                        } else {
                            if (((((this.autoPlay) && (this.canPlay))) && (!(this.playing)))){
                                this.play();
                            };
                        };
                        if ((((this._bytesLoadedUpdateInterval > 0)) && (!(isNaN(this._bytesLoadedUpdateInterval))))){
                            this._bytesLoadedTimer.start();
                        } else {
                            this._bytesLoadedTimer.stop();
                        };
                    };
                    break;
                case MediaTraitType.BUFFER:
                    this.changeListeners(_arg2, _arg1, BufferEvent.BUFFERING_CHANGE, this.onBuffering);
                    this._canBuffer = _arg2;
                    _local11 = BufferTrait(media.getTrait(MediaTraitType.BUFFER));
                    if (this.mediaPlayerBufferTimeSet){
                        this.bufferTime = this.mediaPlayerBufferTime;
                    } else {
                        if (this.mediaPlayerBufferTime != _local11.bufferTime){
                            dispatchEvent(new BufferEvent(BufferEvent.BUFFER_TIME_CHANGE, false, false, false, this.bufferTime));
                        };
                    };
                    if (_local11.buffering){
                        dispatchEvent(new BufferEvent(BufferEvent.BUFFERING_CHANGE, false, false, this.buffering));
                    };
                    break;
                case MediaTraitType.DRM:
                    this._hasDRM = _arg2;
                    dispatchEvent(new DRMEvent(DRMEvent.DRM_STATE_CHANGE, this.drmState, false, false, this.drmStartDate, this.drmEndDate, this.drmPeriod));
                    break;
            };
            if (_arg2 == false){
                this.updateCapabilityForTrait(_arg1, false);
            };
        }
        private function updateCapabilityForTrait(_arg1:String, _arg2:Boolean):void{
            var _local3:String;
            switch (_arg1){
                case MediaTraitType.AUDIO:
                    _local3 = MediaPlayerCapabilityChangeEvent.HAS_AUDIO_CHANGE;
                    this._hasAudio = _arg2;
                    break;
                case MediaTraitType.BUFFER:
                    _local3 = MediaPlayerCapabilityChangeEvent.CAN_BUFFER_CHANGE;
                    this._canBuffer = _arg2;
                    break;
                case MediaTraitType.DISPLAY_OBJECT:
                    _local3 = MediaPlayerCapabilityChangeEvent.HAS_DISPLAY_OBJECT_CHANGE;
                    break;
                case MediaTraitType.DRM:
                    _local3 = MediaPlayerCapabilityChangeEvent.HAS_DRM_CHANGE;
                    this._hasDRM = _arg2;
                    break;
                case MediaTraitType.DYNAMIC_STREAM:
                    _local3 = MediaPlayerCapabilityChangeEvent.IS_DYNAMIC_STREAM_CHANGE;
                    this._isDynamicStream = _arg2;
                    break;
                case MediaTraitType.ALTERNATIVE_AUDIO:
                    _local3 = MediaPlayerCapabilityChangeEvent.HAS_ALTERNATIVE_AUDIO_CHANGE;
                    this._hasAlternativeAudio = _arg2;
                    break;
                case MediaTraitType.LOAD:
                    _local3 = MediaPlayerCapabilityChangeEvent.CAN_LOAD_CHANGE;
                    this._canLoad = _arg2;
                    break;
                case MediaTraitType.PLAY:
                    _local3 = MediaPlayerCapabilityChangeEvent.CAN_PLAY_CHANGE;
                    this._canPlay = _arg2;
                    break;
                case MediaTraitType.SEEK:
                    _local3 = MediaPlayerCapabilityChangeEvent.CAN_SEEK_CHANGE;
                    this._canSeek = _arg2;
                    break;
                case MediaTraitType.TIME:
                    _local3 = MediaPlayerCapabilityChangeEvent.TEMPORAL_CHANGE;
                    this._temporal = _arg2;
                    break;
            };
            if (_local3 != null){
                dispatchEvent(new MediaPlayerCapabilityChangeEvent(_local3, false, false, _arg2));
            };
        }
        private function changeListeners(_arg1:Boolean, _arg2:String, _arg3:String, _arg4:Function):void{
            var _local5:int;
            if (_arg1){
                _local5 = 1;
                media.getTrait(_arg2).addEventListener(_arg3, _arg4, false, _local5);
            } else {
                if (media.hasTrait(_arg2)){
                    media.getTrait(_arg2).removeEventListener(_arg3, _arg4);
                };
            };
        }
        private function onSeeking(_arg1:SeekEvent):void{
            this.mediaAtEnd = false;
            if ((((_arg1.type == SeekEvent.SEEKING_CHANGE)) && (_arg1.seeking))){
                this.setState(MediaPlayerState.BUFFERING);
            } else {
                if (((this.canPlay) && (this.paused))){
                    this.setState(MediaPlayerState.PAUSED);
                } else {
                    if (((this.canBuffer) && (this.buffering))){
                        this.setState(MediaPlayerState.BUFFERING);
                    } else {
                        if (((this.canPlay) && (this.playing))){
                            this.setState(MediaPlayerState.PLAYING);
                        } else {
                            if (!this.inExecuteAutoRewind){
                                this.setState(MediaPlayerState.READY);
                            };
                        };
                    };
                };
            };
        }
        private function onPlayStateChange(_arg1:PlayEvent):void{
            if (_arg1.playState == PlayState.PLAYING){
                if ((((((this.canBuffer == false)) || ((this.bufferLength > 0)))) || ((this.bufferTime < 0.001)))){
                    this.setState(MediaPlayerState.PLAYING);
                };
            } else {
                if (_arg1.playState == PlayState.PAUSED){
                    this.setState(MediaPlayerState.PAUSED);
                };
            };
        }
        private function onLiveStall(_arg1:PlayEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function onLiveResume(_arg1:PlayEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function onLoadState(_arg1:LoadEvent):void{
            if ((((_arg1.loadState == LoadState.READY)) && ((this.state == MediaPlayerState.LOADING)))){
                this.processReadyState();
            } else {
                if (_arg1.loadState == LoadState.UNINITIALIZED){
                    this.setState(MediaPlayerState.UNINITIALIZED);
                } else {
                    if (_arg1.loadState == LoadState.LOAD_ERROR){
                        this.setState(MediaPlayerState.PLAYBACK_ERROR);
                    } else {
                        if (_arg1.loadState == LoadState.LOADING){
                            this.setState(MediaPlayerState.LOADING);
                        };
                    };
                };
            };
        }
        private function processReadyState():void{
            this.setState(MediaPlayerState.READY);
            if (((((this.autoPlay) && (this.canPlay))) && (!(this.playing)))){
                this.play();
            };
        }
        private function onComplete(_arg1:TimeEvent):void{
            this.mediaAtEnd = true;
            if (((((this.loop) && (this.canSeek))) && (this.canPlay))){
                this.executeAutoRewind(true);
            } else {
                if (((!(this.loop)) && (this.canPlay))){
                    (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).stop();
                    if (((this.autoRewind) && (this.canSeek))){
                        this.executeAutoRewind(false);
                    } else {
                        this.setState(MediaPlayerState.READY);
                    };
                } else {
                    this.setState(MediaPlayerState.READY);
                };
            };
        }
        private function executeAutoRewind(_arg1:Boolean):void{
            var onSeekingChange:* = null;
            var playAfterAutoRewind:* = _arg1;
            if (this.inExecuteAutoRewind == false){
                onSeekingChange = function (_arg1:SeekEvent):void{
                    if (_arg1.seeking == false){
                        removeEventListener(SeekEvent.SEEKING_CHANGE, onSeekingChange);
                        if (playAfterAutoRewind){
                            play();
                        } else {
                            setState(MediaPlayerState.READY);
                        };
                        inExecuteAutoRewind = false;
                    };
                };
                this.inExecuteAutoRewind = true;
                this.mediaAtEnd = false;
                addEventListener(SeekEvent.SEEKING_CHANGE, onSeekingChange);
                this.seek(0);
            };
        }
        private function onCurrentTimeTimer(_arg1:TimerEvent):void{
            if (((((this.temporal) && (!((this.currentTime == this.lastCurrentTime))))) && (((!(this.canSeek)) || (!(this.seeking)))))){
                this.lastCurrentTime = this.currentTime;
                dispatchEvent(new TimeEvent(TimeEvent.CURRENT_TIME_CHANGE, false, false, this.currentTime));
            };
        }
        private function onBytesLoadedTimer(_arg1:TimerEvent):void{
            var _local2:LoadEvent;
            if (((this.canLoad) && (!((this.bytesLoaded == this.lastBytesLoaded))))){
                _local2 = new LoadEvent(LoadEvent.BYTES_LOADED_CHANGE, false, false, null, this.bytesLoaded);
                this.lastBytesLoaded = this.bytesLoaded;
                dispatchEvent(_local2);
            };
        }
        private function onBuffering(_arg1:BufferEvent):void{
            if (_arg1.buffering){
                this.setState(MediaPlayerState.BUFFERING);
            } else {
                if (((this.canPlay) && (this.playing))){
                    this.setState(MediaPlayerState.PLAYING);
                } else {
                    if (((this.canPlay) && (this.paused))){
                        this.setState(MediaPlayerState.PAUSED);
                    } else {
                        this.setState(MediaPlayerState.READY);
                    };
                };
            };
        }
        private function setState(_arg1:String):void{
            var _local2:Boolean;
            var _local3:String;
            if (this._state != _arg1){
                this._state = _arg1;
                dispatchEvent(new MediaPlayerStateChangeEvent(MediaPlayerStateChangeEvent.MEDIA_PLAYER_STATE_CHANGE, false, false, this._state));
                if (_arg1 == MediaPlayerState.PLAYBACK_ERROR){
                    _local2 = this.playing;
                    for each (_local3 in media.traitTypes) {
                        if (_local3 != MediaTraitType.LOAD){
                            this.updateTraitListeners(_local3, false, false);
                        };
                    };
                    if (_local2){
                        (this.getTraitOrThrow(MediaTraitType.PLAY) as PlayTrait).stop();
                    };
                };
            };
        }
        private function load():void{
            var loadTrait:* = null;
            try {
                loadTrait = (media.getTrait(MediaTraitType.LOAD) as LoadTrait);
                if (((!((loadTrait.loadState == LoadState.LOADING))) && (!((loadTrait.loadState == LoadState.READY))))){
                    loadTrait.load();
                };
            } catch(error:IllegalOperationError) {
                setState(MediaPlayerState.PLAYBACK_ERROR);
                dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.MEDIA_LOAD_FAILED, error.message)));
            };
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media.pluginClasses {

    public class VersionUtils {

        public static function parseVersionString(_arg1:String):Object{
            var _local2:Array = _arg1.split(".");
            var _local3:int;
            var _local4:int;
            if (_local2.length >= 1){
                _local3 = parseInt(_local2[0]);
            };
            if (_local2.length >= 2){
                _local4 = parseInt(_local2[1]);
                if (_local4 < 10){
                    _local4 = (_local4 * 10);
                };
            };
            return ({
                major:_local3,
                minor:_local4
            });
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.display.*;
    import org.osmf.elements.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.elements.loaderClasses.*;

    class DynamicPluginLoader extends PluginLoader {

        private static const PLUGININFO_PROPERTY_NAME:String = "pluginInfo";

        public function DynamicPluginLoader(_arg1:MediaFactory, _arg2:String){
            super(_arg1, _arg2);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            return (new SWFLoader().canHandleResource(_arg1));
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            var swfLoader:* = null;
            var loaderLoadTrait:* = null;
            var onSWFLoaderStateChange:* = null;
            var onLoadError:* = null;
            var loadTrait:* = _arg1;
            onSWFLoaderStateChange = function (_arg1:LoaderEvent):void{
                var _local2:DisplayObject;
                var _local3:PluginInfo;
                if (_arg1.newState == LoadState.READY){
                    swfLoader.removeEventListener(LoaderEvent.LOAD_STATE_CHANGE, onSWFLoaderStateChange);
                    loaderLoadTrait.removeEventListener(MediaErrorEvent.MEDIA_ERROR, onLoadError);
                    _local2 = loaderLoadTrait.loader.content;
                    _local3 = (_local2[PLUGININFO_PROPERTY_NAME] as PluginInfo);
                    loadFromPluginInfo(loadTrait, _local3, loaderLoadTrait.loader);
                } else {
                    if (_arg1.newState == LoadState.LOAD_ERROR){
                        swfLoader.removeEventListener(LoaderEvent.LOAD_STATE_CHANGE, onSWFLoaderStateChange);
                        updateLoadTrait(loadTrait, _arg1.newState);
                    };
                };
            };
            onLoadError = function (_arg1:MediaErrorEvent):void{
                loaderLoadTrait.removeEventListener(MediaErrorEvent.MEDIA_ERROR, onLoadError);
                loadTrait.dispatchEvent(_arg1.clone());
            };
            updateLoadTrait(loadTrait, LoadState.LOADING);
            swfLoader = new SWFLoader(true);
            swfLoader.validateLoadedContentFunction = this.validateLoadedContent;
            swfLoader.addEventListener(LoaderEvent.LOAD_STATE_CHANGE, onSWFLoaderStateChange);
            loaderLoadTrait = new LoaderLoadTrait(swfLoader, loadTrait.resource);
            loaderLoadTrait.addEventListener(MediaErrorEvent.MEDIA_ERROR, onLoadError);
            swfLoader.load(loaderLoadTrait);
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.UNLOADING);
            var _local2:PluginLoadTrait = (_arg1 as PluginLoadTrait);
            unloadFromPluginInfo(_local2.pluginInfo);
            _local2.loader.unloadAndStop();
            updateLoadTrait(_arg1, LoadState.UNINITIALIZED);
        }
        private function validateLoadedContent(_arg1:DisplayObject):Boolean{
            var _local2:Object = ((_arg1.hasOwnProperty(PLUGININFO_PROPERTY_NAME)) ? _arg1[PLUGININFO_PROPERTY_NAME] : null);
            return (((_local2)!=null) ? isPluginCompatible(_local2) : false);
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class PluginManager extends EventDispatcher {

        private static const STATIC_PLUGIN_MEDIA_INFO_ID:String = "org.osmf.plugins.StaticPluginLoader";
        private static const DYNAMIC_PLUGIN_MEDIA_INFO_ID:String = "org.osmf.plugins.DynamicPluginLoader";

        private var _mediaFactory:MediaFactory;
        private var _pluginFactory:MediaFactory;
        private var _pluginMap:Dictionary;
        private var _pluginList:Vector.<PluginEntry>;
        private var notificationFunctions:Vector.<Function>;
        private var createdElements:Dictionary;
        private var minimumSupportedFrameworkVersion:String;
        private var staticPluginLoader:StaticPluginLoader;
        private var dynamicPluginLoader:DynamicPluginLoader;

        public function PluginManager(_arg1:MediaFactory){
            this._mediaFactory = _arg1;
            this._mediaFactory.addEventListener(MediaFactoryEvent.MEDIA_ELEMENT_CREATE, this.onMediaElementCreate);
            this.minimumSupportedFrameworkVersion = Version.lastAPICompatibleVersion;
            this.initPluginFactory();
            this._pluginMap = new Dictionary();
            this._pluginList = new Vector.<PluginEntry>();
        }
        public function loadPlugin(_arg1:MediaResourceBase):void{
            var identifier:* = null;
            var pluginEntry:* = null;
            var onLoadStateChange:* = null;
            var onMediaError:* = null;
            var pluginElement:* = null;
            var loadTrait:* = null;
            var resource:* = _arg1;
            onLoadStateChange = function (_arg1:LoadEvent):void{
                var _local2:PluginLoadTrait;
                if (_arg1.loadState == LoadState.READY){
                    pluginEntry.state = PluginLoadingState.LOADED;
                    _pluginList.push(pluginEntry);
                    _local2 = (pluginElement.getTrait(MediaTraitType.LOAD) as PluginLoadTrait);
                    if (_local2.pluginInfo.mediaElementCreationNotificationFunction != null){
                        invokeMediaElementCreationNotificationForCreatedMediaElements(_local2.pluginInfo.mediaElementCreationNotificationFunction);
                        if (notificationFunctions == null){
                            notificationFunctions = new Vector.<Function>();
                        };
                        notificationFunctions.push(_local2.pluginInfo.mediaElementCreationNotificationFunction);
                    };
                    dispatchEvent(new PluginManagerEvent(PluginManagerEvent.PLUGIN_LOAD, false, false, resource));
                } else {
                    if (_arg1.loadState == LoadState.LOAD_ERROR){
                        delete _pluginMap[identifier];
                        dispatchEvent(new PluginManagerEvent(PluginManagerEvent.PLUGIN_LOAD_ERROR, false, false, resource));
                    };
                };
            };
            onMediaError = function (_arg1:MediaErrorEvent):void{
                dispatchEvent(_arg1.clone());
            };
            if (resource == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            identifier = this.getPluginIdentifier(resource);
            pluginEntry = (this._pluginMap[identifier] as PluginEntry);
            if (pluginEntry != null){
                dispatchEvent(new PluginManagerEvent(PluginManagerEvent.PLUGIN_LOAD, false, false, resource));
            } else {
                pluginElement = this._pluginFactory.createMediaElement(resource);
                if (pluginElement != null){
                    pluginEntry = new PluginEntry(pluginElement, PluginLoadingState.LOADING);
                    this._pluginMap[identifier] = pluginEntry;
                    loadTrait = (pluginElement.getTrait(MediaTraitType.LOAD) as LoadTrait);
                    if (loadTrait != null){
                        loadTrait.addEventListener(LoadEvent.LOAD_STATE_CHANGE, onLoadStateChange);
                        loadTrait.addEventListener(MediaErrorEvent.MEDIA_ERROR, onMediaError);
                        loadTrait.load();
                    } else {
                        dispatchEvent(new PluginManagerEvent(PluginManagerEvent.PLUGIN_LOAD_ERROR, false, false, resource));
                    };
                } else {
                    dispatchEvent(new PluginManagerEvent(PluginManagerEvent.PLUGIN_LOAD_ERROR, false, false, resource));
                };
            };
        }
        public function get mediaFactory():MediaFactory{
            return (this._mediaFactory);
        }
        private function getPluginIdentifier(_arg1:MediaResourceBase):Object{
            var _local2:Object;
            if ((_arg1 is URLResource)){
                _local2 = (_arg1 as URLResource).url;
            } else {
                if ((_arg1 is PluginInfoResource)){
                    _local2 = (_arg1 as PluginInfoResource).pluginInfo;
                };
            };
            return (_local2);
        }
        private function initPluginFactory():void{
            this._pluginFactory = new MediaFactory();
            this.staticPluginLoader = new StaticPluginLoader(this.mediaFactory, this.minimumSupportedFrameworkVersion);
            this.dynamicPluginLoader = new DynamicPluginLoader(this.mediaFactory, this.minimumSupportedFrameworkVersion);
            var _local1:MediaFactoryItem = new MediaFactoryItem(STATIC_PLUGIN_MEDIA_INFO_ID, this.staticPluginLoader.canHandleResource, this.createStaticPluginElement);
            this._pluginFactory.addItem(_local1);
            var _local2:MediaFactoryItem = new MediaFactoryItem(DYNAMIC_PLUGIN_MEDIA_INFO_ID, this.dynamicPluginLoader.canHandleResource, this.createDynamicPluginElement);
            this._pluginFactory.addItem(_local2);
        }
        private function createStaticPluginElement():MediaElement{
            return (new PluginElement(this.staticPluginLoader));
        }
        private function createDynamicPluginElement():MediaElement{
            return (new PluginElement(this.dynamicPluginLoader));
        }
        private function onMediaElementCreate(_arg1:MediaFactoryEvent):void{
            this.invokeMediaElementCreationNotifications(_arg1.mediaElement);
            if (this.createdElements == null){
                this.createdElements = new Dictionary(true);
            };
            this.createdElements[_arg1.mediaElement] = true;
        }
        private function invokeMediaElementCreationNotifications(_arg1:MediaElement):void{
            var _local2:Function;
            for each (_local2 in this.notificationFunctions) {
                this.invokeMediaElementCreationNotificationFunction(_local2, _arg1);
            };
        }
        private function invokeMediaElementCreationNotificationFunction(_arg1:Function, _arg2:MediaElement):void{
            try {
                _arg1.call(null, _arg2);
            } catch(error:Error) {
            };
        }
        private function invokeMediaElementCreationNotificationForCreatedMediaElements(_arg1:Function):void{
            var _local2:Object;
            for (_local2 in this.createdElements) {
                this.invokeMediaElementCreationNotificationFunction(_arg1, (_local2 as MediaElement));
            };
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.display.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.utils.*;

    class PluginLoader extends LoaderBase {

        private static const FRAMEWORK_VERSION_PROPERTY_NAME:String = "frameworkVersion";
        private static const IS_FRAMEWORK_VERSION_SUPPORTED_PROPERTY_NAME:String = "isFrameworkVersionSupported";

        private var minimumSupportedFrameworkVersion:String;
        private var mediaFactory:MediaFactory;

        public function PluginLoader(_arg1:MediaFactory, _arg2:String){
            this.mediaFactory = _arg1;
            this.minimumSupportedFrameworkVersion = _arg2;
        }
        protected function unloadFromPluginInfo(_arg1:PluginInfo):void{
            var _local2:int;
            var _local3:MediaFactoryItem;
            var _local4:MediaFactoryItem;
            if (_arg1 != null){
                _local2 = 0;
                while (_local2 < _arg1.numMediaFactoryItems) {
                    _local3 = _arg1.getMediaFactoryItemAt(_local2);
                    _local4 = this.mediaFactory.getItemById(_local3.id);
                    if (_local4 != null){
                        this.mediaFactory.removeItem(_local4);
                    };
                    _local2++;
                };
            };
        }
        protected function loadFromPluginInfo(_arg1:LoadTrait, _arg2:PluginInfo, _arg3:Loader=null):void{
            var passedMediaFactory:* = null;
            var i:* = 0;
            var pluginLoadTrait:* = null;
            var item:* = null;
            var loadTrait:* = _arg1;
            var pluginInfo:* = _arg2;
            var loader = _arg3;
            var invalidImplementation:* = false;
            if (pluginInfo != null){
                if (this.isPluginCompatible(pluginInfo)){
                    try {
                        passedMediaFactory = (loadTrait.resource.getMetadataValue(PluginInfo.PLUGIN_MEDIAFACTORY_NAMESPACE) as MediaFactory);
                        if (passedMediaFactory == null){
                            loadTrait.resource.addMetadataValue(PluginInfo.PLUGIN_MEDIAFACTORY_NAMESPACE, this.mediaFactory);
                        };
                        pluginInfo.initializePlugin(loadTrait.resource);
                        i = 0;
                        while (i < pluginInfo.numMediaFactoryItems) {
                            item = pluginInfo.getMediaFactoryItemAt(i);
                            if (item == null){
                                throw (new RangeError());
                            };
                            this.mediaFactory.addItem(item);
                            i = (i + 1);
                        };
                        pluginLoadTrait = (loadTrait as PluginLoadTrait);
                        pluginLoadTrait.pluginInfo = pluginInfo;
                        pluginLoadTrait.loader = loader;
                        updateLoadTrait(pluginLoadTrait, LoadState.READY);
                    } catch(error:RangeError) {
                        invalidImplementation = true;
                    };
                } else {
                    updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                    loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.PLUGIN_VERSION_INVALID)));
                };
            } else {
                invalidImplementation = true;
            };
            if (invalidImplementation){
                updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                loadTrait.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.PLUGIN_IMPLEMENTATION_INVALID)));
            };
        }
        protected function isPluginCompatible(_arg1:Object):Boolean{
            var _local5:Function;
            var _local2:Boolean;
            var _local3:String = ((_arg1.hasOwnProperty(FRAMEWORK_VERSION_PROPERTY_NAME)) ? _arg1[FRAMEWORK_VERSION_PROPERTY_NAME] : null);
            var _local4:Boolean = this.isPluginVersionSupported(_local3);
            if (_local4){
                _local5 = ((_arg1.hasOwnProperty(IS_FRAMEWORK_VERSION_SUPPORTED_PROPERTY_NAME)) ? (_arg1[IS_FRAMEWORK_VERSION_SUPPORTED_PROPERTY_NAME] as Function) : null);
                if (_local5 != null){
                    try {
                        _local2 = _local5(Version.version);
                    } catch(error:Error) {
                    };
                };
            };
            return (_local2);
        }
        private function isPluginVersionSupported(_arg1:String):Boolean{
            if ((((_arg1 == null)) || ((_arg1.length == 0)))){
                return (false);
            };
            var _local2:Object = VersionUtils.parseVersionString(this.minimumSupportedFrameworkVersion);
            var _local3:Object = VersionUtils.parseVersionString(_arg1);
            return ((((_local3.major > _local2.major)) || ((((_local3.major == _local2.major)) && ((_local3.minor >= _local2.minor))))));
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {

    class PluginLoadingState {

        public static const LOADING:PluginLoadingState = new PluginLoadingState("Loading");
;
        public static const LOADED:PluginLoadingState = new PluginLoadingState("Loaded");
;

        private var _state:String;

        public function PluginLoadingState(_arg1:String){
            this._state = _arg1;
        }
        public function get state():String{
            return (this._state);
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.media.*;
    import org.osmf.traits.*;

    class StaticPluginLoader extends PluginLoader {

        public function StaticPluginLoader(_arg1:MediaFactory, _arg2:String){
            super(_arg1, _arg2);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            return ((_arg1 is PluginInfoResource));
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.LOADING);
            var _local2:PluginInfoResource = (_arg1.resource as PluginInfoResource);
            var _local3:PluginInfo = _local2.pluginInfo;
            loadFromPluginInfo(_arg1, _local3);
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            var _local2:PluginLoadTrait = (_arg1 as PluginLoadTrait);
            var _local3:PluginInfo = _local2.pluginInfo;
            updateLoadTrait(_arg1, LoadState.UNLOADING);
            unloadFromPluginInfo(_local3);
            updateLoadTrait(_arg1, LoadState.UNINITIALIZED);
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.media.*;
    import org.osmf.traits.*;

    class PluginElement extends LoadableElementBase {

        public function PluginElement(_arg1:PluginLoader, _arg2:MediaResourceBase=null){
            super(_arg2, _arg1);
        }
        override protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return (new PluginLoadTrait(_arg2, _arg1));
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.media.*;

    class PluginEntry {

        private var _pluginElement:MediaElement;
        private var _state:PluginLoadingState;

        public function PluginEntry(_arg1:MediaElement, _arg2:PluginLoadingState){
            this._pluginElement = _arg1;
            this._state = _arg2;
        }
        public function get pluginElement():MediaElement{
            return (this._pluginElement);
        }
        public function get state():PluginLoadingState{
            return (this._state);
        }
        public function set state(_arg1:PluginLoadingState):void{
            this._state = _arg1;
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media.pluginClasses {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.display.*;

    class PluginLoadTrait extends LoadTrait {

        private var _pluginInfo:PluginInfo;
        private var _loader:Loader;

        public function PluginLoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            super(_arg1, _arg2);
        }
        public function get pluginInfo():PluginInfo{
            return (this._pluginInfo);
        }
        public function set pluginInfo(_arg1:PluginInfo):void{
            this._pluginInfo = _arg1;
        }
        public function get loader():Loader{
            return (this._loader);
        }
        public function set loader(_arg1:Loader):void{
            this._loader = _arg1;
        }

    }
}//package org.osmf.media.pluginClasses 
﻿package org.osmf.media {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import __AS3__.vec.*;

    public class LoadableElementBase extends MediaElement {

        private var _loader:LoaderBase;

        public function LoadableElementBase(_arg1:MediaResourceBase=null, _arg2:LoaderBase=null){
            this._loader = _arg2;
            this.resource = _arg1;
        }
        override public function set resource(_arg1:MediaResourceBase):void{
            super.resource = _arg1;
            this.updateLoadTrait();
        }
        final protected function get loader():LoaderBase{
            return (this._loader);
        }
        final protected function set loader(_arg1:LoaderBase):void{
            this._loader = _arg1;
        }
        protected function createLoadTrait(_arg1:MediaResourceBase, _arg2:LoaderBase):LoadTrait{
            return (new LoadTrait(this._loader, _arg1));
        }
        protected function processLoadingState():void{
        }
        protected function processReadyState():void{
        }
        protected function processUnloadingState():void{
        }
        protected function getLoaderForResource(_arg1:MediaResourceBase, _arg2:Vector.<LoaderBase>):LoaderBase{
            var _local4:Boolean;
            var _local5:LoaderBase;
            var _local3:LoaderBase = this.loader;
            if (((!((_arg1 == null))) && ((((this.loader == null)) || ((this.loader.canHandleResource(_arg1) == false)))))){
                _local4 = false;
                for each (_local5 in _arg2) {
                    if ((((this.loader == null)) || (!((this.loader == _local5))))){
                        if (_local5.canHandleResource(_arg1)){
                            _local3 = _local5;
                            break;
                        };
                    };
                };
                if ((((_local3 == null)) && (!((_arg2 == null))))){
                    _local3 = _arg2[(_arg2.length - 1)];
                };
            };
            return (_local3);
        }
        private function onLoadStateChange(_arg1:LoadEvent):void{
            if (_arg1.loadState == LoadState.LOADING){
                this.processLoadingState();
            } else {
                if (_arg1.loadState == LoadState.READY){
                    this.processReadyState();
                } else {
                    if (_arg1.loadState == LoadState.UNLOADING){
                        this.processUnloadingState();
                    };
                };
            };
        }
        private function updateLoadTrait():void{
            var _local1:LoadTrait = (getTrait(MediaTraitType.LOAD) as LoadTrait);
            if (_local1 != null){
                if (_local1.loadState == LoadState.READY){
                    _local1.unload();
                };
                _local1.removeEventListener(LoadEvent.LOAD_STATE_CHANGE, this.onLoadStateChange);
                removeTrait(MediaTraitType.LOAD);
            };
            if (this.loader != null){
                _local1 = this.createLoadTrait(resource, this.loader);
                _local1.addEventListener(LoadEvent.LOAD_STATE_CHANGE, this.onLoadStateChange, false, 10);
                addTrait(MediaTraitType.LOAD, _local1);
            };
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {

    public final class MediaType {

        public static const VIDEO:String = "video";
        public static const AUDIO:String = "audio";
        public static const IMAGE:String = "image";
        public static const SWF:String = "swf";

    }
}//package org.osmf.media 
﻿package org.osmf.media {

    public final class MediaPlayerState {

        public static const UNINITIALIZED:String = "uninitialized";
        public static const LOADING:String = "loading";
        public static const READY:String = "ready";
        public static const PLAYING:String = "playing";
        public static const PAUSED:String = "paused";
        public static const BUFFERING:String = "buffering";
        public static const PLAYBACK_ERROR:String = "playbackError";

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.utils.*;

    public class MediaFactoryItem {

        private var _id:String;
        private var _canHandleResourceFunction:Function;
        private var _mediaElementCreationFunction:Function;
        private var _type:String;

        public function MediaFactoryItem(_arg1:String, _arg2:Function, _arg3:Function, _arg4:String=null){
            if ((((((_arg1 == null)) || ((_arg2 == null)))) || ((_arg3 == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            _arg4 = ((_arg4) || (MediaFactoryItemType.STANDARD));
            this._id = _arg1;
            this._canHandleResourceFunction = _arg2;
            this._mediaElementCreationFunction = _arg3;
            this._type = _arg4;
        }
        public function get id():String{
            return (this._id);
        }
        public function get canHandleResourceFunction():Function{
            return (this._canHandleResourceFunction);
        }
        public function get mediaElementCreationFunction():Function{
            return (this._mediaElementCreationFunction);
        }
        public function get type():String{
            return (this._type);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.net.*;
    import org.osmf.net.rtmpstreaming.*;
    import org.osmf.net.dvr.*;
    import org.osmf.net.httpstreaming.*;
    import org.osmf.elements.*;

    public class DefaultMediaFactory extends MediaFactory {

        private var rtmpStreamingNetLoader:RTMPDynamicStreamingNetLoader;
        private var f4mLoader:F4MLoader;
        private var dvrCastLoader:DVRCastNetLoader;
        private var netLoader:NetLoader;
        private var imageLoader:ImageLoader;
        private var swfLoader:SWFLoader;
        private var soundLoader:SoundLoader;
        private var httpStreamingNetLoader:HTTPStreamingNetLoader;
        private var multicastLoader:MulticastNetLoader;

        public function DefaultMediaFactory(){
            this.init();
        }
        private function init():void{
            this.f4mLoader = new F4MLoader(this);
            addItem(new MediaFactoryItem("org.osmf.elements.f4m", this.f4mLoader.canHandleResource, function ():MediaElement{
                return (new F4MElement(null, f4mLoader));
            }));
            this.dvrCastLoader = new DVRCastNetLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.video.dvr.dvrcast", this.dvrCastLoader.canHandleResource, function ():MediaElement{
                return (new VideoElement(null, dvrCastLoader));
            }));
            this.httpStreamingNetLoader = new HTTPStreamingNetLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.video.httpstreaming", this.httpStreamingNetLoader.canHandleResource, function ():MediaElement{
                return (new VideoElement(null, httpStreamingNetLoader));
            }));
            this.multicastLoader = new MulticastNetLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.video.rtmfp.multicast", this.multicastLoader.canHandleResource, function ():MediaElement{
                return (new VideoElement(null, multicastLoader));
            }));
            this.rtmpStreamingNetLoader = new RTMPDynamicStreamingNetLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.video.rtmpdynamicStreaming", this.rtmpStreamingNetLoader.canHandleResource, function ():MediaElement{
                return (new VideoElement(null, rtmpStreamingNetLoader));
            }));
            this.netLoader = new NetLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.video", this.netLoader.canHandleResource, function ():MediaElement{
                return (new VideoElement(null, netLoader));
            }));
            this.soundLoader = new SoundLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.audio", this.soundLoader.canHandleResource, function ():MediaElement{
                return (new AudioElement(null, soundLoader));
            }));
            addItem(new MediaFactoryItem("org.osmf.elements.audio.streaming", this.netLoader.canHandleResource, function ():MediaElement{
                return (new AudioElement(null, netLoader));
            }));
            this.imageLoader = new ImageLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.image", this.imageLoader.canHandleResource, function ():MediaElement{
                return (new ImageElement(null, imageLoader));
            }));
            this.swfLoader = new SWFLoader();
            addItem(new MediaFactoryItem("org.osmf.elements.swf", this.swfLoader.canHandleResource, function ():MediaElement{
                return (new SWFElement(null, swfLoader));
            }));
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import __AS3__.vec.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.utils.*;

    public class PluginInfo {

        public static const PLUGIN_MEDIAFACTORY_NAMESPACE:String = "http://www.osmf.org/plugin/mediaFactory/1.0";

        private var _mediaFactoryItems:Vector.<MediaFactoryItem>;
        private var _mediaElementCreationNotificationFunction:Function;

        public function PluginInfo(_arg1:Vector.<MediaFactoryItem>=null, _arg2:Function=null){
            this._mediaFactoryItems = ((_arg1)!=null) ? _arg1 : new Vector.<MediaFactoryItem>();
            this._mediaElementCreationNotificationFunction = _arg2;
        }
        public function get numMediaFactoryItems():int{
            return (this._mediaFactoryItems.length);
        }
        public function get frameworkVersion():String{
            return (Version.version);
        }
        public function getMediaFactoryItemAt(_arg1:int):MediaFactoryItem{
            if ((((_arg1 < 0)) || ((_arg1 >= this._mediaFactoryItems.length)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return ((this._mediaFactoryItems[_arg1] as MediaFactoryItem));
        }
        public function isFrameworkVersionSupported(_arg1:String):Boolean{
            if ((((_arg1 == null)) || ((_arg1.length == 0)))){
                return (false);
            };
            var _local2:Object = VersionUtils.parseVersionString(_arg1);
            var _local3:Object = VersionUtils.parseVersionString(this.frameworkVersion);
            return ((((_local2.major > _local3.major)) || ((((_local2.major == _local3.major)) && ((_local2.minor >= _local3.minor))))));
        }
        public function initializePlugin(_arg1:MediaResourceBase):void{
        }
        public function get mediaElementCreationNotificationFunction():Function{
            return (this._mediaElementCreationNotificationFunction);
        }
        final protected function get mediaFactoryItems():Vector.<MediaFactoryItem>{
            return (this._mediaFactoryItems);
        }
        final protected function set mediaFactoryItems(_arg1:Vector.<MediaFactoryItem>):void{
            this._mediaFactoryItems = _arg1;
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {

    public class PluginInfoResource extends MediaResourceBase {

        private var _pluginInfo:PluginInfo;

        public function PluginInfoResource(_arg1:PluginInfo){
            this._pluginInfo = _arg1;
        }
        public function get pluginInfo():PluginInfo{
            return (this._pluginInfo);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.utils.*;

    class MediaTraitResolver extends EventDispatcher {

        private var _type:String;
        private var _resolvedTrait:MediaTraitBase;

        public function MediaTraitResolver(_arg1:String){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this._type = _arg1;
        }
        final public function get type():String{
            return (this._type);
        }
        final protected function setResolvedTrait(_arg1:MediaTraitBase):void{
            if (_arg1 != this._resolvedTrait){
                if (this._resolvedTrait){
                    this._resolvedTrait = null;
                    dispatchEvent(new Event(Event.CHANGE));
                };
                this._resolvedTrait = _arg1;
                dispatchEvent(new Event(Event.CHANGE));
            };
        }
        final public function get resolvedTrait():MediaTraitBase{
            return (this._resolvedTrait);
        }
        final public function addTrait(_arg1:MediaTraitBase):void{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (_arg1.traitType != this.type){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this.processAddTrait(_arg1);
        }
        final public function removeTrait(_arg1:MediaTraitBase):MediaTraitBase{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (_arg1.traitType != this.type){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return (this.processRemoveTrait(_arg1));
        }
        protected function processAddTrait(_arg1:MediaTraitBase):void{
        }
        protected function processRemoveTrait(_arg1:MediaTraitBase):MediaTraitBase{
            return (null);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.traits.*;
    import org.osmf.utils.*;

    public class DefaultTraitResolver extends MediaTraitResolver {

        private var defaultTrait:MediaTraitBase;
        private var trait:MediaTraitBase;

        public function DefaultTraitResolver(_arg1:String, _arg2:MediaTraitBase){
            super(_arg1);
            if (_arg2 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            if (_arg2.traitType != _arg1){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this.defaultTrait = _arg2;
            setResolvedTrait(_arg2);
        }
        override protected function processAddTrait(_arg1:MediaTraitBase):void{
            if (this.trait == null){
                setResolvedTrait((this.trait = _arg1));
            };
        }
        override protected function processRemoveTrait(_arg1:MediaTraitBase):MediaTraitBase{
            var _local2:MediaTraitBase;
            if (((_arg1) && ((_arg1 == this.trait)))){
                _local2 = this.trait;
                this.trait = null;
                setResolvedTrait(this.defaultTrait);
            };
            return (_local2);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media.videoClasses {

    public final class VideoSurfaceInfo {

        public static const UNAVAILABLE:String = "unavailable";
        public static const SOFTWARE:String = "software";
        public static const ACCELERATED:String = "accelerated";

        protected var _stageVideoInUse:Boolean;
        protected var _renderStatus:String;
        protected var _stageVideoInUseCount:int;
        protected var _stageVideoCount:int;

        public function VideoSurfaceInfo(_arg1:Boolean, _arg2:String, _arg3:int, _arg4:int){
            this._stageVideoInUse = _arg1;
            this._renderStatus = _arg2;
            this._stageVideoInUseCount = _arg3;
            this._stageVideoCount = _arg4;
        }
        public function get stageVideoInUse():Boolean{
            return (this._stageVideoInUse);
        }
        public function get renderStatus():String{
            return (this._renderStatus);
        }
        public function get stageVideoInUseCount():int{
            return (this._stageVideoInUseCount);
        }
        public function get stageVideoCount():int{
            return (this._stageVideoCount);
        }

    }
}//package org.osmf.media.videoClasses 
﻿package org.osmf.media.videoClasses {
    import org.osmf.events.*;
    import flash.events.*;
    import flash.display.*;
    import flash.net.*;
    import flash.media.*;
    import flash.geom.*;

    public class VideoSurface extends Sprite {

        static var videoSurfaceManager:VideoSurfaceManager = null;
        static var stageVideoInUseCount:int = 0;
        static var stageVideoCount:int = 0;

        var createVideo:Function;
        var stageVideo = null;
        var video:Video = null;
        private var currentVideoRenderer = null;
        private var netStream:NetStream;
        private var surfaceRect:Rectangle;
        private var invalidSurfaceRect:Boolean = false;
        private var surfaceShape:Shape = null;
        private var _deblocking:int = 0;
        private var _smoothing:Boolean = false;
        private var _visible:Boolean = true;
        private var renderStatus:String;

        public function VideoSurface(_arg1:Boolean=true, _arg2:Function=null){
            var useStageVideo:Boolean = _arg1;
            var createVideo = _arg2;
            this.surfaceRect = new Rectangle(0, 0, 0, 0);
            super();
            this.doubleClickEnabled = true;
            if (createVideo != null){
                this.createVideo = createVideo;
            } else {
                this.createVideo = function ():Video{
                    return (new Video());
                };
            };
            if (useStageVideo){
                this.register();
            } else {
                this.switchRenderer(this.createVideo());
            };
        }
        private static function updateRect(_arg1:Rectangle):Rectangle{
            var _local2:Rectangle = _arg1;
            if (isNaN(_local2.x)){
                _local2.x = 0;
            };
            if (isNaN(_local2.y)){
                _local2.y = 0;
            };
            if (isNaN(_local2.width)){
                _local2.width = 0;
            };
            if (isNaN(_local2.height)){
                _local2.height = 0;
            };
            return (_local2);
        }

        public function get info():VideoSurfaceInfo{
            return (new VideoSurfaceInfo(!((this.stageVideo == null)), this.renderStatus, stageVideoInUseCount, stageVideoCount));
        }
        public function attachNetStream(_arg1:NetStream):void{
            this.netStream = _arg1;
            if (this.currentVideoRenderer){
                this.currentVideoRenderer.attachNetStream(_arg1);
            };
        }
        public function clear(_arg1:Boolean=false):void{
            if (this.currentVideoRenderer){
                if (this.currentVideoRenderer == this.video){
                    this.video.clear();
                } else {
                    if (_arg1){
                        this.stageVideo.depth = 0;
                        this.stageVideo.viewPort = new Rectangle(0, 0, 0, 0);
                    };
                };
            };
        }
        public function get deblocking():int{
            return (this._deblocking);
        }
        public function set deblocking(_arg1:int):void{
            if (this._deblocking != _arg1){
                this._deblocking = _arg1;
                if ((this.currentVideoRenderer is Video)){
                    this.currentVideoRenderer.deblocking = this._deblocking;
                };
            };
        }
        public function get smoothing():Boolean{
            return (this._smoothing);
        }
        public function set smoothing(_arg1:Boolean):void{
            if (this._smoothing != _arg1){
                this._smoothing = _arg1;
                if ((this.currentVideoRenderer is Video)){
                    this.currentVideoRenderer.smoothing = this._smoothing;
                };
            };
        }
        override public function set visible(_arg1:Boolean):void{
            this._visible = _arg1;
            if (videoSurfaceManager){
                if (this._visible){
                    videoSurfaceManager.provideRenderer(this);
                } else {
                    videoSurfaceManager.releaseRenderer(this);
                };
            };
        }
        override public function get visible():Boolean{
            return (this._visible);
        }
        public function get videoHeight():int{
            return (((this.currentVideoRenderer) ? this.currentVideoRenderer.videoHeight : this.surfaceRect.height));
        }
        public function get videoWidth():int{
            return (((this.currentVideoRenderer) ? this.currentVideoRenderer.videoWidth : this.surfaceRect.width));
        }
        override public function set x(_arg1:Number):void{
            super.x = _arg1;
            this.surfaceRect.x = 0;
            this.updateView();
        }
        override public function set y(_arg1:Number):void{
            super.y = _arg1;
            this.surfaceRect.y = 0;
            this.updateView();
        }
        override public function get height():Number{
            return (this.surfaceRect.height);
        }
        override public function set height(_arg1:Number):void{
            if (this.surfaceRect.height != _arg1){
                this.surfaceRect.height = _arg1;
                this.updateView();
            };
        }
        override public function get width():Number{
            return (this.surfaceRect.width);
        }
        override public function set width(_arg1:Number):void{
            if (this.surfaceRect.width != _arg1){
                this.surfaceRect.width = _arg1;
                this.updateView();
            };
        }
        function updateView():void{
            var _local2:Rectangle;
            if (this.currentVideoRenderer == null){
                return;
            };
            var _local1:Rectangle = updateRect(this.surfaceRect);
            if (this.currentVideoRenderer == this.stageVideo){
                _local2 = new Rectangle();
                _local2.topLeft = localToGlobal(_local1.topLeft);
                _local2.bottomRight = localToGlobal(_local1.bottomRight);
                this.stageVideo.viewPort = _local2;
                if (this.surfaceShape == null){
                    this.surfaceShape = new Shape();
                };
                this.surfaceShape.graphics.clear();
                this.surfaceShape.graphics.drawRect(0, 0, _local1.width, _local1.height);
                this.surfaceShape.alpha = 0;
                addChild(this.surfaceShape);
            } else {
                this.currentVideoRenderer.x = _local1.x;
                this.currentVideoRenderer.y = _local1.y;
                this.currentVideoRenderer.height = _local1.height;
                this.currentVideoRenderer.width = _local1.width;
            };
        }
        function switchRenderer(_arg1):void{
            if (this.currentVideoRenderer == _arg1){
                return;
            };
            if (this.currentVideoRenderer){
                this.currentVideoRenderer.attachNetStream(null);
                if (this.currentVideoRenderer == this.video){
                    this.video = null;
                    removeChild(this.currentVideoRenderer);
                } else {
                    if (this.stageVideo != null){
                        this.stageVideo.viewPort = new Rectangle(0, 0, 0, 0);
                    };
                    this.stageVideo = null;
                    if (this.surfaceShape != null){
                        this.surfaceShape.graphics.clear();
                        removeChild(this.surfaceShape);
                        this.surfaceShape = null;
                    };
                };
            };
            this.currentVideoRenderer = _arg1;
            if (this.currentVideoRenderer){
                this.currentVideoRenderer.attachNetStream(this.netStream);
                if ((this.currentVideoRenderer is DisplayObject)){
                    this.video = this.currentVideoRenderer;
                    this.video.deblocking = this._deblocking;
                    this.video.smoothing = this._smoothing;
                    addChild(this.currentVideoRenderer);
                } else {
                    this.stageVideo = this.currentVideoRenderer;
                };
                this.updateView();
                this.currentVideoRenderer.addEventListener("renderState", this.onRenderState);
            };
            if ((((this.currentVideoRenderer == null)) || ((this.currentVideoRenderer is DisplayObject)))){
                dispatchEvent(new VideoSurfaceEvent(VideoSurfaceEvent.RENDER_CHANGE, true, false, false));
            } else {
                dispatchEvent(new VideoSurfaceEvent(VideoSurfaceEvent.RENDER_CHANGE, true, false, true));
            };
        }
        private function onRenderState(_arg1:Event):void{
            if (_arg1.hasOwnProperty("status")){
                this.renderStatus = _arg1["status"];
            };
        }
        private function register():void{
            if (videoSurfaceManager == null){
                videoSurfaceManager = new VideoSurfaceManager();
            };
            videoSurfaceManager.registerVideoSurface(this);
        }

    }
}//package org.osmf.media.videoClasses 
﻿package org.osmf.media.videoClasses {
    import flash.events.*;
    import flash.display.*;
    import flash.media.*;
    import flash.utils.*;
    import org.osmf.media.videoClasses.*;

    class VideoSurfaceManager {

        private static const AVAILABILITY:String = "availability";
        private static const AVAILABLE:String = "available";
        private static const UNAVAILABLE:String = "unavailable";

        var activeVideoSurfaces:Dictionary;
        private var _stage:Stage = null;
        private var stageVideoIsAvailable:Boolean = false;

        public function VideoSurfaceManager(){
            this.activeVideoSurfaces = new Dictionary(true);
            super();
        }
        public function registerVideoSurface(_arg1:VideoSurface):void{
            _arg1.addEventListener(Event.ADDED_TO_STAGE, this.onAddedToStage);
            _arg1.addEventListener(Event.REMOVED_FROM_STAGE, this.onRemovedFromStage);
        }
        public function get stageVideoInUseCount():int{
            var _local2:*;
            var _local1:int;
            for each (_local2 in this.activeVideoSurfaces) {
                if (((_local2) && ((_local2 is StageVideo)))){
                    _local1++;
                };
            };
            return (_local1);
        }
        public function get stageVideoCount():int{
            return (((this._stage) ? this._stage.stageVideos.length : 0));
        }
        function registerStage(_arg1:Stage):void{
            this._stage = _arg1;
            this._stage.addEventListener("stageVideoAvailability", this.onStageVideoAvailability);
            this.stageVideoIsAvailable = ((this._stage.hasOwnProperty("stageVideos")) && ((this._stage.stageVideos.length > 0)));
        }
        function provideRenderer(_arg1:VideoSurface):void{
            if (_arg1 == null){
                return;
            };
            this.switchRenderer(_arg1);
        }
        function releaseRenderer(_arg1:VideoSurface):void{
            _arg1.clear(true);
            this.activeVideoSurfaces[_arg1] = null;
            _arg1.switchRenderer(null);
        }
        private function onStageVideoAvailability(_arg1:Event):void{
            var _local2:Boolean;
            var _local3:*;
            var _local4:VideoSurface;
            if (!_arg1.hasOwnProperty(AVAILABILITY)){
                return;
            };
            _local2 = (_arg1[AVAILABILITY] == AVAILABLE);
            if (this.stageVideoIsAvailable != _local2){
                this.stageVideoIsAvailable = _local2;
                for (_local3 in this.activeVideoSurfaces) {
                    _local4 = (_local3 as VideoSurface);
                    if (((!((_local4 == null))) && (!((_local4.info.stageVideoInUse == this.stageVideoIsAvailable))))){
                        this.switchRenderer(_local4);
                    };
                };
            };
        }
        private function onAddedToStage(_arg1:Event):void{
            if (this._stage == null){
                this.registerStage(_arg1.target.stage);
            };
            this.provideRenderer((_arg1.target as VideoSurface));
        }
        private function onRemovedFromStage(_arg1:Event):void{
            this.releaseRenderer((_arg1.target as VideoSurface));
        }
        private function onStageVideoRenderState(_arg1:Event):void{
            var _local2:*;
            var _local3:VideoSurface;
            if (_arg1["status"] == UNAVAILABLE){
                for (_local2 in this.activeVideoSurfaces) {
                    _local3 = (_local2 as VideoSurface);
                    if (_arg1.target == _local3.stageVideo){
                        _local3.stageVideo = null;
                        this.switchRenderer(_local3);
                        break;
                    };
                };
            };
        }
        private function switchRenderer(_arg1:VideoSurface):void{
            var _local2:*;
            var _local3:StageVideo;
            var _local4:int;
            var _local5:*;
            var _local6:int;
            var _local7:int;
            if (!this.stageVideoIsAvailable){
                if (_arg1.video == null){
                    _arg1.video = _arg1.createVideo();
                };
                _local2 = _arg1.video;
            } else {
                _local3 = null;
                _local4 = 0;
                while (_local4 < this._stage.stageVideos.length) {
                    _local3 = this._stage.stageVideos[_local4];
                    for (_local5 in this.activeVideoSurfaces) {
                        if (_local3 == this.activeVideoSurfaces[_local5]){
                            _local3 = null;
                        };
                    };
                    if (_local3 != null){
                        break;
                    };
                    _local4++;
                };
                if (_local3 != null){
                    _local6 = 0;
                    _local7 = 0;
                    while (_local7 < this._stage.stageVideos.length) {
                        if (_local6 < this._stage.stageVideos[_local7].depth){
                            _local6 = this._stage.stageVideos[_local7].depth;
                        };
                        _local7++;
                    };
                    this.activeVideoSurfaces[_arg1] = _local3;
                    _arg1.stageVideo = _local3;
                    _local2 = _local3;
                    _local3.depth = (_local6 + 1);
                    _local2.addEventListener("renderState", this.onStageVideoRenderState);
                } else {
                    if (_arg1.video == null){
                        _arg1.video = _arg1.createVideo();
                    };
                    _local2 = _arg1.video;
                };
            };
            this.activeVideoSurfaces[_arg1] = _local2;
            _arg1.switchRenderer(_local2);
            VideoSurface.stageVideoCount = this.stageVideoCount;
            VideoSurface.stageVideoInUseCount = this.stageVideoInUseCount;
        }

    }
}//package org.osmf.media.videoClasses 
﻿package org.osmf.media {

    public class MediaFactoryItemType {

        public static const STANDARD:String = "standard";
        public static const PROXY:String = "proxy";
        static const ALL_TYPES:Array = [STANDARD, PROXY];

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.containers.*;
    import org.osmf.metadata.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class MediaElement extends EventDispatcher {

        private var traits:Dictionary;
        private var traitResolvers:Dictionary;
        private var unresolvedTraits:Dictionary;
        private var _traitTypes:Vector.<String>;
        private var _resource:MediaResourceBase;
        private var _metadata:Metadata;
        private var _container:IMediaContainer;

        public function MediaElement(){
            this.traits = new Dictionary();
            this.traitResolvers = new Dictionary();
            this.unresolvedTraits = new Dictionary();
            this._traitTypes = new Vector.<String>();
            super();
            this._metadata = this.createMetadata();
            this._metadata.addEventListener(MetadataEvent.VALUE_ADD, this.onMetadataValueAdd);
            this._metadata.addEventListener(MetadataEvent.VALUE_REMOVE, this.onMetadataValueRemove);
            this._metadata.addEventListener(MetadataEvent.VALUE_CHANGE, this.onMetadataValueChange);
            this.setupTraitResolvers();
            this.setupTraits();
            addEventListener(ContainerChangeEvent.CONTAINER_CHANGE, this.onContainerChange, false, Number.MAX_VALUE);
        }
        public function get traitTypes():Vector.<String>{
            return (this._traitTypes.concat());
        }
        public function hasTrait(_arg1:String):Boolean{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return (!((this.traits[_arg1] == null)));
        }
        public function getTrait(_arg1:String):MediaTraitBase{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            return (this.traits[_arg1]);
        }
        public function get resource():MediaResourceBase{
            return (this._resource);
        }
        public function set resource(_arg1:MediaResourceBase):void{
            this._resource = _arg1;
        }
        public function get container():IMediaContainer{
            return (this._container);
        }
        public function addMetadata(_arg1:String, _arg2:Metadata):void{
            if ((((_arg1 == null)) || ((_arg2 == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.metadata.addValue(_arg1, _arg2);
        }
        public function removeMetadata(_arg1:String):Metadata{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            return ((this.metadata.removeValue(_arg1) as Metadata));
        }
        public function getMetadata(_arg1:String):Metadata{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            return ((this.metadata.getValue(_arg1) as Metadata));
        }
        public function get metadataNamespaceURLs():Vector.<String>{
            return (this.metadata.keys);
        }
        protected function createMetadata():Metadata{
            return (new Metadata());
        }
        public function get metadata():Metadata{
            return (this._metadata);
        }
        protected function addTrait(_arg1:String, _arg2:MediaTraitBase):void{
            if ((((((_arg1 == null)) || ((_arg2 == null)))) || (!((_arg1 == _arg2.traitType))))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local3:MediaTraitResolver = this.traitResolvers[_arg1];
            if (_local3 != null){
                _local3.addTrait(_arg2);
            } else {
                this.setLocalTrait(_arg1, _arg2);
            };
        }
        protected function removeTrait(_arg1:String):MediaTraitBase{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local2:MediaTraitBase = this.traits[_arg1];
            var _local3:MediaTraitResolver = this.traitResolvers[_arg1];
            if (_local3 != null){
                return (_local3.removeTrait(_local2));
            };
            return (this.setLocalTrait(_arg1, null));
        }
        final protected function addTraitResolver(_arg1:String, _arg2:MediaTraitResolver):void{
            var _local3:MediaTraitBase;
            if ((((_arg2 == null)) || (!((_arg2.type == _arg1))))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (this.traitResolvers[_arg1] == null){
                this.unresolvedTraits[_arg1] = this.traits[_arg1];
                this.traitResolvers[_arg1] = _arg2;
                _local3 = this.traits[_arg1];
                if (_local3){
                    _arg2.addTrait(_local3);
                };
                this.processResolvedTraitChange(_arg1, _arg2.resolvedTrait);
                _arg2.addEventListener(Event.CHANGE, this.onTraitResolverChange);
            } else {
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.TRAIT_RESOLVER_ALREADY_ADDED)));
            };
        }
        final protected function removeTraitResolver(_arg1:String):MediaTraitResolver{
            if ((((_arg1 == null)) || ((this.traitResolvers[_arg1] == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local2:MediaTraitResolver = this.traitResolvers[_arg1];
            _local2.removeEventListener(Event.CHANGE, this.onTraitResolverChange);
            delete this.traitResolvers[_arg1];
            var _local3:MediaTraitBase = this.unresolvedTraits[_arg1];
            if (_local3 != this.traits[_arg1]){
                this.setLocalTrait(_arg1, _local3);
            };
            delete this.unresolvedTraits[_arg1];
            return (_local2);
        }
        final protected function getTraitResolver(_arg1:String):MediaTraitResolver{
            return (this.traitResolvers[_arg1]);
        }
        protected function setupTraitResolvers():void{
        }
        protected function setupTraits():void{
        }
        private function onMediaError(_arg1:MediaErrorEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function setLocalTrait(_arg1:String, _arg2:MediaTraitBase):MediaTraitBase{
            var _local3:MediaTraitBase = this.traits[_arg1];
            if (_arg2 == null){
                if (_local3 != null){
                    _local3.removeEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                    _local3.dispose();
                    dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_REMOVE, false, false, _arg1));
                    this._traitTypes.splice(this._traitTypes.indexOf(_arg1), 1);
                    delete this.traits[_arg1];
                };
            } else {
                if (_local3 == null){
                    _local3 = _arg2;
                    this.traits[_arg1] = _local3;
                    this._traitTypes.push(_arg1);
                    _local3.addEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaError);
                    dispatchEvent(new MediaElementEvent(MediaElementEvent.TRAIT_ADD, false, false, _arg1));
                } else {
                    if (_local3 != _arg2){
                        throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.TRAIT_INSTANCE_ALREADY_ADDED)));
                    };
                };
            };
            return (_local3);
        }
        private function onTraitResolverChange(_arg1:Event):void{
            var _local2:MediaTraitResolver = (_arg1.target as MediaTraitResolver);
            this.processResolvedTraitChange(_local2.type, _local2.resolvedTrait);
        }
        private function processResolvedTraitChange(_arg1:String, _arg2:MediaTraitBase):void{
            if (_arg2 != this.traits[_arg1]){
                this.setLocalTrait(_arg1, _arg2);
            };
        }
        private function onContainerChange(_arg1:ContainerChangeEvent):void{
            if ((((this._container == _arg1.oldContainer)) && (!((this._container == _arg1.newContainer))))){
                this._container = _arg1.newContainer;
            };
        }
        private function onMetadataValueAdd(_arg1:MetadataEvent):void{
            dispatchEvent(new MediaElementEvent(MediaElementEvent.METADATA_ADD, false, false, null, _arg1.key, (_arg1.value as Metadata)));
        }
        private function onMetadataValueChange(_arg1:MetadataEvent):void{
            dispatchEvent(new MediaElementEvent(MediaElementEvent.METADATA_REMOVE, false, false, null, _arg1.key, (_arg1.oldValue as Metadata)));
            dispatchEvent(new MediaElementEvent(MediaElementEvent.METADATA_ADD, false, false, null, _arg1.key, (_arg1.value as Metadata)));
        }
        private function onMetadataValueRemove(_arg1:MetadataEvent):void{
            dispatchEvent(new MediaElementEvent(MediaElementEvent.METADATA_REMOVE, false, false, null, _arg1.key, (_arg1.value as Metadata)));
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import __AS3__.vec.*;

    public class MediaTypeUtil {

        public static const METADATA_MATCH_FOUND:int = 0;
        public static const METADATA_CONFLICTS_FOUND:int = 1;
        public static const METADATA_MATCH_UNKNOWN:int = 2;

        public static function checkMetadataMatchWithResource(_arg1:MediaResourceBase, _arg2:Vector.<String>, _arg3:Vector.<String>):int{
            var _local4:String = ((_arg1) ? _arg1.mediaType : null);
            var _local5:String = ((_arg1) ? _arg1.mimeType : null);
            return (checkMetadataMatch(_local4, _local5, _arg2, _arg3));
        }
        public static function checkMetadataMatch(_arg1:String, _arg2:String, _arg3:Vector.<String>, _arg4:Vector.<String>):int{
            if (_arg1 != null){
                if (_arg2 != null){
                    return (((((matchType(_arg1, _arg3)) && (matchType(_arg2, _arg4)))) ? METADATA_MATCH_FOUND : METADATA_CONFLICTS_FOUND));
                };
                return (((matchType(_arg1, _arg3)) ? METADATA_MATCH_FOUND : METADATA_CONFLICTS_FOUND));
            };
            if (_arg2 != null){
                return (((matchType(_arg2, _arg4)) ? METADATA_MATCH_FOUND : METADATA_CONFLICTS_FOUND));
            };
            return (METADATA_MATCH_UNKNOWN);
        }
        private static function matchType(_arg1:String, _arg2:Vector.<String>):Boolean{
            var _local3:int;
            while (_local3 < _arg2.length) {
                if (_arg1 == _arg2[_local3]){
                    return (true);
                };
                _local3++;
            };
            return (false);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import org.osmf.events.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.utils.*;
    import org.osmf.elements.*;
    import org.osmf.media.pluginClasses.*;
    import org.osmf.utils.*;

    public class MediaFactory extends EventDispatcher {

        private var pluginManager:PluginManager;
        private var allItems:Dictionary;

        public function MediaFactory(){
            this.allItems = new Dictionary();
        }
        private static function getItemsByResource(_arg1:MediaResourceBase, _arg2:Vector.<MediaFactoryItem>):Vector.<MediaFactoryItem>{
            var _local4:MediaFactoryItem;
            var _local3:Vector.<MediaFactoryItem> = new Vector.<MediaFactoryItem>();
            for each (_local4 in _arg2) {
                if (_local4.canHandleResourceFunction(_arg1)){
                    _local3.push(_local4);
                };
            };
            return (_local3);
        }
        private static function getIndexOfItem(_arg1:String, _arg2:Vector.<MediaFactoryItem>):int{
            var _local4:MediaFactoryItem;
            var _local3:int;
            while (_local3 < _arg2.length) {
                _local4 = (_arg2[_local3] as MediaFactoryItem);
                if (_local4.id == _arg1){
                    return (_local3);
                };
                _local3++;
            };
            return (-1);
        }

        public function addItem(_arg1:MediaFactoryItem):void{
            if ((((_arg1 == null)) || ((_arg1.id == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local2:Vector.<MediaFactoryItem> = this.findOrCreateItems(_arg1.type);
            var _local3:int = getIndexOfItem(_arg1.id, _local2);
            if (_local3 != -1){
                _local2[_local3] = _arg1;
            } else {
                _local2.push(_arg1);
            };
        }
        public function removeItem(_arg1:MediaFactoryItem):void{
            var _local3:int;
            if ((((_arg1 == null)) || ((_arg1.id == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            var _local2:Vector.<MediaFactoryItem> = this.allItems[_arg1.type];
            if (_local2 != null){
                _local3 = _local2.indexOf(_arg1);
                if (_local3 != -1){
                    _local2.splice(_local3, 1);
                };
            };
        }
        public function get numItems():int{
            var _local2:String;
            var _local3:Vector.<MediaFactoryItem>;
            var _local1:int;
            for each (_local2 in MediaFactoryItemType.ALL_TYPES) {
                _local3 = this.allItems[_local2];
                if (_local3 != null){
                    _local1 = (_local1 + _local3.length);
                };
            };
            return (_local1);
        }
        public function getItemAt(_arg1:int):MediaFactoryItem{
            var _local3:String;
            var _local4:Vector.<MediaFactoryItem>;
            var _local2:MediaFactoryItem;
            if (_arg1 >= 0){
                for each (_local3 in MediaFactoryItemType.ALL_TYPES) {
                    _local4 = this.allItems[_local3];
                    if (_local4 != null){
                        if (_arg1 < _local4.length){
                            _local2 = _local4[_arg1];
                            break;
                        };
                        _arg1 = (_arg1 - _local4.length);
                    };
                };
            };
            return (_local2);
        }
        public function getItemById(_arg1:String):MediaFactoryItem{
            var _local3:String;
            var _local4:Vector.<MediaFactoryItem>;
            var _local5:int;
            var _local2:MediaFactoryItem;
            for each (_local3 in MediaFactoryItemType.ALL_TYPES) {
                _local4 = this.allItems[_local3];
                if (_local4 != null){
                    _local5 = getIndexOfItem(_arg1, _local4);
                    if (_local5 != -1){
                        _local2 = _local4[_local5];
                        break;
                    };
                };
            };
            return (_local2);
        }
        public function loadPlugin(_arg1:MediaResourceBase):void{
            this.createPluginManager();
            this.pluginManager.loadPlugin(_arg1);
        }
        public function createMediaElement(_arg1:MediaResourceBase):MediaElement{
            var _local3:MediaElement;
            this.createPluginManager();
            var _local2:MediaElement = this.createMediaElementByResource(_arg1, MediaFactoryItemType.STANDARD);
            if (_local2 != null){
                _local3 = this.createMediaElementByResource(_local2.resource, MediaFactoryItemType.PROXY, _local2);
                _local2 = ((_local3)!=null) ? _local3 : _local2;
                dispatchEvent(new MediaFactoryEvent(MediaFactoryEvent.MEDIA_ELEMENT_CREATE, false, false, null, _local2));
            };
            return (_local2);
        }
        protected function resolveItems(_arg1:MediaResourceBase, _arg2:Vector.<MediaFactoryItem>):MediaFactoryItem{
            var _local5:MediaFactoryItem;
            if ((((_arg1 == null)) || ((_arg2 == null)))){
                return (null);
            };
            var _local3:MediaFactoryItem;
            var _local4:int;
            while (_local4 < _arg2.length) {
                _local5 = (_arg2[_local4] as MediaFactoryItem);
                if (_local5.id.indexOf("org.osmf") == -1){
                    return (_local5);
                };
                if (_local3 == null){
                    _local3 = _local5;
                };
                _local4++;
            };
            return (_local3);
        }
        private function findOrCreateItems(_arg1:String):Vector.<MediaFactoryItem>{
            if (this.allItems[_arg1] == null){
                this.allItems[_arg1] = new Vector.<MediaFactoryItem>();
            };
            return ((this.allItems[_arg1] as Vector.<MediaFactoryItem>));
        }
        private function createMediaElementByResource(_arg1:MediaResourceBase, _arg2:String, _arg3:MediaElement=null):MediaElement{
            var _local6:MediaFactoryItem;
            var _local7:MediaElement;
            var _local8:int;
            var _local9:MediaFactoryItem;
            var _local10:ProxyElement;
            var _local4:MediaElement;
            var _local5:Vector.<MediaFactoryItem> = getItemsByResource(_arg1, this.allItems[_arg2]);
            if (_arg2 == MediaFactoryItemType.STANDARD){
                _local6 = (this.resolveItems(_arg1, _local5) as MediaFactoryItem);
                if (_local6 != null){
                    _local4 = this.invokeMediaElementCreationFunction(_local6);
                };
            } else {
                if (_arg2 == MediaFactoryItemType.PROXY){
                    _local7 = _arg3;
                    _local8 = _local5.length;
                    while (_local8 > 0) {
                        _local9 = (_local5[(_local8 - 1)] as MediaFactoryItem);
                        _local10 = (this.invokeMediaElementCreationFunction(_local9) as ProxyElement);
                        if (_local10 != null){
                            _local10.proxiedElement = _local7;
                            _local7 = _local10;
                        };
                        _local8--;
                    };
                    _local4 = _local7;
                };
            };
            if (_local4 != null){
                _local4.resource = _arg1;
            };
            return (_local4);
        }
        private function onPluginLoad(_arg1:PluginManagerEvent):void{
            dispatchEvent(new MediaFactoryEvent(MediaFactoryEvent.PLUGIN_LOAD, false, false, _arg1.resource));
        }
        private function onPluginLoadError(_arg1:PluginManagerEvent):void{
            dispatchEvent(new MediaFactoryEvent(MediaFactoryEvent.PLUGIN_LOAD_ERROR, false, false, _arg1.resource));
        }
        private function invokeMediaElementCreationFunction(_arg1:MediaFactoryItem):MediaElement{
            var _local2:MediaElement;
            try {
                _local2 = _arg1.mediaElementCreationFunction();
            } catch(error:Error) {
            };
            return (_local2);
        }
        private function createPluginManager():void{
            if (this.pluginManager == null){
                this.pluginManager = new PluginManager(this);
                this.pluginManager.addEventListener(PluginManagerEvent.PLUGIN_LOAD, this.onPluginLoad);
                this.pluginManager.addEventListener(PluginManagerEvent.PLUGIN_LOAD_ERROR, this.onPluginLoadError);
            };
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {
    import __AS3__.vec.*;
    import flash.utils.*;

    public class MediaResourceBase {

        private var _metadata:Dictionary;
        private var _mediaType:String;
        private var _mimeType:String;

        public function get mediaType():String{
            return (this._mediaType);
        }
        public function set mediaType(_arg1:String):void{
            this._mediaType = _arg1;
        }
        public function get mimeType():String{
            return (this._mimeType);
        }
        public function set mimeType(_arg1:String):void{
            this._mimeType = _arg1;
        }
        public function get metadataNamespaceURLs():Vector.<String>{
            var _local2:String;
            var _local1:Vector.<String> = new Vector.<String>();
            if (this._metadata != null){
                for (_local2 in this._metadata) {
                    _local1.push(_local2);
                };
            };
            return (_local1);
        }
        public function addMetadataValue(_arg1:String, _arg2:Object):void{
            if (this._metadata == null){
                this._metadata = new Dictionary();
            };
            this._metadata[_arg1] = _arg2;
        }
        public function getMetadataValue(_arg1:String):Object{
            if (this._metadata != null){
                return (this._metadata[_arg1]);
            };
            return (null);
        }
        public function removeMetadataValue(_arg1:String):Object{
            var _local2:Object;
            if (this._metadata != null){
                _local2 = this._metadata[_arg1];
                delete this._metadata[_arg1];
                return (_local2);
            };
            return (null);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.media {

    public class URLResource extends MediaResourceBase {

        private var _url:String;

        public function URLResource(_arg1:String){
            this._url = _arg1;
        }
        public function get url():String{
            return (this._url);
        }

    }
}//package org.osmf.media 
﻿package org.osmf.containers {
    import org.osmf.media.*;

    public interface IMediaContainer {

        function addMediaElement(_arg1:MediaElement):MediaElement;
        function removeMediaElement(_arg1:MediaElement):MediaElement;
        function containsMediaElement(_arg1:MediaElement):Boolean;

    }
}//package org.osmf.containers 
﻿package org.osmf.events {
    import flash.events.*;

    public class MediaElementChangeEvent extends Event {

        public static const MEDIA_ELEMENT_CHANGE:String = "mediaElementChange";

        public function MediaElementChangeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false){
            super(_arg1, _arg2, _arg3);
        }
        override public function clone():Event{
            return (new MediaElementChangeEvent(type, bubbles, cancelable));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class VideoSurfaceEvent extends Event {

        public static const RENDER_CHANGE:String = "renderSwitch";

        private var _usesStageVideo:Boolean;

        public function VideoSurfaceEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this._usesStageVideo = _arg4;
        }
        public function get usesStageVideo():Boolean{
            return (this._usesStageVideo);
        }
        override public function clone():Event{
            return (new VideoSurfaceEvent(type, bubbles, cancelable, this._usesStageVideo));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.metadata.*;

    public class TimelineMetadataEvent extends MetadataEvent {

        public static const MARKER_TIME_REACHED:String = "markerTimeReached";
        public static const MARKER_DURATION_REACHED:String = "markerDurationReached";
        public static const MARKER_ADD:String = "markerAdd";
        public static const MARKER_REMOVE:String = "markerRemove";

        private var _marker:TimelineMarker;

        public function TimelineMetadataEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:TimelineMarker=null){
            super(_arg1, _arg2, _arg3, ("" + _arg4.time), _arg4);
            this._marker = _arg4;
        }
        public function get marker():TimelineMarker{
            return (this._marker);
        }
        override public function clone():Event{
            return (new TimelineMetadataEvent(type, bubbles, cancelable, this._marker));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class DVRStreamInfoEvent extends Event {

        public static const DVRSTREAMINFO:String = "DVRStreamInfo";

        private var _info:Object;

        public function DVRStreamInfoEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Object=null){
            super(_arg1, _arg2, _arg3);
            this._info = _arg4;
        }
        override public function clone():Event{
            return (new DVRStreamInfoEvent(type, bubbles, cancelable, this.info));
        }
        public function get info():Object{
            return (this._info);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.utils.*;

    public final class MediaErrorCodes {

        public static const IO_ERROR:int = 1;
        public static const SECURITY_ERROR:int = 2;
        public static const ASYNC_ERROR:int = 3;
        public static const ARGUMENT_ERROR:int = 4;
        public static const URL_SCHEME_INVALID:int = 5;
        public static const HTTP_GET_FAILED:int = 6;
        public static const MEDIA_LOAD_FAILED:int = 7;
        public static const PLUGIN_VERSION_INVALID:int = 8;
        public static const PLUGIN_IMPLEMENTATION_INVALID:int = 9;
        public static const SOUND_PLAY_FAILED:int = 10;
        public static const NETCONNECTION_REJECTED:int = 11;
        public static const NETCONNECTION_APPLICATION_INVALID:int = 12;
        public static const NETCONNECTION_FAILED:int = 13;
        public static const NETCONNECTION_TIMEOUT:int = 14;
        public static const NETSTREAM_PLAY_FAILED:int = 15;
        public static const NETSTREAM_STREAM_NOT_FOUND:int = 16;
        public static const NETSTREAM_FILE_STRUCTURE_INVALID:int = 17;
        public static const NETSTREAM_NO_SUPPORTED_TRACK_FOUND:int = 18;
        public static const DRM_SYSTEM_UPDATE_ERROR:int = 19;
        public static const DVRCAST_SUBSCRIBE_FAILED:int = 20;
        public static const DVRCAST_CONTENT_OFFLINE:int = 21;
        public static const DVRCAST_STREAM_INFO_RETRIEVAL_FAILED:int = 22;
        public static const F4M_FILE_INVALID:int = 23;
        private static const errorMap:Array = [{
            errorID:IO_ERROR,
            message:OSMFStrings.IO_ERROR
        }, {
            errorID:SECURITY_ERROR,
            message:OSMFStrings.SECURITY_ERROR
        }, {
            errorID:ASYNC_ERROR,
            message:OSMFStrings.ASYNC_ERROR
        }, {
            errorID:ARGUMENT_ERROR,
            message:OSMFStrings.ARGUMENT_ERROR
        }, {
            errorID:URL_SCHEME_INVALID,
            message:OSMFStrings.URL_SCHEME_INVALID
        }, {
            errorID:HTTP_GET_FAILED,
            message:OSMFStrings.HTTP_GET_FAILED
        }, {
            errorID:MEDIA_LOAD_FAILED,
            message:OSMFStrings.MEDIA_LOAD_FAILED
        }, {
            errorID:PLUGIN_VERSION_INVALID,
            message:OSMFStrings.PLUGIN_VERSION_INVALID
        }, {
            errorID:PLUGIN_IMPLEMENTATION_INVALID,
            message:OSMFStrings.PLUGIN_IMPLEMENTATION_INVALID
        }, {
            errorID:SOUND_PLAY_FAILED,
            message:OSMFStrings.SOUND_PLAY_FAILED
        }, {
            errorID:NETCONNECTION_REJECTED,
            message:OSMFStrings.NETCONNECTION_REJECTED
        }, {
            errorID:NETCONNECTION_APPLICATION_INVALID,
            message:OSMFStrings.NETCONNECTION_APPLICATION_INVALID
        }, {
            errorID:NETCONNECTION_FAILED,
            message:OSMFStrings.NETCONNECTION_FAILED
        }, {
            errorID:NETCONNECTION_TIMEOUT,
            message:OSMFStrings.NETCONNECTION_TIMEOUT
        }, {
            errorID:NETSTREAM_PLAY_FAILED,
            message:OSMFStrings.NETSTREAM_PLAY_FAILED
        }, {
            errorID:NETSTREAM_STREAM_NOT_FOUND,
            message:OSMFStrings.NETSTREAM_STREAM_NOT_FOUND
        }, {
            errorID:NETSTREAM_FILE_STRUCTURE_INVALID,
            message:OSMFStrings.NETSTREAM_FILE_STRUCTURE_INVALID
        }, {
            errorID:NETSTREAM_NO_SUPPORTED_TRACK_FOUND,
            message:OSMFStrings.NETSTREAM_NO_SUPPORTED_TRACK_FOUND
        }, {
            errorID:DRM_SYSTEM_UPDATE_ERROR,
            message:OSMFStrings.DRM_SYSTEM_UPDATE_ERROR
        }, {
            errorID:DVRCAST_SUBSCRIBE_FAILED,
            message:OSMFStrings.DVRCAST_SUBSCRIBE_FAILED
        }, {
            errorID:DVRCAST_CONTENT_OFFLINE,
            message:OSMFStrings.DVRCAST_CONTENT_OFFLINE
        }, {
            errorID:DVRCAST_STREAM_INFO_RETRIEVAL_FAILED,
            message:OSMFStrings.DVRCAST_STREAM_INFO_RETRIEVAL_FAILED
        }, {
            errorID:F4M_FILE_INVALID,
            message:OSMFStrings.F4M_FILE_INVALID
        }];

        static function getMessageForErrorID(_arg1:int):String{
            var _local2 = "";
            var _local3:int;
            while (_local3 < errorMap.length) {
                if (errorMap[_local3].errorID == _arg1){
                    _local2 = OSMFStrings.getString(errorMap[_local3].message);
                    break;
                };
                _local3++;
            };
            return (_local2);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class MediaPlayerStateChangeEvent extends Event {

        public static const MEDIA_PLAYER_STATE_CHANGE:String = "mediaPlayerStateChange";

        private var _state:String;

        public function MediaPlayerStateChangeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null){
            super(_arg1, _arg2, _arg3);
            this._state = _arg4;
        }
        public function get state():String{
            return (this._state);
        }
        override public function clone():Event{
            return (new MediaPlayerStateChangeEvent(type, bubbles, cancelable, this._state));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class DynamicStreamEvent extends Event {

        public static const SWITCHING_CHANGE:String = "switchingChange";
        public static const NUM_DYNAMIC_STREAMS_CHANGE:String = "numDynamicStreamsChange";
        public static const AUTO_SWITCH_CHANGE:String = "autoSwitchChange";

        private var _switching:Boolean;
        private var _autoSwitch:Boolean;

        public function DynamicStreamEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this._switching = _arg4;
            this._autoSwitch = _arg5;
        }
        public function get switching():Boolean{
            return (this._switching);
        }
        public function get autoSwitch():Boolean{
            return (this._autoSwitch);
        }
        override public function clone():Event{
            return (new DynamicStreamEvent(type, bubbles, cancelable, this._switching, this._autoSwitch));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.media.*;
    import flash.events.*;

    public class MediaFactoryEvent extends Event {

        public static const PLUGIN_LOAD:String = "pluginLoad";
        public static const PLUGIN_LOAD_ERROR:String = "pluginLoadError";
        public static const MEDIA_ELEMENT_CREATE:String = "mediaElementCreate";

        private var _resource:MediaResourceBase;
        private var _mediaElement:MediaElement;

        public function MediaFactoryEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:MediaResourceBase=null, _arg5:MediaElement=null){
            super(_arg1, _arg2, _arg3);
            this._resource = _arg4;
            this._mediaElement = _arg5;
        }
        public function get resource():MediaResourceBase{
            return (this._resource);
        }
        public function get mediaElement():MediaElement{
            return (this._mediaElement);
        }
        override public function clone():Event{
            return (new MediaFactoryEvent(type, bubbles, cancelable, this._resource, this._mediaElement));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.net.httpstreaming.*;
    import org.osmf.net.httpstreaming.flv.*;

    public class HTTPStreamingEvent extends Event {

        public static const TRANSITION:String = "transition";
        public static const TRANSITION_COMPLETE:String = "transitionComplete";
        public static const BEGIN_FRAGMENT:String = "beginFragment";
        public static const END_FRAGMENT:String = "endFragment";
        public static const DOWNLOAD_COMPLETE:String = "downloadComplete";
        public static const DOWNLOAD_ERROR:String = "downloadError";
        public static const DOWNLOAD_SKIP:String = "downloadSkip";
        public static const DOWNLOAD_CONTINUE:String = "downloadContinue";
        public static const DOWNLOAD_PROGRESS:String = "downloadProgress";
        public static const FRAGMENT_DURATION:String = "fragmentDuration";
        public static const FILE_ERROR:String = "fileError";
        public static const INDEX_ERROR:String = "indexError";
        public static const SCRIPT_DATA:String = "scriptData";
        public static const ACTION_NEEDED:String = "actionNeeded";
        public static const RUN_ALGORITHM:String = "runAlgorithm";

        private var _fragmentDuration:Number;
        private var _scriptDataObject:FLVTagScriptDataObject;
        private var _scriptDataMode:String;
        private var _url:String;
        private var _bytesDownloaded:uint;
        private var _reason:String;
        private var _downloader:HTTPStreamDownloader;

        public function HTTPStreamingEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Number=0, _arg5:FLVTagScriptDataObject=null, _arg6:String="normal", _arg7:String=null, _arg8:uint=0, _arg9:String="normal", _arg10:HTTPStreamDownloader=null){
            super(_arg1, _arg2, _arg3);
            this._fragmentDuration = _arg4;
            this._scriptDataObject = _arg5;
            this._scriptDataMode = _arg6;
            this._url = _arg7;
            this._bytesDownloaded = _arg8;
            this._reason = _arg9;
            this._downloader = _arg10;
        }
        public function get fragmentDuration():Number{
            return (this._fragmentDuration);
        }
        public function get scriptDataObject():FLVTagScriptDataObject{
            return (this._scriptDataObject);
        }
        public function get scriptDataMode():String{
            return (this._scriptDataMode);
        }
        public function get url():String{
            return (this._url);
        }
        public function get bytesDownloaded():uint{
            return (this._bytesDownloaded);
        }
        public function get reason():String{
            return (this._reason);
        }
        public function get downloader():HTTPStreamDownloader{
            return (this._downloader);
        }
        override public function clone():Event{
            return (new HTTPStreamingEvent(type, bubbles, cancelable, this.fragmentDuration, this.scriptDataObject, this.scriptDataMode, this._url, this._bytesDownloaded, this._reason, this._downloader));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class LoadEvent extends Event {

        public static const LOAD_STATE_CHANGE:String = "loadStateChange";
        public static const BYTES_LOADED_CHANGE:String = "bytesLoadedChange";
        public static const BYTES_TOTAL_CHANGE:String = "bytesTotalChange";

        private var _loadState:String;
        private var _bytes:Number;

        public function LoadEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._loadState = _arg4;
            this._bytes = _arg5;
        }
        override public function clone():Event{
            return (new LoadEvent(type, bubbles, cancelable, this.loadState, this.bytes));
        }
        public function get loadState():String{
            return (this._loadState);
        }
        public function get bytes():Number{
            return (this._bytes);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.net.httpstreaming.flv.*;
    import org.osmf.net.httpstreaming.f4f.*;

    public class HTTPStreamingFileHandlerEvent extends HTTPStreamingEvent {

        public static const NOTIFY_BOOTSTRAP_BOX:String = "notifyBootstrapBox";

        private var _abst:AdobeBootstrapBox;

        public function HTTPStreamingFileHandlerEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Number=0, _arg5:FLVTagScriptDataObject=null, _arg6:String="normal", _arg7:AdobeBootstrapBox=null){
            super(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6);
            this._abst = _arg7;
        }
        public function get bootstrapBox():AdobeBootstrapBox{
            return (this._abst);
        }
        override public function clone():Event{
            return (new HTTPStreamingFileHandlerEvent(type, bubbles, cancelable, fragmentDuration, scriptDataObject, scriptDataMode, this.bootstrapBox));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class BufferEvent extends Event {

        public static const BUFFERING_CHANGE:String = "bufferingChange";
        public static const BUFFER_TIME_CHANGE:String = "bufferTimeChange";

        private var _buffering:Boolean;
        private var _bufferTime:Number;

        public function BufferEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._buffering = _arg4;
            this._bufferTime = _arg5;
        }
        public function get buffering():Boolean{
            return (this._buffering);
        }
        public function get bufferTime():Number{
            return (this._bufferTime);
        }
        override public function clone():Event{
            return (new BufferEvent(type, bubbles, cancelable, this._buffering, this._bufferTime));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class MediaPlayerCapabilityChangeEvent extends Event {

        public static const CAN_PLAY_CHANGE:String = "canPlayChange";
        public static const CAN_SEEK_CHANGE:String = "canSeekChange";
        public static const TEMPORAL_CHANGE:String = "temporalChange";
        public static const HAS_AUDIO_CHANGE:String = "hasAudioChange";
        public static const HAS_ALTERNATIVE_AUDIO_CHANGE:String = "hasAlternativeAudioChange";
        public static const IS_DYNAMIC_STREAM_CHANGE:String = "isDynamicStreamChange";
        public static const CAN_LOAD_CHANGE:String = "canLoadChange";
        public static const CAN_BUFFER_CHANGE:String = "canBufferChange";
        public static const HAS_DRM_CHANGE:String = "hasDRMChange";
        public static const HAS_DISPLAY_OBJECT_CHANGE:String = "hasDisplayObjectChange";

        private var _enabled:Boolean;

        public function MediaPlayerCapabilityChangeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this._enabled = _arg4;
        }
        public function get enabled():Boolean{
            return (this._enabled);
        }
        override public function clone():Event{
            return (new MediaPlayerCapabilityChangeEvent(type, bubbles, cancelable, this._enabled));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import flash.display.*;

    public class DisplayObjectEvent extends Event {

        public static const DISPLAY_OBJECT_CHANGE:String = "displayObjectChange";
        public static const MEDIA_SIZE_CHANGE:String = "mediaSizeChange";

        private var _oldDisplayObject:DisplayObject;
        private var _newDisplayObject:DisplayObject;
        private var _oldWidth:Number;
        private var _oldHeight:Number;
        private var _newWidth:Number;
        private var _newHeight:Number;

        public function DisplayObjectEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:DisplayObject=null, _arg5:DisplayObject=null, _arg6:Number=NaN, _arg7:Number=NaN, _arg8:Number=NaN, _arg9:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._oldDisplayObject = _arg4;
            this._newDisplayObject = _arg5;
            this._oldWidth = _arg6;
            this._oldHeight = _arg7;
            this._newWidth = _arg8;
            this._newHeight = _arg9;
        }
        public function get oldDisplayObject():DisplayObject{
            return (this._oldDisplayObject);
        }
        public function get newDisplayObject():DisplayObject{
            return (this._newDisplayObject);
        }
        public function get oldWidth():Number{
            return (this._oldWidth);
        }
        public function get oldHeight():Number{
            return (this._oldHeight);
        }
        public function get newWidth():Number{
            return (this._newWidth);
        }
        public function get newHeight():Number{
            return (this._newHeight);
        }
        override public function clone():Event{
            return (new DisplayObjectEvent(type, bubbles, cancelable, this._oldDisplayObject, this._newDisplayObject, this._oldWidth, this._oldHeight, this._newWidth, this._newHeight));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.net.qos.*;

    public class QoSInfoEvent extends Event {

        public static const QOS_UPDATE:String = "qosUpdate";

        private var _qosInfo:QoSInfo = null;

        public function QoSInfoEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:QoSInfo=null){
            super(_arg1, _arg2, _arg3);
            this._qosInfo = _arg4;
        }
        public function get qosInfo():QoSInfo{
            return (this._qosInfo);
        }
        override public function clone():Event{
            return (new QoSInfoEvent(type, bubbles, cancelable, this._qosInfo));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.utils.*;

    public final class MetricErrorCodes {

        public static const INVALID_METRIC_TYPE:int = 1;
        private static const errorMap:Array = [{
            errorID:INVALID_METRIC_TYPE,
            message:OSMFStrings.METRIC_NOT_FOUND
        }];

        static function getMessageForErrorID(_arg1:int):String{
            var _local2 = "";
            var _local3:int;
            while (_local3 < errorMap.length) {
                if (errorMap[_local3].errorID == _arg1){
                    _local2 = OSMFStrings.getString(errorMap[_local3].message);
                    break;
                };
                _local3++;
            };
            return (_local2);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class ParseEvent extends Event {

        public static const PARSE_COMPLETE:String = "parseComplete";
        public static const PARSE_ERROR:String = "parseError";

        public var data:Object;

        public function ParseEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Object=null){
            this.data = _arg4;
            super(_arg1, _arg2, _arg3);
        }
        override public function clone():Event{
            return (new ParseEvent(this.type, this.bubbles, this.cancelable, this.data));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class TimeEvent extends Event {

        public static const CURRENT_TIME_CHANGE:String = "currentTimeChange";
        public static const DURATION_CHANGE:String = "durationChange";
        public static const COMPLETE:String = "complete";

        private var _time:Number;

        public function TimeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._time = _arg4;
        }
        public function get time():Number{
            return (this._time);
        }
        override public function clone():Event{
            return (new TimeEvent(type, bubbles, cancelable, this.time));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class SeekEvent extends Event {

        public static const SEEKING_CHANGE:String = "seekingChange";

        private var _seeking:Boolean = false;
        private var _time:Number;

        public function SeekEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._seeking = _arg4;
            this._time = _arg5;
        }
        public function get seeking():Boolean{
            return (this._seeking);
        }
        public function get time():Number{
            return (this._time);
        }
        override public function clone():Event{
            return (new SeekEvent(type, bubbles, cancelable, this._seeking, this._time));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.metadata.*;

    public class MediaElementEvent extends Event {

        public static const TRAIT_ADD:String = "traitAdd";
        public static const TRAIT_REMOVE:String = "traitRemove";
        public static const METADATA_ADD:String = "metadataAdd";
        public static const METADATA_REMOVE:String = "metadataRemove";

        private var _traitType:String;
        private var _namespaceURL:String;
        private var _metadata:Metadata;

        public function MediaElementEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:String=null, _arg6:Metadata=null){
            super(_arg1, _arg2, _arg3);
            this._traitType = _arg4;
            this._namespaceURL = _arg5;
            this._metadata = _arg6;
        }
        override public function clone():Event{
            return (new MediaElementEvent(type, bubbles, cancelable, this.traitType, this.namespaceURL, this.metadata));
        }
        public function get traitType():String{
            return (this._traitType);
        }
        public function get namespaceURL():String{
            return (this._namespaceURL);
        }
        public function get metadata():Metadata{
            return (this._metadata);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.media.*;
    import flash.events.*;
    import flash.net.*;

    public class NetConnectionFactoryEvent extends Event {

        public static const CREATION_COMPLETE:String = "creationComplete";
        public static const CREATION_ERROR:String = "creationError";

        private var _netConnection:NetConnection;
        private var _resource:URLResource;
        private var _mediaError:MediaError;

        public function NetConnectionFactoryEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:NetConnection=null, _arg5:URLResource=null, _arg6:MediaError=null){
            super(_arg1, _arg2, _arg3);
            this._netConnection = _arg4;
            this._resource = _arg5;
            this._mediaError = _arg6;
        }
        public function get netConnection():NetConnection{
            return (this._netConnection);
        }
        public function get resource():URLResource{
            return (this._resource);
        }
        public function get mediaError():MediaError{
            return (this._mediaError);
        }
        override public function clone():Event{
            return (new NetConnectionFactoryEvent(type, bubbles, cancelable, this._netConnection, this._resource, this._mediaError));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import org.osmf.containers.*;

    public class ContainerChangeEvent extends Event {

        public static const CONTAINER_CHANGE:String = "containerChange";

        private var _oldContainer:IMediaContainer;
        private var _newContainer:IMediaContainer;

        public function ContainerChangeEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:IMediaContainer=null, _arg5:IMediaContainer=null){
            super(_arg1, _arg2, _arg3);
            this._oldContainer = _arg4;
            this._newContainer = _arg5;
        }
        public function get oldContainer():IMediaContainer{
            return (this._oldContainer);
        }
        public function get newContainer():IMediaContainer{
            return (this._newContainer);
        }
        override public function clone():Event{
            return (new ContainerChangeEvent(type, bubbles, cancelable, this._oldContainer, this._newContainer));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class AudioEvent extends Event {

        public static const VOLUME_CHANGE:String = "volumeChange";
        public static const MUTED_CHANGE:String = "mutedChange";
        public static const PAN_CHANGE:String = "panChange";

        private var _muted:Boolean;
        private var _volume:Number;
        private var _pan:Number;

        public function AudioEvent(_arg1:String, _arg2:Boolean, _arg3:Boolean, _arg4:Boolean=false, _arg5:Number=NaN, _arg6:Number=NaN){
            super(_arg1, _arg2, _arg3);
            this._muted = _arg4;
            this._volume = _arg5;
            this._pan = _arg6;
        }
        public function get muted():Boolean{
            return (this._muted);
        }
        public function get volume():Number{
            return (this._volume);
        }
        public function get pan():Number{
            return (this._pan);
        }
        override public function clone():Event{
            return (new AudioEvent(type, bubbles, cancelable, this._muted, this._volume, this._pan));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class MediaErrorEvent extends Event {

        public static const MEDIA_ERROR:String = "mediaError";

        private var _error:MediaError;

        public function MediaErrorEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:MediaError=null){
            super(_arg1, _arg2, _arg3);
            this._error = _arg4;
        }
        override public function clone():Event{
            return (new MediaErrorEvent(type, bubbles, cancelable, this.error));
        }
        public function get error():MediaError{
            return (this._error);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class AlternativeAudioEvent extends Event {

        public static const AUDIO_SWITCHING_CHANGE:String = "audioSwitchingChange";
        public static const NUM_ALTERNATIVE_AUDIO_STREAMS_CHANGE:String = "numAlternativeAudioStreamsChange";

        private var _switching:Boolean;

        public function AlternativeAudioEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this._switching = _arg4;
        }
        public function get switching():Boolean{
            return (this._switching);
        }
        override public function clone():Event{
            return (new AlternativeAudioEvent(type, bubbles, cancelable, this.switching));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.flv.*;

    public class HTTPStreamingIndexHandlerEvent extends HTTPStreamingEvent {

        public static const INDEX_READY:String = "indexReady";
        public static const RATES_READY:String = "ratesReady";
        public static const REQUEST_LOAD_INDEX:String = "requestLoadIndex";

        private var _streamNames:Array;
        private var _rates:Array;
        private var _request:URLRequest;
        private var _requestContext:Object;
        private var _binaryData:Boolean;
        private var _live:Boolean;
        private var _offset:Number;

        public function HTTPStreamingIndexHandlerEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Number=NaN, _arg6:Array=null, _arg7:Array=null, _arg8:URLRequest=null, _arg9:Object=null, _arg10:Boolean=true, _arg11:Number=0, _arg12:FLVTagScriptDataObject=null, _arg13:String="normal"){
            super(_arg1, _arg2, _arg3, _arg11, _arg12, _arg13);
            this._live = _arg4;
            this._offset = _arg5;
            this._streamNames = _arg6;
            this._rates = _arg7;
            this._request = _arg8;
            this._requestContext = _arg9;
            this._binaryData = _arg10;
        }
        public function get live():Boolean{
            return (this._live);
        }
        public function get offset():Number{
            return (this._offset);
        }
        public function get streamNames():Array{
            return (this._streamNames);
        }
        public function get rates():Array{
            return (this._rates);
        }
        public function get request():URLRequest{
            return (this._request);
        }
        public function get requestContext():Object{
            return (this._requestContext);
        }
        public function get binaryData():Boolean{
            return (this._binaryData);
        }
        override public function clone():Event{
            return (new HTTPStreamingIndexHandlerEvent(type, bubbles, cancelable, this.live, this.offset, this.streamNames, this.rates, this.request, this.requestContext, this.binaryData, fragmentDuration, scriptDataObject, scriptDataMode));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {

    public class MediaError extends Error {

        private var _detail:String;

        public function MediaError(_arg1:int, _arg2:String=null){
            super(this.getMessageForErrorID(_arg1), _arg1);
            this._detail = _arg2;
        }
        public function get detail():String{
            return (this._detail);
        }
        protected function getMessageForErrorID(_arg1:int):String{
            return (MediaErrorCodes.getMessageForErrorID(_arg1));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {

    public class HTTPStreamingEventReason {

        public static const NORMAL:String = "normal";
        public static const BEST_EFFORT:String = "bestEffort";
        public static const TIMEOUT:String = "timeout";

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.traits.*;
    import flash.events.*;

    public class LoaderEvent extends Event {

        public static const LOAD_STATE_CHANGE:String = "loadStateChange";

        private var _loader:LoaderBase;
        private var _loadTrait:LoadTrait;
        private var _oldState:String;
        private var _newState:String;

        public function LoaderEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:LoaderBase=null, _arg5:LoadTrait=null, _arg6:String=null, _arg7:String=null){
            super(_arg1, _arg2, _arg3);
            this._loader = _arg4;
            this._loadTrait = _arg5;
            this._oldState = _arg6;
            this._newState = _arg7;
        }
        public function get loader():LoaderBase{
            return (this._loader);
        }
        public function get loadTrait():LoadTrait{
            return (this._loadTrait);
        }
        public function get oldState():String{
            return (this._oldState);
        }
        public function get newState():String{
            return (this._newState);
        }
        override public function clone():Event{
            return (new LoaderEvent(type, bubbles, cancelable, this.loader, this.loadTrait, this.oldState, this.newState));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class MetadataEvent extends Event {

        public static const VALUE_ADD:String = "valueAdd";
        public static const VALUE_REMOVE:String = "valueRemove";
        public static const VALUE_CHANGE:String = "valueChange";

        private var _key:String;
        private var _value;
        private var _oldValue;

        public function MetadataEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5=null, _arg6=null){
            super(_arg1, _arg2, _arg3);
            this._key = _arg4;
            this._value = _arg5;
            this._oldValue = _arg6;
        }
        public function get key():String{
            return (this._key);
        }
        public function get value(){
            return (this._value);
        }
        public function get oldValue(){
            return (this._oldValue);
        }
        override public function clone():Event{
            return (new MetadataEvent(type, bubbles, cancelable, this._key, this._value, this._oldValue));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {

    public class MetricError extends Error {

        private var _detail:String;

        public function MetricError(_arg1:int, _arg2:String=null){
            super(this.getMessageForErrorID(_arg1), _arg1);
            this._detail = _arg2;
        }
        public function get detail():String{
            return (this._detail);
        }
        protected function getMessageForErrorID(_arg1:int):String{
            return (MetricErrorCodes.getMessageForErrorID(_arg1));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class DVREvent extends Event {

        public static const IS_RECORDING_CHANGE:String = "isRecordingChange";

        public function DVREvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false){
            super(_arg1, _arg2, _arg3);
        }
        override public function clone():Event{
            return (new DVREvent(type, bubbles, cancelable));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import org.osmf.media.*;
    import flash.events.*;

    public class PluginManagerEvent extends Event {

        public static const PLUGIN_LOAD:String = "pluginLoad";
        public static const PLUGIN_LOAD_ERROR:String = "pluginLoadError";

        private var _resource:MediaResourceBase;

        public function PluginManagerEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:MediaResourceBase=null){
            super(_arg1, _arg2, _arg3);
            this._resource = _arg4;
        }
        public function get resource():MediaResourceBase{
            return (this._resource);
        }
        override public function clone():Event{
            return (new PluginManagerEvent(type, bubbles, cancelable, this._resource));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class PlayEvent extends Event {

        public static const CAN_PAUSE_CHANGE:String = "canPauseChange";
        public static const PLAY_STATE_CHANGE:String = "playStateChange";
        public static const LIVE_STALL:String = "liveStall";
        public static const LIVE_RESUME:String = "liveResume";

        private var _playState:String;
        private var _canPause:Boolean;

        public function PlayEvent(_arg1:String, _arg2:Boolean=false, _arg3:Boolean=false, _arg4:String=null, _arg5:Boolean=false){
            super(_arg1, _arg2, _arg3);
            this._playState = _arg4;
            this._canPause = _arg5;
        }
        override public function clone():Event{
            return (new PlayEvent(type, bubbles, cancelable, this.playState, this.canPause));
        }
        public function get playState():String{
            return (this._playState);
        }
        public function get canPause():Boolean{
            return (this._canPause);
        }

    }
}//package org.osmf.events 
﻿package org.osmf.events {
    import flash.events.*;

    public class DRMEvent extends Event {

        public static const DRM_STATE_CHANGE:String = "drmStateChange";

        private var _drmState:String;
        private var _startDate:Date;
        private var _endDate:Date;
        private var _period:Number;
        private var _serverURL:String;
        private var _token:Object;
        private var _mediaError:MediaError;

        public function DRMEvent(_arg1:String, _arg2:String, _arg3:Boolean=false, _arg4:Boolean=false, _arg5:Date=null, _arg6:Date=null, _arg7:Number=0, _arg8:String=null, _arg9:Object=null, _arg10:MediaError=null){
            super(_arg1, _arg3, _arg4);
            this._drmState = _arg2;
            this._token = _arg9;
            this._mediaError = _arg10;
            this._startDate = _arg5;
            this._endDate = _arg6;
            this._period = _arg7;
            this._serverURL = _arg8;
        }
        public function get token():Object{
            return (this._token);
        }
        public function get mediaError():MediaError{
            return (this._mediaError);
        }
        public function get startDate():Date{
            return (this._startDate);
        }
        public function get endDate():Date{
            return (this._endDate);
        }
        public function get period():Number{
            return (this._period);
        }
        public function get drmState():String{
            return (this._drmState);
        }
        public function get serverURL():String{
            return (this._serverURL);
        }
        override public function clone():Event{
            return (new DRMEvent(type, this._drmState, bubbles, cancelable, this._startDate, this._endDate, this._period, this._serverURL, this._token, this._mediaError));
        }

    }
}//package org.osmf.events 
﻿package org.osmf.utils {
    import flash.system.*;

    public final class OSMFSettings {

        public static var enableStageVideo:Boolean = true;
        public static var hdsMinimumBufferTime:Number = 4;
        public static var hdsAdditionalBufferTime:Number = 2;
        public static var hdsBytesProcessingLimit:Number = 102400;
        public static var hdsBytesReadingLimit:Number = 102400;
        public static var hdsMainTimerInterval:int = 25;
        public static var hdsLiveStallTolerance:Number = 15;
        public static var hdsDefaultFragmentsThreshold:uint = 5;
        public static var hdsMinimumBootstrapRefreshInterval:uint = 2000;
        public static var hdsDVRLiveOffset:Number = 4;
        public static var hdsPureLiveOffset:Number = 5;
        public static var f4mParseTimeout:Number = 30000;
        public static var hdsMaximumRetries:Number = 5;
        public static var hdsTimeoutAdjustmentOnRetry:Number = 4000;
        public static var hdsFragmentDownloadTimeout:Number = 4000;
        public static var hdsIndexDownloadTimeout:Number = 4000;

        public static function get supportsStageVideo():Boolean{
            return (runtimeSupportsStageVideo(Capabilities.version));
        }
        static function runtimeSupportsStageVideo(_arg1:String):Boolean{
            if (_arg1 == null){
                return (false);
            };
            var _local2:Array = _arg1.split(" ");
            if (_local2.length < 2){
                return (false);
            };
            var _local3:String = _local2[0];
            var _local4:Array = _local2[1].split(",");
            if (_local4.length < 2){
                return (false);
            };
            var _local5:Number = parseInt(_local4[0]);
            var _local6:Number = parseInt(_local4[1]);
            return ((((_local5 > 10)) || ((((_local5 == 10)) && ((_local6 >= 2))))));
        }

    }
}//package org.osmf.utils 
﻿package org.osmf.utils {

    public class DateUtil {

        public static function parseW3CDTF(_arg1:String):Date{
            var finalDate:* = null;
            var dateStr:* = null;
            var timeStr:* = null;
            var dateArr:* = null;
            var year:* = NaN;
            var month:* = NaN;
            var date:* = NaN;
            var multiplier:* = NaN;
            var offsetHours:* = NaN;
            var offsetMinutes:* = NaN;
            var offsetStr:* = null;
            var timeArr:* = null;
            var hour:* = NaN;
            var minutes:* = NaN;
            var secondsArr:* = null;
            var seconds:* = NaN;
            var milliseconds:* = NaN;
            var utc:* = NaN;
            var offset:* = NaN;
            var eStr:* = null;
            var str:* = _arg1;
            try {
                dateStr = str.substring(0, str.indexOf("T"));
                timeStr = str.substring((str.indexOf("T") + 1), str.length);
                dateArr = dateStr.split("-");
                year = Number(dateArr.shift());
                month = Number(dateArr.shift());
                date = Number(dateArr.shift());
                if (timeStr.indexOf("Z") != -1){
                    multiplier = 1;
                    offsetHours = 0;
                    offsetMinutes = 0;
                    timeStr = timeStr.replace("Z", "");
                } else {
                    if (timeStr.indexOf("+") != -1){
                        multiplier = 1;
                        offsetStr = timeStr.substring((timeStr.indexOf("+") + 1), timeStr.length);
                        offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
                        offsetMinutes = Number(offsetStr.substring((offsetStr.indexOf(":") + 1), offsetStr.length));
                        timeStr = timeStr.substring(0, timeStr.indexOf("+"));
                    } else {
                        multiplier = -1;
                        offsetStr = timeStr.substring((timeStr.indexOf("-") + 1), timeStr.length);
                        offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
                        offsetMinutes = Number(offsetStr.substring((offsetStr.indexOf(":") + 1), offsetStr.length));
                        timeStr = timeStr.substring(0, timeStr.indexOf("-"));
                    };
                };
                timeArr = timeStr.split(":");
                hour = Number(timeArr.shift());
                minutes = Number(timeArr.shift());
                secondsArr = ((timeArr.length)>0) ? String(timeArr.shift()).split(".") : null;
                seconds = ((((!((secondsArr == null))) && ((secondsArr.length > 0)))) ? Number(secondsArr.shift()) : 0);
                milliseconds = ((((!((secondsArr == null))) && ((secondsArr.length > 0)))) ? Number(secondsArr.shift()) : 0);
                utc = Date.UTC(year, (month - 1), date, hour, minutes, seconds, milliseconds);
                offset = (((offsetHours * 3600000) + (offsetMinutes * 60000)) * multiplier);
                finalDate = new Date((utc - offset));
                if (finalDate.toString() == "Invalid Date"){
                    throw (new Error("This date does not conform to W3CDTF."));
                };
            } catch(e:Error) {
                eStr = (("Unable to parse the string [" + str) + "] into a date. ");
                eStr = (eStr + ("The internal error was: " + e.toString()));
                throw (new Error(eStr));
            };
            return (finalDate);
        }

    }
}//package org.osmf.utils 
﻿package org.osmf.utils {

    public class URL {

        private var _rawUrl:String;
        private var _protocol:String;
        private var _userInfo:String;
        private var _host:String;
        private var _port:String;
        private var _path:String;
        private var _query:String;
        private var _fragment:String;

        public function URL(_arg1:String){
            this._rawUrl = _arg1;
            this._protocol = "";
            this._userInfo = "";
            this._host = "";
            this._port = "";
            this._path = "";
            this._query = "";
            this._fragment = "";
            if (((!((this._rawUrl == null))) && ((this._rawUrl.length > 0)))){
                this._rawUrl = this._rawUrl.replace(/^\s+|\s+$/g, "");
                this.parseUrl();
            };
        }
        public static function isAbsoluteURL(_arg1:String):Boolean{
            var _local2:URL = new URL(_arg1);
            return (_local2.absolute);
        }
        public static function getRootUrl(_arg1:String):String{
            var _local2:String = _arg1.substr(0, _arg1.lastIndexOf("/"));
            return (_local2);
        }
        public static function normalizeRootURL(_arg1:String):String{
            if (((!((_arg1 == null))) && (!((_arg1.charAt((_arg1.length - 1)) == "/"))))){
                return ((_arg1 + "/"));
            };
            return (_arg1);
        }
        public static function normalizeRelativeURL(_arg1:String):String{
            if (_arg1.charAt(0) == "/"){
                return (_arg1.substr(1));
            };
            return (_arg1);
        }
        public static function normalizePathForURL(_arg1:String, _arg2:Boolean):String{
            var _local5:String;
            var _local6:int;
            var _local3:String = _arg1;
            var _local4:URL = new URL(_arg1);
            if (_local4.absolute){
                _local3 = ((_local4.protocol + "://") + _local4.host);
                if (((!((_local4.port == null))) && ((_local4.port.length > 0)))){
                    _local3 = (_local3 + (":" + _local4.port));
                };
                _local5 = _local4.path;
                if (((!((_local5 == null))) && ((_local5.length > 0)))){
                    if (_arg2){
                        _local6 = _local5.lastIndexOf("/");
                        _local5 = _local5.substr(0, (_local6 + 1));
                    };
                    _local3 = (_local3 + ("/" + _local5));
                };
            };
            return (URL.normalizeRootURL(_local3));
        }

        public function get rawUrl():String{
            return (this._rawUrl);
        }
        public function get protocol():String{
            return (this._protocol);
        }
        public function set protocol(_arg1:String):void{
            if (_arg1 != null){
                this._protocol = _arg1.replace(/:\/?\/?$/, "");
                this._protocol = this._protocol.toLowerCase();
            };
        }
        public function get userInfo():String{
            return (this._userInfo);
        }
        public function set userInfo(_arg1:String):void{
            if (_arg1 != null){
                this._userInfo = _arg1.replace(/@$/, "");
            };
        }
        public function get host():String{
            return (this._host);
        }
        public function set host(_arg1:String):void{
            this._host = _arg1;
        }
        public function get port():String{
            return (this._port);
        }
        public function set port(_arg1:String):void{
            if (_arg1 != null){
                this._port = _arg1.replace(/(:)/, "");
            };
        }
        public function get path():String{
            return (this._path);
        }
        public function set path(_arg1:String):void{
            if (_arg1 != null){
                this._path = _arg1.replace(/^\//, "");
            };
        }
        public function get query():String{
            return (this._query);
        }
        public function set query(_arg1:String):void{
            if (_arg1 != null){
                this._query = _arg1.replace(/^\?/, "");
            };
        }
        public function get fragment():String{
            return (this._fragment);
        }
        public function set fragment(_arg1:String):void{
            if (_arg1 != null){
                this._fragment = _arg1.replace(/^#/, "");
            };
        }
        public function toString():String{
            return (this._rawUrl);
        }
        public function getParamValue(_arg1:String):String{
            if (this._query == null){
                return ("");
            };
            var _local2:RegExp = new RegExp((("[/?&]*" + _arg1) + "=([^&#]*)"), "i");
            var _local3:Array = this._query.match(_local2);
            var _local4:String = ((_local3)==null) ? "" : _local3[1];
            return (_local4);
        }
        public function get absolute():Boolean{
            return (!((this.protocol == "")));
        }
        public function get extension():String{
            var _local1:int = this.path.lastIndexOf("/");
            var _local2:int = this.path.lastIndexOf(".");
            if (((!((_local2 == -1))) && ((_local2 > _local1)))){
                return (this.path.substr((_local2 + 1)));
            };
            return ("");
        }
        private function parseUrl():void{
            var _local1:RegExp;
            var _local2:Array;
            var _local3:String;
            var _local4:RegExp;
            var _local5:Array;
            var _local6:String;
            if ((((this._rawUrl == null)) || ((this._rawUrl.length == 0)))){
                return;
            };
            if ((((this._rawUrl.search(/:\//) == -1)) && (!((this._rawUrl.indexOf(":") == (this._rawUrl.length - 1)))))){
                this.path = this._rawUrl;
            } else {
                _local1 = /^(rtmp|rtmp[tse]|rtmpte)(:\/[^\/])/i;
                _local2 = this._rawUrl.match(_local1);
                _local3 = this._rawUrl;
                if (_local2 != null){
                    _local3 = this._rawUrl.replace(/:\//, "://localhost/");
                };
                _local4 = /^([a-z+\w\+\.\-]+:\/?\/?)?([^\/?#]*)?(\/[^?#]*)?(\?[^#]*)?(\#.*)?/i;
                _local5 = _local3.match(_local4);
                if (_local5 != null){
                    this.protocol = _local5[1];
                    _local6 = _local5[2];
                    this.path = _local5[3];
                    this.query = _local5[4];
                    this.fragment = _local5[5];
                    _local4 = /^([!-~]+@)?([^\/?#:]*)(:[\d]*)?/i;
                    _local5 = _local6.match(_local4);
                    if (_local5 != null){
                        this.userInfo = _local5[1];
                        this.host = _local5[2];
                        this.port = _local5[3];
                    };
                };
            };
        }

    }
}//package org.osmf.utils 
﻿package org.osmf.utils {
    import flash.utils.*;

    public class OSMFStrings {

        public static const COMPOSITE_TRAIT_NOT_FOUND:String = "compositeTraitNotFound";
        public static const INVALID_PARAM:String = "invalidParam";
        public static const NULL_PARAM:String = "nullParam";
        public static const FUNCTION_MUST_BE_OVERRIDDEN:String = "functionMustBeOverridden";
        public static const ALREADY_ADDED:String = "alreadyAdded";
        public static const UNSUPPORTED_MEDIA_ELEMENT_TYPE:String = "unsupportedMediaElementType";
        public static const TRAIT_INSTANCE_ALREADY_ADDED:String = "traitInstanceAlreadyAdded";
        public static const TRAIT_RESOLVER_ALREADY_ADDED:String = "traitResolverAlreadyAdded";
        public static const CAPABILITY_NOT_SUPPORTED:String = "capabilityNotSupported";
        public static const MEDIA_LOAD_FAILED:String = "mediaLoadFailed";
        public static const MUST_SET_LOADER:String = "mustSetLoader";
        public static const LOADER_CANT_HANDLE_RESOURCE:String = "loaderCantHandleResource";
        public static const PAUSE_NOT_SUPPORTED:String = "pauseNotSupported";
        public static const ALREADY_READY:String = "alreadyReady";
        public static const ALREADY_LOADING:String = "alreadyLoading";
        public static const ALREADY_UNLOADED:String = "alreadyUnloaded";
        public static const ALREADY_UNLOADING:String = "alreadyUnloading";
        public static const INVALID_LAYOUT_RENDERER_CONSTRUCTOR:String = "invalidLayoutRendererConstructor";
        public static const ILLEGAL_CONSTRUCTOR_INVOCATION:String = "illegalConstructorInvocation";
        public static const DIRECT_DISPLAY_LIST_MOD_ERROR:String = "directDisplayListModError";
        public static const NULL_SCRIPT_PATH:String = "nullScriptPath";
        public static const STREAMSWITCH_INVALID_INDEX:String = "streamSwitchInvalidIndex";
        public static const ALTERNATIVEAUDIO_INVALID_INDEX:String = "alternativeAudioInvalidIndex";
        public static const STREAMSWITCH_STREAM_NOT_IN_MANUAL_MODE:String = "streamSwitchStreamNotInManualMode";
        public static const DVR_MAXIMUM_RPC_ATTEMPTS:String = "dvrMaximumRPCAttempts";
        public static const DVR_UNEXPECTED_SERVER_RESPONSE:String = "dvrUnexpectedServerResponse";
        public static const F4M_PARSE_PROFILE_MISSING:String = "f4mProfileMissing";
        public static const F4M_PARSE_MEDIA_URL_MISSING:String = "f4mMediaURLMissing";
        public static const F4M_PARSE_BITRATE_MISSING:String = "f4mBitrateMissing";
        public static const F4M_PARSE_VALUE_MISSING:String = "f4mValueMissing";
        public static const F4M_PARSE_ERROR:String = "f4mParseError";
        public static const IO_ERROR:String = "ioError";
        public static const SECURITY_ERROR:String = "securityError";
        public static const ASYNC_ERROR:String = "asyncError";
        public static const ARGUMENT_ERROR:String = "argumentError";
        public static const URL_SCHEME_INVALID:String = "urlSchemeInvalid";
        public static const HTTP_GET_FAILED:String = "httpGetFailed";
        public static const PLUGIN_VERSION_INVALID:String = "pluginVersionInvalid";
        public static const PLUGIN_IMPLEMENTATION_INVALID:String = "pluginImplementationInvalid";
        public static const SOUND_PLAY_FAILED:String = "soundPlayFailed";
        public static const NETCONNECTION_REJECTED:String = "netConnectionRejected";
        public static const NETCONNECTION_APPLICATION_INVALID:String = "netConnectionApplicationInvalid";
        public static const NETCONNECTION_FAILED:String = "netConnectionFailed";
        public static const NETCONNECTION_TIMEOUT:String = "netConnectionTimeout";
        public static const NETSTREAM_PLAY_FAILED:String = "netStreamPlayFailed";
        public static const NETSTREAM_STREAM_NOT_FOUND:String = "netStreamStreamNotFound";
        public static const NETSTREAM_FILE_STRUCTURE_INVALID:String = "netStreamFileStructureInvalid";
        public static const NETSTREAM_NO_SUPPORTED_TRACK_FOUND:String = "netStreamNoSupportedTrackFound";
        public static const DRM_SYSTEM_UPDATE_ERROR:String = "drmSystemUpdateError";
        public static const DVRCAST_SUBSCRIBE_FAILED:String = "dvrCastSubscribeFailed";
        public static const DVRCAST_CONTENT_OFFLINE:String = "dvrCastContentOffline";
        public static const DVRCAST_STREAM_INFO_RETRIEVAL_FAILED:String = "dvrCastStreamInfoRetrievalFailed";
        public static const MULTICAST_PARAMETER_INVALID:String = "multicastParameterInvalid";
        public static const MULTICAST_NOT_SUPPORT_MBR:String = "multicastNotSupportMBR";
        public static const F4M_FILE_INVALID:String = "f4MFileINVALID";
        public static const F4M_MEDIA_MISSING:String = "f4mMediaMissing";
        public static const METRIC_NOT_FOUND:String = "metricNotFound";
        public static const METRIC_FACTORY_NULL:String = "metricFactoryNull";
        public static const METRIC_ALREADY_EXISTS:String = "metricAlreadyExists";
        public static const NETSTREAM_LIVE_STALL:String = "netStreamLiveStall";
        public static const NETSTREAM_LIVE_RESUME:String = "netStreamLiveResume";
        private static const resourceDict:Dictionary = new Dictionary();
        public static const DRM_METADATA_NOT_SET:String = "drmMetadataNotSet";

        private static var _resourceStringFunction:Function = defaultResourceStringFunction;

        public static function getString(_arg1:String, _arg2:Array=null):String{
            return (resourceStringFunction(_arg1, _arg2));
        }
        public static function get resourceStringFunction():Function{
            return (_resourceStringFunction);
        }
        public static function set resourceStringFunction(_arg1:Function):void{
            _resourceStringFunction = _arg1;
        }
        private static function defaultResourceStringFunction(_arg1:String, _arg2:Array=null):String{
            var _local3:String = ((resourceDict.hasOwnProperty(_arg1)) ? String(resourceDict[_arg1]) : null);
            if (_local3 == null){
                _local3 = String(resourceDict["missingStringResource"]);
                _arg2 = [_arg1];
            };
            if (_arg2){
                _local3 = substitute(_local3, _arg2);
            };
            return (_local3);
        }
        private static function substitute(_arg1:String, ... _args):String{
            var _local4:int;
            var _local5:Array;
            var _local6:int;
            var _local3 = "";
            if (_arg1 != null){
                _local3 = _arg1;
                _local4 = _args.length;
                if ((((_local4 == 1)) && ((_args[0] is Array)))){
                    _local5 = (_args[0] as Array);
                    _local4 = _local5.length;
                } else {
                    _local5 = _args;
                };
                _local6 = 0;
                while (_local6 < _local4) {
                    _local3 = _local3.replace(new RegExp((("\\{" + _local6) + "\\}"), "g"), _local5[_local6]);
                    _local6++;
                };
            };
            return (_local3);
        }

        resourceDict[COMPOSITE_TRAIT_NOT_FOUND] = "There is no composite trait for the given trait type";
        resourceDict[INVALID_PARAM] = "Invalid parameter passed to method";
        resourceDict[NULL_PARAM] = "Unexpected null parameter passed to method";
        resourceDict[FUNCTION_MUST_BE_OVERRIDDEN] = "Function must be overridden";
        resourceDict[ALREADY_ADDED] = "Child has already been added";
        resourceDict[UNSUPPORTED_MEDIA_ELEMENT_TYPE] = "The specified media element type is not supported";
        resourceDict[TRAIT_INSTANCE_ALREADY_ADDED] = "An instance of this trait class has already been added to this MediaElement";
        resourceDict[TRAIT_RESOLVER_ALREADY_ADDED] = "A trait resolver for the specified trait type has already been added to this MediaElement";
        resourceDict[CAPABILITY_NOT_SUPPORTED] = "The specified capability is not currently supported";
        resourceDict[MEDIA_LOAD_FAILED] = "The loading of a MediaElement failed";
        resourceDict[MUST_SET_LOADER] = "Must set LoaderBase on a LoadTrait before calling load or unload";
        resourceDict[LOADER_CANT_HANDLE_RESOURCE] = "LoaderBase unable to handle the given MediaResourceBase";
        resourceDict[PAUSE_NOT_SUPPORTED] = "PlayTrait.pause cannot be invoked when canPause is false";
        resourceDict[ALREADY_READY] = "Loader - attempt to load an already loaded object";
        resourceDict[ALREADY_LOADING] = "Loader - attempt to load a loading object";
        resourceDict[ALREADY_UNLOADED] = "Loader - attempt to unload an already unloaded object";
        resourceDict[ALREADY_UNLOADING] = "Loader - attempt to unload a unloading object";
        resourceDict[INVALID_LAYOUT_RENDERER_CONSTRUCTOR] = "Unable to construct LayoutRenderer implementation";
        resourceDict[ILLEGAL_CONSTRUCTOR_INVOCATION] = "Use the static getInstance method to obtain a class instance";
        resourceDict[DIRECT_DISPLAY_LIST_MOD_ERROR] = "The direct addition or removal of display objects onto a MediaContainer is prohibited.";
        resourceDict[NULL_SCRIPT_PATH] = "Operation requires a valid script path";
        resourceDict[STREAMSWITCH_INVALID_INDEX] = "Dynamic Stream Switching - Invalid index requested";
        resourceDict[STREAMSWITCH_STREAM_NOT_IN_MANUAL_MODE] = "Dynamic Stream Switching - stream is not in manual mode";
        resourceDict[ALTERNATIVEAUDIO_INVALID_INDEX] = "Alternative Audio Source Changing - Invalid index requested";
        resourceDict[DRM_METADATA_NOT_SET] = "Metadata not set on DRMServices";
        resourceDict[DVR_MAXIMUM_RPC_ATTEMPTS] = "Maximum DVRGetStreamInfo RPC attempts (%i) reached";
        resourceDict[DVR_UNEXPECTED_SERVER_RESPONSE] = "Unexpected server response: ";
        resourceDict[F4M_PARSE_PROFILE_MISSING] = "Profile missing from Bootstrap info tag";
        resourceDict[F4M_PARSE_MEDIA_URL_MISSING] = "URL missing from Media tag";
        resourceDict[F4M_PARSE_BITRATE_MISSING] = "Bitrate missing from Media tag";
        resourceDict[F4M_PARSE_VALUE_MISSING] = "Value must be non-null";
        resourceDict[F4M_PARSE_ERROR] = "Error parsing f4m file";
        resourceDict[IO_ERROR] = "I/O error when loading media";
        resourceDict[SECURITY_ERROR] = "Security error when loading media";
        resourceDict[ASYNC_ERROR] = "Async error when loading media";
        resourceDict[ARGUMENT_ERROR] = "Argument error when loading media";
        resourceDict[URL_SCHEME_INVALID] = "Invalid URL scheme";
        resourceDict[HTTP_GET_FAILED] = "HTTP GET failed due to a Client Error (4xx Status Code)";
        resourceDict[PLUGIN_VERSION_INVALID] = "Plugin failed to load due to version mismatch";
        resourceDict[PLUGIN_IMPLEMENTATION_INVALID] = "Plugin failed to load due to improper or missing implementation of PluginInfo";
        resourceDict[SOUND_PLAY_FAILED] = "Playback failed due to no sound channels being available";
        resourceDict[NETCONNECTION_REJECTED] = "Connection attempt rejected by FMS server";
        resourceDict[NETCONNECTION_APPLICATION_INVALID] = "Attempting to connect to an invalid FMS application";
        resourceDict[NETCONNECTION_FAILED] = "All NetConnection attempts failed";
        resourceDict[NETCONNECTION_TIMEOUT] = "Timed-out trying to establish a NetConnection, or timed out due to an idle NetConnection";
        resourceDict[NETSTREAM_PLAY_FAILED] = "Playback failed";
        resourceDict[NETSTREAM_STREAM_NOT_FOUND] = "Stream not found";
        resourceDict[NETSTREAM_FILE_STRUCTURE_INVALID] = "File has invalid structure";
        resourceDict[NETSTREAM_NO_SUPPORTED_TRACK_FOUND] = "No supported track found";
        resourceDict[DRM_SYSTEM_UPDATE_ERROR] = "The update of the DRM subsystem failed";
        resourceDict[DVRCAST_SUBSCRIBE_FAILED] = "DVRCast subscribe failed";
        resourceDict[DVRCAST_CONTENT_OFFLINE] = "DVRCast content is offline and unavailable";
        resourceDict[DVRCAST_STREAM_INFO_RETRIEVAL_FAILED] = "Unable to retrieve DVRCast stream info";
        resourceDict[MULTICAST_PARAMETER_INVALID] = "The groupspec or streamName is null or empty but not both";
        resourceDict[MULTICAST_NOT_SUPPORT_MBR] = "Multicast does not support MBR";
        resourceDict[F4M_FILE_INVALID] = "The F4M document contains errors";
        resourceDict[F4M_MEDIA_MISSING] = "The F4M document doesn't contain media informations.";
        resourceDict[METRIC_ALREADY_EXISTS] = "The metric already exists.";
        resourceDict[METRIC_FACTORY_NULL] = "The metric factory was not set.";
        resourceDict[METRIC_NOT_FOUND] = "The metric was not found.";
        resourceDict[NETSTREAM_LIVE_STALL] = "Live playback stalled.";
        resourceDict[NETSTREAM_LIVE_RESUME] = "Live playback resumed.";
        resourceDict["missingStringResource"] = "No string for resource {0}";
    }
}//package org.osmf.utils 
﻿package org.osmf.utils {

    public class Version {

        private static const FIELD_SEPARATOR:String = ".";
        private static const _major:String = "2";
        private static const _minor:String = "0";
        private static const _build_number:String = "2494";

        public static function get version():String{
            return (((_major + FIELD_SEPARATOR) + _minor));
        }
        public static function get lastAPICompatibleVersion():String{
            return ("1.0");
        }
        public static function get FLASH_10_1():Boolean{
            return (true);
        }
        public static function get LOGGING():Boolean{
            return (false);
        }
        public static function get buildNumber():String{
            return (_build_number);
        }

    }
}//package org.osmf.utils 
﻿package org.osmf.utils {
    import flash.utils.*;

    public class Base64Decoder {

        private static const ESCAPE_CHAR_CODE:Number = 61;
        private static const inverse:Array = [64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 62, 64, 64, 64, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 64, 64, 64, 64, 64, 64, 64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 64, 64, 64, 64, 64, 64, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64];

        private var count:int = 0;
        private var data:ByteArray;
        private var filled:int = 0;
        private var work:Array;

        public function Base64Decoder(){
            this.work = [0, 0, 0, 0];
            super();
            this.data = new ByteArray();
        }
        private static function copyByteArray(_arg1:ByteArray, _arg2:ByteArray, _arg3:uint=0):void{
            var _local4:int = _arg1.position;
            _arg1.position = 0;
            _arg2.position = 0;
            var _local5:uint;
            while ((((_arg1.bytesAvailable > 0)) && ((_local5 < _arg3)))) {
                _arg2.writeByte(_arg1.readByte());
                _local5++;
            };
            _arg1.position = _local4;
            _arg2.position = 0;
        }

        public function decode(_arg1:String):void{
            var _local3:Number;
            var _local2:uint;
            for (;_local2 < _arg1.length;_local2++) {
                _local3 = _arg1.charCodeAt(_local2);
                if (_local3 == ESCAPE_CHAR_CODE){
                    var _local4 = this.count++;
                    this.work[_local4] = -1;
                } else {
                    if (inverse[_local3] != 64){
                        _local4 = this.count++;
                        this.work[_local4] = inverse[_local3];
                    } else {
                        continue;
                    };
                };
                if (this.count == 4){
                    this.count = 0;
                    this.data.writeByte(((this.work[0] << 2) | ((this.work[1] & 0xFF) >> 4)));
                    this.filled++;
                    if (this.work[2] == -1){
                        break;
                    };
                    this.data.writeByte(((this.work[1] << 4) | ((this.work[2] & 0xFF) >> 2)));
                    this.filled++;
                    if (this.work[3] == -1){
                        break;
                    };
                    this.data.writeByte(((this.work[2] << 6) | this.work[3]));
                    this.filled++;
                };
            };
        }
        public function drain():ByteArray{
            var _local1:ByteArray = new ByteArray();
            copyByteArray(this.data, _local1, this.filled);
            this.filled = 0;
            return (_local1);
        }

    }
}//package org.osmf.utils 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.net.*;
    import org.osmf.utils.*;

    public class NetStreamAlternativeAudioTrait extends AlternativeAudioTrait {

        private var _netStream:NetStream;
        private var _streamingResource:StreamingURLResource;
        private var _transitionInProgress:Boolean = false;
        private var _activeTransitionIndex:int = -1;
        private var _activeTransitionStreamName:String = null;
        private var _lastTransitionIndex:int = -2;
        private var _lastTransitionStreamName:String = null;

        public function NetStreamAlternativeAudioTrait(_arg1:NetStream, _arg2:StreamingURLResource){
            super(_arg2.alternativeAudioStreamItems.length);
            this._streamingResource = _arg2;
            this._netStream = _arg1;
            if (((!((this._netStream == null))) && (!((this._netStream.client == null))))){
                NetClient(_arg1.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus);
            };
        }
        override public function dispose():void{
            this._netStream = null;
            this._streamingResource = null;
        }
        override public function getItemForIndex(_arg1:int):StreamingItem{
            if ((((_arg1 <= INVALID_TRANSITION_INDEX)) || ((_arg1 >= numAlternativeAudioStreams)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.ALTERNATIVEAUDIO_INVALID_INDEX)));
            };
            if (_arg1 == DEFAULT_TRANSITION_INDEX){
                return (null);
            };
            return (this._streamingResource.alternativeAudioStreamItems[_arg1]);
        }
        override protected function endSwitching(_arg1:int):void{
            if (switching){
                this.executeSwitching(_indexToSwitchTo);
            };
            super.endSwitching(_arg1);
        }
        protected function executeSwitching(_arg1:int):void{
            var _local2:Object;
            var _local3:NetStreamPlayOptions;
            if (this._lastTransitionIndex != _arg1){
                this._activeTransitionIndex = _arg1;
                if (this._activeTransitionIndex > DEFAULT_TRANSITION_INDEX){
                    this._activeTransitionStreamName = this._streamingResource.alternativeAudioStreamItems[this._activeTransitionIndex].streamName;
                } else {
                    this._activeTransitionStreamName = null;
                };
                this._transitionInProgress = true;
                _local2 = NetStreamUtils.getPlayArgsForResource(this._streamingResource);
                _local3 = new NetStreamPlayOptions();
                _local3.start = _local2.start;
                _local3.len = _local2.len;
                _local3.streamName = this._activeTransitionStreamName;
                _local3.oldStreamName = this.prepareStreamName(this._lastTransitionStreamName);
                _local3.transition = NetStreamPlayTransitions.SWAP;
                this._netStream.play2(_local3);
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE:
                    if (((this._transitionInProgress) && ((this._activeTransitionIndex > INVALID_TRANSITION_INDEX)))){
                        this._lastTransitionIndex = this._activeTransitionIndex;
                        this._lastTransitionStreamName = this._activeTransitionStreamName;
                        this._transitionInProgress = false;
                        this._activeTransitionIndex = INVALID_TRANSITION_INDEX;
                        this._activeTransitionStreamName = null;
                        setSwitching(false, this._lastTransitionIndex);
                    };
                    break;
            };
        }
        private function prepareStreamName(_arg1:String):String{
            if (((!((_arg1 == null))) && ((_arg1.indexOf("?") >= 0)))){
                return (_arg1.substr(0, _arg1.indexOf("?")));
            };
            return (_arg1);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.media.*;

    public class StreamingXMLResource extends MediaResourceBase {

        private var _manifest:String;
        private var _url:String;
        private var _clipStartTime:Number;
        private var _clipEndTime:Number;

        public function StreamingXMLResource(_arg1:String, _arg2:String=null, _arg3:Number=NaN, _arg4:Number=NaN){
            var _local5:XML;
            var _local6:Namespace;
            var _local7:String;
            super();
            this._manifest = _arg1;
            if (_arg2 != null){
                this._url = _arg2;
            } else {
                _local5 = new XML(_arg1);
                _local6 = _local5.namespace();
                _local7 = _local5._local6::baseURL.text();
                if (_local7 != null){
                    this._url = _local7;
                } else {
                    throw (new Error("The baseURL was not specified neither via the baseURL parameter, nor via the manifest <baseURL> tag."));
                };
            };
            if (this._url != null){
                if (this._url.charAt((this._url.length - 1)) != "/"){
                    this._url = (this._url + "/");
                };
                this._url = (this._url + "manifest.f4m");
            };
            this._clipStartTime = _arg3;
            this._clipEndTime = _arg4;
        }
        public function get clipStartTime():Number{
            return (this._clipStartTime);
        }
        public function set clipStartTime(_arg1:Number):void{
            this._clipStartTime = _arg1;
        }
        public function get clipEndTime():Number{
            return (this._clipEndTime);
        }
        public function set clipEndTime(_arg1:Number):void{
            this._clipEndTime = _arg1;
        }
        public function get manifest():String{
            return (this._manifest);
        }
        public function get url():String{
            return (this._url);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public class StreamingItem {

        private var _type:String = null;
        private var _streamName:String = null;
        private var _bitrate:Number;
        private var _info:Object = null;

        public function StreamingItem(_arg1:String, _arg2:String, _arg3:Number=0, _arg4:Object=null){
            this._type = _arg1;
            this._streamName = _arg2;
            this._bitrate = _arg3;
            this._info = (((_arg4 == null)) ? new Object() : _arg4);
        }
        public function get type():String{
            return (this._type);
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function get info():Object{
            return (this._info);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.traits.*;

    public class ModifiableTimeTrait extends TimeTrait {

        public function ModifiableTimeTrait(_arg1:Number=NaN){
            super(_arg1);
        }
        public function set duration(_arg1:Number):void{
            super.setDuration(_arg1);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import flash.utils.*;

    public dynamic class NetClient extends Proxy {

        private var handlers:Dictionary;

        public function NetClient(){
            this.handlers = new Dictionary();
            super();
        }
        public function addHandler(_arg1:String, _arg2:Function, _arg3:int=0):void{
            var _local5:Boolean;
            var _local6:int;
            var _local7:Object;
            var _local4:Array = ((this.handlers.hasOwnProperty(_arg1)) ? this.handlers[_arg1] : this.handlers[_arg1] = []);
            if (_local4.indexOf(_arg2) == -1){
                _local5 = false;
                _arg3 = Math.max(0, _arg3);
                if (_arg3 > 0){
                    _local6 = 0;
                    while (_local6 < _local4.length) {
                        _local7 = _local4[_local6];
                        if (_local7.priority < _arg3){
                            _local4.splice(_local6, 0, {
                                handler:_arg2,
                                priority:_arg3
                            });
                            _local5 = true;
                            break;
                        };
                        _local6++;
                    };
                };
                if (!_local5){
                    _local4.push({
                        handler:_arg2,
                        priority:_arg3
                    });
                };
            };
        }
        public function removeHandler(_arg1:String, _arg2:Function):void{
            var _local3:Array;
            var _local4:int;
            var _local5:Object;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local3 = this.handlers[_arg1];
                _local4 = 0;
                while (_local4 < _local3.length) {
                    _local5 = _local3[_local4];
                    if (_local5.handler == _arg2){
                        _local3.splice(_local4, 1);
                        break;
                    };
                    _local4++;
                };
            };
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function callProperty(_arg1, ... _args){
            return (this.invokeHandlers(_arg1, _args));
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function getProperty(_arg1){
            var result:* = undefined;
            var name:* = _arg1;
            if (this.handlers.hasOwnProperty(name)){
                result = function (){
                    return (invokeHandlers(arguments.callee.name, arguments));
                };
                result.name = name;
            };
            return (result);
        }
        override "http://www.adobe.com/2006/actionscript/flash/proxy"?? function hasProperty(_arg1):Boolean{
            return (this.handlers.hasOwnProperty(_arg1));
        }
        private function invokeHandlers(_arg1:String, _arg2:Array){
            var _local3:Array;
            var _local4:Array;
            var _local5:Object;
            if (this.handlers.hasOwnProperty(_arg1)){
                _local3 = [];
                _local4 = this.handlers[_arg1];
                for each (_local5 in _local4) {
                    _local3.push(_local5.handler.apply(null, _arg2));
                };
            };
            return (_local3);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net.metrics {
    import org.osmf.utils.*;

    public class MetricFactoryItem {

        private var _type:String;
        private var _metricCreationFunction:Function;

        public function MetricFactoryItem(_arg1:String, _arg2:Function){
            if ((((_arg1 == null)) || ((_arg2 == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this._type = _arg1;
            this._metricCreationFunction = _arg2;
        }
        public function get type():String{
            return (this._type);
        }
        public function get metricCreationFunction():Function{
            return (this._metricCreationFunction);
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class BufferLengthMetric extends MetricBase {

        public function BufferLengthMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.BUFFER_LENGTH);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getLatestQoSInfo();
            if (((!(isNaN(_local1.bufferLength))) && ((_local1.bufferLength >= 0)))){
                return (new MetricValue(_local1.bufferLength, true));
            };
            return (new MetricValue(undefined, false));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;
    import flash.errors.*;

    public class MetricBase {

        private var _type:String = null;
        private var lastMachineTime:Number = NaN;
        private var lastValue:MetricValue;
        private var _qosInfoHistory:QoSInfoHistory;

        public function MetricBase(_arg1:QoSInfoHistory, _arg2:String){
            if (_arg1 == null){
                throw (new ArgumentError("qosInfoHistory cannot be null."));
            };
            this._qosInfoHistory = _arg1;
            this._type = _arg2;
            this.lastValue = new MetricValue(undefined, false);
        }
        public function get type():String{
            return (this._type);
        }
        final public function get value():MetricValue{
            return (this.getValue());
        }
        function getValue():MetricValue{
            var _local1:Vector.<QoSInfo> = this._qosInfoHistory.getHistory();
            if (_local1.length > 0){
                if (_local1[0].timestamp != this.lastMachineTime){
                    this.lastValue = this.getValueForced();
                    this.lastMachineTime = _local1[0].timestamp;
                };
                return (this.lastValue);
            };
            return (new MetricValue(undefined, false));
        }
        protected function getValueForced():MetricValue{
            throw (new IllegalOperationError("The getValueForced() method must be overridden by the derived class."));
        }
        protected function get qosInfoHistory():QoSInfoHistory{
            return (this._qosInfoHistory);
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class BandwidthMetric extends MetricBase {

        private var _weights:Vector.<Number>;

        public function BandwidthMetric(_arg1:QoSInfoHistory, _arg2:Vector.<Number>){
            super(_arg1, MetricType.BANDWIDTH);
            ABRUtils.validateWeights(_arg2);
            this._weights = _arg2.slice();
        }
        public function get weights():Vector.<Number>{
            return (this._weights);
        }
        override protected function getValueForced():MetricValue{
            var _local5:FragmentDetails;
            var _local6:Number;
            var _local1:Vector.<QoSInfo> = qosInfoHistory.getHistory(this._weights.length);
            var _local2:Number = 0;
            var _local3:Number = 0;
            var _local4:uint;
            while (_local4 < _local1.length) {
                _local5 = _local1[_local4].lastDownloadedFragmentDetails;
                _local6 = (_local5.size / _local5.downloadDuration);
                _local2 = (_local2 + (_local6 * this._weights[_local4]));
                _local3 = (_local3 + this._weights[_local4]);
                _local4++;
            };
            _local2 = (_local2 / _local3);
            return (new MetricValue(_local2, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class FPSMetric extends MetricBase {

        public function FPSMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.FPS);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getLatestQoSInfo();
            if (((isNaN(_local1.maxFPS)) || ((_local1.maxFPS == 0)))){
                return (new MetricValue(undefined, false));
            };
            return (new MetricValue(_local1.maxFPS, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class CurrentStatusMetric extends MetricBase {

        public function CurrentStatusMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.CURRENT_STATUS);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getLatestQoSInfo();
            var _local2:Vector.<uint> = new Vector.<uint>();
            _local2.push(_local1.currentIndex);
            _local2.push(_local1.actualIndex);
            return (new MetricValue(_local2, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class RecentSwitchMetric extends MetricBase {

        public function RecentSwitchMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.RECENT_SWITCH);
        }
        override protected function getValueForced():MetricValue{
            var _local3:FragmentDetails;
            var _local4:FragmentDetails;
            var _local1:Vector.<QoSInfo> = qosInfoHistory.getHistory(2);
            var _local2:int;
            if (_local1.length >= 2){
                _local3 = _local1[0].lastDownloadedFragmentDetails;
                _local4 = _local1[1].lastDownloadedFragmentDetails;
                if ((((_local3 == null)) || ((_local4 == null)))){
                    return (new MetricValue(undefined, false));
                };
                _local2 = (_local3.index - _local4.index);
            } else {
                return (new MetricValue(undefined, false));
            };
            return (new MetricValue(_local2, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class DefaultMetricFactory extends MetricFactory {

        public function DefaultMetricFactory(_arg1:QoSInfoHistory){
            super(_arg1);
            this.init();
        }
        private function init():void{
            addItem(new MetricFactoryItem(MetricType.ACTUAL_BITRATE, function (_arg1:QoSInfoHistory, _arg2:uint=5):MetricBase{
                return (new ActualBitrateMetric(_arg1, _arg2));
            }));
            addItem(new MetricFactoryItem(MetricType.FRAGMENT_COUNT, function (_arg1:QoSInfoHistory):MetricBase{
                return (new FragmentCountMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.AVAILABLE_QUALITY_LEVELS, function (_arg1:QoSInfoHistory):MetricBase{
                return (new AvailableQualityLevelsMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.CURRENT_STATUS, function (_arg1:QoSInfoHistory):MetricBase{
                return (new CurrentStatusMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.BANDWIDTH, function (_arg1:QoSInfoHistory, _arg2:Vector.<Number>):MetricBase{
                return (new BandwidthMetric(_arg1, _arg2));
            }));
            addItem(new MetricFactoryItem(MetricType.FPS, function (_arg1:QoSInfoHistory):MetricBase{
                return (new FPSMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.DROPPED_FPS, function (_arg1:QoSInfoHistory, _arg2:Number=10):MetricBase{
                return (new DroppedFPSMetric(_arg1, _arg2));
            }));
            addItem(new MetricFactoryItem(MetricType.BUFFER_OCCUPATION_RATIO, function (_arg1:QoSInfoHistory):MetricBase{
                return (new BufferOccupationRatioMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.BUFFER_LENGTH, function (_arg1:QoSInfoHistory):MetricBase{
                return (new BufferLengthMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.BUFFER_FRAGMENTS, function (_arg1:QoSInfoHistory):MetricBase{
                return (new BufferFragmentsMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.EMPTY_BUFFER, function (_arg1:QoSInfoHistory):MetricBase{
                return (new EmptyBufferMetric(_arg1));
            }));
            addItem(new MetricFactoryItem(MetricType.RECENT_SWITCH, function (_arg1:QoSInfoHistory):MetricBase{
                return (new RecentSwitchMetric(_arg1));
            }));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import flash.utils.*;

    public class MetricRepository {

        private var metrics:Dictionary;
        private var lastKey:String;
        private var lastKeyByteArray:ByteArray;
        private var _metricFactory:MetricFactory = null;

        public function MetricRepository(_arg1:MetricFactory){
            this.metrics = new Dictionary();
            if (_arg1 == null){
                throw (new ArgumentError("The metricFactory should not be null!"));
            };
            this._metricFactory = _arg1;
        }
        public function get metricFactory():MetricFactory{
            return (this._metricFactory);
        }
        public function getMetric(_arg1:String, ... _args):MetricBase{
            var _local5:Array;
            var _local6:MetricBase;
            var _local3:int = getTimer();
            var _local4:Array = _args.slice();
            _local4.splice(0, 0, _arg1);
            if (this.metrics[_arg1] == null){
                this.metrics[_arg1] = new Vector.<Array>();
            };
            for each (_local5 in this.metrics[_arg1]) {
                if (this.match(_local5.slice(1), _local4)){
                    return (_local5[0]);
                };
            };
            _local6 = this._metricFactory.buildMetric.apply(null, _local4);
            _local4.splice(0, 0, _local6);
            this.metrics[_arg1].push(_local4);
            return (_local6);
        }
        private function match(_arg1, _arg2):Boolean{
            var _local3:uint;
            if (_arg1 == _arg2){
                return (true);
            };
            if ((((_arg1 == null)) && ((_arg2 == null)))){
                return (true);
            };
            if ((((((((_arg1 is Number)) && ((_arg2 is Number)))) && (isNaN(_arg1)))) && (isNaN(_arg2)))){
                return (true);
            };
            if (((((this.isVector(_arg1)) && (this.isVector(_arg2)))) || ((((_arg1 is Array)) && ((_arg2 is Array)))))){
                if (_arg1.length != _arg2.length){
                    return (false);
                };
                _local3 = 0;
                while (_local3 < _arg1.length) {
                    if (!this.match(_arg1[_local3], _arg2[_local3])){
                        return (false);
                    };
                    _local3++;
                };
                return (true);
            };
            return (false);
        }
        private function isVector(_arg1:Object):Boolean{
            var _local2:String = getQualifiedClassName(_arg1);
            return ((_local2.indexOf("__AS3__.vec::Vector.") === 0));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class AvailableQualityLevelsMetric extends MetricBase {

        public function AvailableQualityLevelsMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.AVAILABLE_QUALITY_LEVELS);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getHistory(1)[0];
            return (new MetricValue(_local1.availableQualityLevels, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class EmptyBufferMetric extends MetricBase {

        public function EmptyBufferMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.EMPTY_BUFFER);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getLatestQoSInfo();
            return (new MetricValue(_local1.emptyBufferOccurred, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class BufferFragmentsMetric extends MetricBase {

        public function BufferFragmentsMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.BUFFER_FRAGMENTS);
        }
        override protected function getValueForced():MetricValue{
            var _local5:QoSInfo;
            var _local1:Vector.<QoSInfo> = qosInfoHistory.getHistory();
            var _local2:Number = _local1[0].bufferLength;
            if (((isNaN(_local2)) || ((_local2 < 0)))){
                return (new MetricValue(undefined, false));
            };
            var _local3:Number = 0;
            var _local4:Number = 0;
            while (_local4 < _local1.length) {
                _local5 = _local1[_local4];
                _local3 = (_local3 + _local5.lastDownloadedFragmentDetails.playDuration);
                if (_local3 > _local2){
                    break;
                };
                _local4++;
            };
            return (new MetricValue(_local4, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.events.*;
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class MetricFactory {

        private var items:Dictionary;
        private var _numItems:Number;
        private var _qosInfoHistory:QoSInfoHistory;

        public function MetricFactory(_arg1:QoSInfoHistory){
            this._qosInfoHistory = _arg1;
            this.items = new Dictionary();
            this._numItems = 0;
        }
        public function addItem(_arg1:MetricFactoryItem):void{
            if ((((_arg1 == null)) || ((_arg1.type == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (this.items[_arg1.type] == null){
                this._numItems++;
            };
            this.items[_arg1.type] = _arg1;
        }
        public function removeItem(_arg1:MetricFactoryItem):void{
            if ((((_arg1 == null)) || ((_arg1.type == null)))){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (this.items[_arg1.type] != null){
                this._numItems--;
            };
            this.items[_arg1.type] = null;
        }
        public function getItems():Vector.<MetricFactoryItem>{
            var _local2:MetricFactoryItem;
            var _local1:Vector.<MetricFactoryItem> = new Vector.<MetricFactoryItem>();
            for each (_local2 in this.items) {
                _local1.push(_local2);
            };
            return (_local1);
        }
        public function getItem(_arg1:String):MetricFactoryItem{
            return (this.items[_arg1]);
        }
        public function get numItems():Number{
            return (this._numItems);
        }
        public function buildMetric(_arg1:String, ... _args):MetricBase{
            if (this.items[_arg1] == null){
                throw (new MetricError(MetricErrorCodes.INVALID_METRIC_TYPE));
            };
            var _local3:MetricFactoryItem = (this.items[_arg1] as MetricFactoryItem);
            _args.splice(0, 0, this._qosInfoHistory);
            return (_local3.metricCreationFunction.apply(null, _args));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {

    public class MetricValue {

        private var _value;
        private var _valid:Boolean;

        public function MetricValue(_arg1, _arg2:Boolean=true){
            this._value = _arg1;
            this._valid = _arg2;
        }
        public function get value(){
            return (this._value);
        }
        public function get valid():Boolean{
            return (this._valid);
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {

    public final class MetricType {

        public static const FRAGMENT_COUNT:String = "org.osmf.net.metrics.fragmentCount";
        public static const BANDWIDTH:String = "org.osmf.net.metrics.bandwidth";
        public static const AVAILABLE_QUALITY_LEVELS:String = "org.osmf.net.metrics.availableQualityLevels";
        public static const CURRENT_STATUS:String = "org.osmf.net.metrics.currentStatus";
        public static const ACTUAL_BITRATE:String = "org.osmf.net.metrics.actualBitrate";
        public static const FPS:String = "org.osmf.net.metrics.fps";
        public static const DROPPED_FPS:String = "org.osmf.net.metrics.droppedFPS";
        public static const BUFFER_OCCUPATION_RATIO:String = "org.osmf.net.metrics.bufferOccupationRatio";
        public static const BUFFER_LENGTH:String = "org.osmf.net.metrics.bufferLength";
        public static const BUFFER_FRAGMENTS:String = "org.osmf.net.metrics.bufferFragments";
        public static const EMPTY_BUFFER:String = "org.osmf.net.metrics.emptyBuffer";
        public static const RECENT_SWITCH:String = "org.osmf.net.metrics.recentSwitch";

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class BufferOccupationRatioMetric extends MetricBase {

        public function BufferOccupationRatioMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.BUFFER_OCCUPATION_RATIO);
        }
        override protected function getValueForced():MetricValue{
            var _local1:QoSInfo = qosInfoHistory.getLatestQoSInfo();
            if (((((((!(isNaN(_local1.bufferLength))) && (!(isNaN(_local1.bufferTime))))) && ((_local1.bufferTime > 0)))) && ((_local1.bufferLength >= 0)))){
                return (new MetricValue((_local1.bufferLength / _local1.bufferTime), true));
            };
            return (new MetricValue(undefined, false));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import org.osmf.net.qos.*;

    public class FragmentCountMetric extends MetricBase {

        public function FragmentCountMetric(_arg1:QoSInfoHistory){
            super(_arg1, MetricType.FRAGMENT_COUNT);
        }
        override protected function getValueForced():MetricValue{
            return (new MetricValue(qosInfoHistory.length, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class ActualBitrateMetric extends MetricBase {

        private var _maxFragments:uint;

        public function ActualBitrateMetric(_arg1:QoSInfoHistory, _arg2:uint=5){
            super(_arg1, MetricType.ACTUAL_BITRATE);
            this.maxFragments = _arg2;
        }
        public function get maxFragments():uint{
            return (this._maxFragments);
        }
        public function set maxFragments(_arg1:uint):void{
            if (_arg1 < 1){
                throw (new ArgumentError("Invalid value for 'maxFragments'."));
            };
            this._maxFragments = _arg1;
        }
        override protected function getValueForced():MetricValue{
            var _local5:QoSInfo;
            var _local7:FragmentDetails;
            var _local1:Vector.<QoSInfo> = qosInfoHistory.getHistory(this._maxFragments);
            var _local2:int = _local1[0].actualIndex;
            var _local3:Number = 0;
            var _local4:Number = 0;
            for each (_local5 in _local1) {
                if (_local5.lastDownloadedFragmentDetails.index == _local2){
                    _local7 = _local5.lastDownloadedFragmentDetails;
                    _local3 = (_local3 + _local7.size);
                    _local4 = (_local4 + _local7.playDuration);
                };
            };
            if (_local4 == 0){
                return (new MetricValue(undefined, false));
            };
            var _local6:Number = (((_local3 / _local4) * 8) / 1000);
            return (new MetricValue(_local6, true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net.metrics {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class DroppedFPSMetric extends MetricBase {

        private static const MINIMUM_CONTINUOUS_PLAYBACK_DURATION:Number = 1;
        private static const MINIMUM_TOTAL_PLAYBACK_DURATION:Number = 2;

        private var _desiredSampleLength:Number = 10;

        public function DroppedFPSMetric(_arg1:QoSInfoHistory, _arg2:Number=10){
            super(_arg1, MetricType.DROPPED_FPS);
            this.desiredSampleLength = _arg2;
        }
        public function get desiredSampleLength():Number{
            return (this._desiredSampleLength);
        }
        public function set desiredSampleLength(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                throw (new ArgumentError("Invalid desiredSampleLength"));
            };
            this._desiredSampleLength = _arg1;
        }
        override protected function getValueForced():MetricValue{
            var _local6:Vector.<PlaybackDetails>;
            var _local7:PlaybackDetails;
            var _local1:Vector.<QoSInfo> = qosInfoHistory.getHistory();
            var _local2:Number = 0;
            var _local3:Number = 0;
            var _local4:uint = _local1[0].currentIndex;
            var _local5:uint;
            while (_local5 < _local1.length) {
                _local6 = _local1[_local5].playbackDetailsRecord;
                for each (_local7 in _local6) {
                    if ((((_local7.duration < 0)) || ((_local7.droppedFrames < 0)))){
                        return (new MetricValue(undefined, false));
                    };
                    if ((((_local7.index == _local4)) && ((_local7.duration >= MINIMUM_CONTINUOUS_PLAYBACK_DURATION)))){
                        _local2 = (_local2 + _local7.duration);
                        _local3 = (_local3 + _local7.droppedFrames);
                        break;
                    };
                };
                if (_local2 >= this.desiredSampleLength){
                    break;
                };
                _local5++;
            };
            if (_local2 < MINIMUM_TOTAL_PLAYBACK_DURATION){
                return (new MetricValue(undefined, false));
            };
            return (new MetricValue((_local3 / _local2), true));
        }

    }
}//package org.osmf.net.metrics 
﻿package org.osmf.net {
    import __AS3__.vec.*;

    public class ABRUtils {

        public static function validateWeights(_arg1:Vector.<Number>, _arg2:int=-1):void{
            var _local4:Number;
            if (_arg1 == null){
                throw (new ArgumentError("The weights vector is null."));
            };
            if ((((_arg2 > -1)) && (!((_arg1.length == _arg2))))){
                throw (new ArgumentError("Invalid number of weights."));
            };
            var _local3:Boolean;
            for each (_local4 in _arg1) {
                if (((isNaN(_local4)) || ((_local4 < 0)))){
                    throw (new ArgumentError("Invalid weight in weights Vector."));
                };
                if (_local4 > 0){
                    _local3 = true;
                };
            };
            if (!_local3){
                throw (new ArgumentError("At least one weight must be greater than 0."));
            };
        }
        public static function roundNumber(_arg1:Number):Number{
            if (isNaN(_arg1)){
                return (_arg1);
            };
            return ((Math.round((_arg1 * 1000)) / 1000));
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.media.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class NetConnectionFactoryBase extends EventDispatcher {

        public function create(_arg1:URLResource):void{
            throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.FUNCTION_MUST_BE_OVERRIDDEN)));
        }
        public function closeNetConnection(_arg1:NetConnection):void{
            _arg1.close();
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.media.*;
    import __AS3__.vec.*;
    import flash.utils.*;

    public class StreamingURLResource extends URLResource {

        private var _streamType:String;
        private var _clipStartTime:Number;
        private var _clipEndTime:Number;
        private var _connectionArguments:Vector.<Object>;
        private var _drmContentData:ByteArray;
        private var _urlIncludesFMSApplicationInstance:Boolean = false;
        private var _alternativeAudioStreamItems:Vector.<StreamingItem> = null;

        public function StreamingURLResource(_arg1:String, _arg2:String=null, _arg3:Number=NaN, _arg4:Number=NaN, _arg5:Vector.<Object>=null, _arg6:Boolean=false, _arg7:ByteArray=null){
            this._streamType = ((_arg2) || (StreamType.RECORDED));
            this._clipStartTime = _arg3;
            this._clipEndTime = _arg4;
            this._urlIncludesFMSApplicationInstance = _arg6;
            this._drmContentData = _arg7;
            this._connectionArguments = _arg5;
            super(_arg1);
        }
        public function get streamType():String{
            return (this._streamType);
        }
        public function set streamType(_arg1:String):void{
            this._streamType = _arg1;
        }
        public function get clipStartTime():Number{
            return (this._clipStartTime);
        }
        public function set clipStartTime(_arg1:Number):void{
            this._clipStartTime = _arg1;
        }
        public function get clipEndTime():Number{
            return (this._clipEndTime);
        }
        public function set clipEndTime(_arg1:Number):void{
            this._clipEndTime = _arg1;
        }
        public function get connectionArguments():Vector.<Object>{
            return (this._connectionArguments);
        }
        public function set connectionArguments(_arg1:Vector.<Object>):void{
            this._connectionArguments = _arg1;
        }
        public function get drmContentData():ByteArray{
            return (this._drmContentData);
        }
        public function set drmContentData(_arg1:ByteArray):void{
            this._drmContentData = _arg1;
        }
        public function get urlIncludesFMSApplicationInstance():Boolean{
            return (this._urlIncludesFMSApplicationInstance);
        }
        public function set urlIncludesFMSApplicationInstance(_arg1:Boolean):void{
            this._urlIncludesFMSApplicationInstance = _arg1;
        }
        public function get alternativeAudioStreamItems():Vector.<StreamingItem>{
            if (this._alternativeAudioStreamItems == null){
                this._alternativeAudioStreamItems = new Vector.<StreamingItem>();
            };
            return (this._alternativeAudioStreamItems);
        }
        public function set alternativeAudioStreamItems(_arg1:Vector.<StreamingItem>):void{
            this._alternativeAudioStreamItems = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net.rules {

    public final class RuleType {

        public static const BANDWIDTH:String = "org.osmf.net.rules.bandwidth";
        public static const DROPPED_FPS:String = "org.osmf.net.rules.droppedFPS";
        public static const BUFFER_BANDWIDTH:String = "org.osmf.net.rules.bufferBandwidth";
        public static const EMPTY_BUFFER:String = "org.osmf.net.rules.emptyBuffer";
        public static const AFTER_UP_SWITCH_BUFFER_BANDWIDTH:String = "org.osmf.net.rules.afterUpSwitchBufferBandwidth";

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;
    import org.osmf.net.metrics.*;

    public class RuleUtils {

        public static function computeActualBitrate(_arg1:MetricBase, _arg2:MetricBase, _arg3:MetricBase):Number{
            var _local5:MetricValue;
            var _local6:MetricValue;
            var _local7:uint;
            var _local8:Vector.<QualityLevel>;
            var _local4:MetricValue = _arg1.value;
            if (_local4.valid){
                return ((_local4.value as Number));
            };
            _local5 = _arg2.value;
            _local6 = _arg3.value;
            if (((!(_local5.valid)) || (!(_local6.valid)))){
                return (Number.NaN);
            };
            _local7 = (_local6.value as Vector.<uint>)[1];
            _local8 = (_local5.value as Vector.<QualityLevel>);
            return (_local8[_local7].bitrate);
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import org.osmf.net.metrics.*;

    public class EmptyBufferRule extends RuleBase {

        private var _scaleDownFactor:Number;
        private var emptyBufferInterruptionMetric:MetricBase;
        private var actualBitrateMetric:MetricBase;
        private var currentStatusMetric:MetricBase;
        private var availableQualityLevelsMetric:MetricBase;

        public function EmptyBufferRule(_arg1:MetricRepository, _arg2:Number){
            super(_arg1);
            this.scaleDownFactor = _arg2;
        }
        public function get scaleDownFactor():Number{
            return (this._scaleDownFactor);
        }
        public function set scaleDownFactor(_arg1:Number):void{
            if (((((isNaN(_arg1)) || ((_arg1 < 0)))) || ((_arg1 > 1)))){
                throw (new ArgumentError("Invalid scaleDownFactor"));
            };
            this._scaleDownFactor = _arg1;
        }
        override public function getRecommendation():Recommendation{
            if (this.emptyBufferInterruptionMetric == null){
                this.emptyBufferInterruptionMetric = metricRepository.getMetric(MetricType.EMPTY_BUFFER);
            };
            var _local1:MetricValue = this.emptyBufferInterruptionMetric.value;
            if (((!(_local1.valid)) || ((_local1.value == false)))){
                return (new Recommendation(RuleType.EMPTY_BUFFER, 0, 0));
            };
            if (this.actualBitrateMetric == null){
                this.actualBitrateMetric = metricRepository.getMetric(MetricType.ACTUAL_BITRATE);
            };
            if (this.availableQualityLevelsMetric == null){
                this.availableQualityLevelsMetric = metricRepository.getMetric(MetricType.AVAILABLE_QUALITY_LEVELS);
            };
            if (this.currentStatusMetric == null){
                this.currentStatusMetric = metricRepository.getMetric(MetricType.CURRENT_STATUS);
            };
            var _local2:Number = RuleUtils.computeActualBitrate(this.actualBitrateMetric, this.availableQualityLevelsMetric, this.currentStatusMetric);
            if (isNaN(_local2)){
                return (new Recommendation(RuleType.EMPTY_BUFFER, 0, 1));
            };
            var _local3:Number = (_local2 * this.scaleDownFactor);
            return (new Recommendation(RuleType.EMPTY_BUFFER, _local3, 1));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {

    public class Recommendation {

        private var _ruleType:String;
        private var _bitrate:Number;
        private var _confidence:Number;

        public function Recommendation(_arg1:String, _arg2:Number, _arg3:Number){
            if (_arg1 == null){
                throw (new ArgumentError("ruleType cannot be null."));
            };
            if (((((isNaN(_arg3)) || ((_arg3 < 0)))) || ((_arg3 > 1)))){
                throw (new ArgumentError("Invalid confidence!"));
            };
            if (((isNaN(_arg2)) || ((_arg2 < 0)))){
                throw (new ArgumentError("Invalid bitrate!"));
            };
            this._ruleType = _arg1;
            this._bitrate = _arg2;
            this._confidence = _arg3;
        }
        public function get ruleType():String{
            return (this._ruleType);
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function get confidence():Number{
            return (this._confidence);
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import __AS3__.vec.*;
    import org.osmf.net.metrics.*;

    public class DroppedFPSRule extends RuleBase {

        private var _minimumFPS:Number;
        private var _maximumDroppedFPSRatio:Number;
        private var _desiredSampleLength:Number;
        private var actualBitrateMetric:MetricBase;
        private var currentStatusMetric:MetricBase;
        private var availableQualityLevelsMetric:MetricBase;
        private var fpsMetric:MetricBase;
        private var droppedFPSMetric:MetricBase;

        public function DroppedFPSRule(_arg1:MetricRepository, _arg2:Number, _arg3:Number){
            super(_arg1);
            this.desiredSampleLength = _arg2;
            this.maximumDroppedFPSRatio = _arg3;
        }
        public function get desiredSampleLength():Number{
            return (this._desiredSampleLength);
        }
        public function set desiredSampleLength(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 <= 0)))){
                throw (new ArgumentError("Invalid desiredSampleLength"));
            };
            this._desiredSampleLength = _arg1;
        }
        public function get maximumDroppedFPSRatio():Number{
            return (this._maximumDroppedFPSRatio);
        }
        public function set maximumDroppedFPSRatio(_arg1:Number):void{
            if (((((isNaN(_arg1)) || ((_arg1 < 0)))) || ((_arg1 > 1)))){
                throw (new ArgumentError("Invalid maximumDroppedFPSRatio"));
            };
            this._maximumDroppedFPSRatio = _arg1;
        }
        override public function getRecommendation():Recommendation{
            if (this.actualBitrateMetric == null){
                this.actualBitrateMetric = metricRepository.getMetric(MetricType.ACTUAL_BITRATE);
            };
            if (this.currentStatusMetric == null){
                this.currentStatusMetric = metricRepository.getMetric(MetricType.CURRENT_STATUS);
            };
            var _local1:MetricValue = this.actualBitrateMetric.value;
            var _local2:MetricValue = this.currentStatusMetric.value;
            if (!_local2.valid){
                return (new Recommendation(RuleType.DROPPED_FPS, 0, 0));
            };
            var _local3:uint = (_local2.value as Vector.<uint>)[0];
            var _local4:uint = (_local2.value as Vector.<uint>)[1];
            if (_local3 != _local4){
                return (new Recommendation(RuleType.DROPPED_FPS, 0, 0));
            };
            if (this.availableQualityLevelsMetric == null){
                this.availableQualityLevelsMetric = metricRepository.getMetric(MetricType.AVAILABLE_QUALITY_LEVELS);
            };
            var _local5:Number = RuleUtils.computeActualBitrate(this.actualBitrateMetric, this.availableQualityLevelsMetric, this.currentStatusMetric);
            if (isNaN(_local5)){
                return (new Recommendation(RuleType.DROPPED_FPS, 0, 0));
            };
            if (this.fpsMetric == null){
                this.fpsMetric = metricRepository.getMetric(MetricType.FPS);
            };
            if (this.droppedFPSMetric == null){
                this.droppedFPSMetric = metricRepository.getMetric(MetricType.DROPPED_FPS, this._desiredSampleLength);
            };
            var _local6:MetricValue = this.fpsMetric.value;
            var _local7:MetricValue = this.droppedFPSMetric.value;
            if (((!(_local6.valid)) || (!(_local7.valid)))){
                return (new Recommendation(RuleType.DROPPED_FPS, 0, 0));
            };
            var _local8:Number = _local7.value;
            var _local9:Number = _local6.value;
            if (_local8 > _local9){
                _local8 = _local9;
            };
            var _local10:Number = (_local5 * (1 - (_local8 / _local9)));
            var _local11:Number = 0;
            if ((((this._maximumDroppedFPSRatio == 0)) && ((_local8 == 0)))){
                return (new Recommendation(RuleType.DROPPED_FPS, 0, 0));
            };
            if ((_local8 / _local9) > this._maximumDroppedFPSRatio){
                _local11 = 1;
            } else {
                _local11 = (_local8 / (_local9 * this._maximumDroppedFPSRatio));
            };
            return (new Recommendation(RuleType.DROPPED_FPS, _local10, _local11));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import __AS3__.vec.*;
    import org.osmf.net.metrics.*;

    public class BufferBandwidthRule extends BandwidthRule {

        private var _bufferFragmentsThreshold:Number;
        private var actualBitrateMetric:MetricBase;
        private var bufferFragmentsMetric:MetricBase;
        private var currentStatusMetric:MetricBase;
        private var availableQualityLevelsMetric:MetricBase;

        public function BufferBandwidthRule(_arg1:MetricRepository, _arg2:Vector.<Number>, _arg3:Number){
            super(_arg1, _arg2);
            this.bufferFragmentsThreshold = _arg3;
        }
        public function get bufferFragmentsThreshold():Number{
            return (this._bufferFragmentsThreshold);
        }
        public function set bufferFragmentsThreshold(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                throw (new ArgumentError("Invalid bufferLengthThreshold"));
            };
            this._bufferFragmentsThreshold = _arg1;
        }
        override public function getRecommendation():Recommendation{
            var _local4:Number;
            var _local5:MetricValue;
            var _local6:Number;
            var _local1:Recommendation = super.getRecommendation();
            var _local2:Number = _local1.bitrate;
            var _local3:Number = _local1.confidence;
            _local1 = null;
            if (_local3 > 0){
                if (this.actualBitrateMetric == null){
                    this.actualBitrateMetric = metricRepository.getMetric(MetricType.ACTUAL_BITRATE);
                };
                if (this.availableQualityLevelsMetric == null){
                    this.availableQualityLevelsMetric = metricRepository.getMetric(MetricType.AVAILABLE_QUALITY_LEVELS);
                };
                if (this.currentStatusMetric == null){
                    this.currentStatusMetric = metricRepository.getMetric(MetricType.CURRENT_STATUS);
                };
                _local4 = RuleUtils.computeActualBitrate(this.actualBitrateMetric, this.availableQualityLevelsMetric, this.currentStatusMetric);
                if (isNaN(_local4)){
                    return (new Recommendation(RuleType.BUFFER_BANDWIDTH, 0, 0));
                };
                if (_local2 < _local4){
                    if (this.bufferFragmentsMetric == null){
                        this.bufferFragmentsMetric = metricRepository.getMetric(MetricType.BUFFER_FRAGMENTS);
                    };
                    _local5 = this.bufferFragmentsMetric.value;
                    if (_local5.valid){
                        _local6 = _local5.value;
                        if (_local6 > this._bufferFragmentsThreshold){
                            _local2 = _local4;
                        };
                    };
                };
            };
            return (new Recommendation(RuleType.BUFFER_BANDWIDTH, _local2, _local3));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import org.osmf.net.metrics.*;
    import flash.errors.*;

    public class RuleBase {

        protected var _metricRepository:MetricRepository;

        public function RuleBase(_arg1:MetricRepository){
            this._metricRepository = _arg1;
        }
        public function get metricRepository():MetricRepository{
            return (this._metricRepository);
        }
        public function getRecommendation():Recommendation{
            throw (new IllegalOperationError("The getRecommendation() method must be overridden by the derived class."));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.net.metrics.*;

    public class BandwidthRule extends RuleBase {

        private var _weights:Vector.<Number>;
        private var bandwidthMetric:MetricBase;
        private var fragmentCountMetric:MetricBase;

        public function BandwidthRule(_arg1:MetricRepository, _arg2:Vector.<Number>){
            super(_arg1);
            ABRUtils.validateWeights(_arg2);
            this._weights = _arg2.slice();
        }
        public function get weights():Vector.<Number>{
            return (this._weights);
        }
        override public function getRecommendation():Recommendation{
            if (this.bandwidthMetric == null){
                this.bandwidthMetric = _metricRepository.getMetric(MetricType.BANDWIDTH, this._weights);
            };
            if (this.fragmentCountMetric == null){
                this.fragmentCountMetric = _metricRepository.getMetric(MetricType.FRAGMENT_COUNT);
            };
            if (((!(this.bandwidthMetric.value.valid)) || (!(this.fragmentCountMetric.value.valid)))){
                return (new Recommendation(RuleType.BANDWIDTH, 0, 0));
            };
            var _local1:Number = (((this.bandwidthMetric.value.value as Number) / 1000) * 8);
            var _local2:uint = (this.fragmentCountMetric.value.value as uint);
            if (_local2 > this._weights.length){
                _local2 = this._weights.length;
            };
            var _local3:Number = 0;
            var _local4:Number = 0;
            var _local5:uint;
            while (_local5 < this._weights.length) {
                _local4 = (_local4 + this._weights[_local5]);
                if (_local5 < _local2){
                    _local3 = (_local3 + this._weights[_local5]);
                };
                _local5++;
            };
            _local3 = (_local3 / _local4);
            return (new Recommendation(RuleType.BANDWIDTH, _local1, _local3));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.rules {
    import __AS3__.vec.*;
    import org.osmf.net.metrics.*;

    public class AfterUpSwitchBufferBandwidthRule extends BufferBandwidthRule {

        private var _minBandwidthToBitrateRatio:Number;
        private var upSwitchMetric:MetricBase;
        private var actualBitrateMetric:MetricBase;
        private var availableQualityLevelsMetric:MetricBase;
        private var currentStatusMetric:MetricBase;

        public function AfterUpSwitchBufferBandwidthRule(_arg1:MetricRepository, _arg2:Number, _arg3:Number){
            super(_arg1, new <Number>[1], _arg2);
            this.minBandwidthToBitrateRatio = _arg3;
        }
        public function get minBandwidthToBitrateRatio():Number{
            return (this._minBandwidthToBitrateRatio);
        }
        public function set minBandwidthToBitrateRatio(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 < 0)))){
                throw (new ArgumentError("Invalid value for minBandwidthToBitrateRatio"));
            };
            this._minBandwidthToBitrateRatio = _arg1;
        }
        override public function getRecommendation():Recommendation{
            if (this.upSwitchMetric == null){
                this.upSwitchMetric = metricRepository.getMetric(MetricType.RECENT_SWITCH);
            };
            var _local1:MetricValue = this.upSwitchMetric.value;
            if (((!(_local1.valid)) || (((_local1.value as int) <= 0)))){
                return (new Recommendation(RuleType.AFTER_UP_SWITCH_BUFFER_BANDWIDTH, 0, 0));
            };
            var _local2:Recommendation = super.getRecommendation();
            if (_local2.confidence == 0){
                return (new Recommendation(RuleType.AFTER_UP_SWITCH_BUFFER_BANDWIDTH, 0, 0));
            };
            var _local3:Number = _local2.bitrate;
            if (this.actualBitrateMetric == null){
                this.actualBitrateMetric = metricRepository.getMetric(MetricType.ACTUAL_BITRATE);
            };
            if (this.availableQualityLevelsMetric == null){
                this.availableQualityLevelsMetric = metricRepository.getMetric(MetricType.AVAILABLE_QUALITY_LEVELS);
            };
            if (this.currentStatusMetric == null){
                this.currentStatusMetric = metricRepository.getMetric(MetricType.CURRENT_STATUS);
            };
            var _local4:Number = RuleUtils.computeActualBitrate(this.actualBitrateMetric, this.availableQualityLevelsMetric, this.currentStatusMetric);
            if (isNaN(_local4)){
                return (new Recommendation(RuleType.AFTER_UP_SWITCH_BUFFER_BANDWIDTH, 0, 0));
            };
            var _local5:Number = 0;
            if ((_local3 / _local4) < this.minBandwidthToBitrateRatio){
                _local5 = 1;
            };
            return (new Recommendation(RuleType.AFTER_UP_SWITCH_BUFFER_BANDWIDTH, _local3, _local5));
        }

    }
}//package org.osmf.net.rules 
﻿package org.osmf.net.dvr {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.dvr.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    class DVRCastDVRTrait extends DVRTrait {

        private var connection:NetConnection;
        private var stream:NetStream;
        private var streamInfo:DVRCastStreamInfo;
        private var recordingInfo:DVRCastRecordingInfo;
        private var streamInfoUpdateTimer:Timer;
        private var streamInfoRetriever:DVRCastStreamInfoRetriever;
        private var offset:Number;

        public function DVRCastDVRTrait(_arg1:NetConnection, _arg2:NetStream, _arg3:MediaResourceBase){
            if (((!((_arg1 == null))) && (!((_arg2 == null))))){
                this.stream = _arg2;
                this.streamInfo = (_arg3.getMetadataValue(DVRCastConstants.STREAM_INFO_KEY) as DVRCastStreamInfo);
                this.recordingInfo = (_arg3.getMetadataValue(DVRCastConstants.RECORDING_INFO_KEY) as DVRCastRecordingInfo);
                this.streamInfoRetriever = new DVRCastStreamInfoRetriever(_arg1, this.streamInfo.streamName);
                this.streamInfoRetriever.addEventListener(Event.COMPLETE, this.onStreamInfoRetrieverComplete);
                this.streamInfoUpdateTimer = new Timer(DVRCastConstants.STREAM_INFO_UPDATE_DELAY);
                this.streamInfoUpdateTimer.addEventListener(TimerEvent.TIMER, this.onStreamInfoUpdateTimer);
                this.streamInfoUpdateTimer.start();
                super(this.streamInfo.isRecording);
                this.updateProperties();
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
        }
        override protected function isRecordingChangeStart(_arg1:Boolean):void{
            if (_arg1){
                this.recordingInfo.startDuration = this.streamInfo.currentLength;
                this.recordingInfo.startTime = new Date();
            };
        }
        private function updateProperties():void{
            setIsRecording(this.streamInfo.isRecording);
        }
        private function onStreamInfoUpdateTimer(_arg1:TimerEvent):void{
            this.streamInfoRetriever.retrieve();
        }
        private function onStreamInfoRetrieverComplete(_arg1:Event):void{
            if (this.streamInfoRetriever.streamInfo != null){
                this.streamInfo.readFromDVRCastStreamInfo(this.streamInfoRetriever.streamInfo);
                this.updateProperties();
            } else {
                dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.DVRCAST_STREAM_INFO_RETRIEVAL_FAILED)));
            };
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import org.osmf.media.*;
    import flash.net.*;

    public class DVRCastNetStream extends NetStream {

        private var recordingInfo:DVRCastRecordingInfo;

        public function DVRCastNetStream(_arg1:NetConnection, _arg2:MediaResourceBase){
            super(_arg1);
            this.recordingInfo = (_arg2.getMetadataValue(DVRCastConstants.RECORDING_INFO_KEY) as DVRCastRecordingInfo);
        }
        override public function play(... _args):void{
            super.play(_args[0], this.recordingInfo.startOffset, -1);
        }
        override public function play2(_arg1:NetStreamPlayOptions):void{
            if (_arg1){
                _arg1.start = this.recordingInfo.startOffset;
                _arg1.len = -1;
            };
            super.play2(_arg1);
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.dvr.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    class DVRCastTimeTrait extends TimeTrait {

        private var durationUpdateTimer:Timer;
        private var oldDuration:Number;
        private var stream:NetStream;
        private var streamInfo:DVRCastStreamInfo;
        private var recordingInfo:DVRCastRecordingInfo;

        public function DVRCastTimeTrait(_arg1:NetConnection, _arg2:NetStream, _arg3:MediaResourceBase){
            super(NaN);
            if ((((_arg1 == null)) || ((_arg2 == null)))){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.stream = _arg2;
            _arg2.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            this.durationUpdateTimer = new Timer(DVRCastConstants.LOCAL_DURATION_UPDATE_INTERVAL);
            this.durationUpdateTimer.addEventListener(TimerEvent.TIMER, this.onDurationUpdateTimer);
            this.durationUpdateTimer.start();
            this.streamInfo = (_arg3.getMetadataValue(DVRCastConstants.STREAM_INFO_KEY) as DVRCastStreamInfo);
            this.recordingInfo = (_arg3.getMetadataValue(DVRCastConstants.RECORDING_INFO_KEY) as DVRCastRecordingInfo);
        }
        override public function get duration():Number{
            var _local1:Number;
            if (this.streamInfo.isRecording){
                _local1 = ((this.recordingInfo.startDuration - this.recordingInfo.startOffset) + ((new Date().time - this.recordingInfo.startTime.time) / 1000));
            } else {
                _local1 = (this.streamInfo.currentLength - this.recordingInfo.startOffset);
            };
            _local1 = ((isNaN(_local1)) ? NaN : Math.max(0, _local1));
            return (_local1);
        }
        override public function get currentTime():Number{
            return (this.stream.time);
        }
        private function onDurationUpdateTimer(_arg1:TimerEvent):void{
            var _local2:Number = this.duration;
            if (_local2 != this.oldDuration){
                this.oldDuration = _local2;
                dispatchEvent(new TimeEvent(TimeEvent.DURATION_CHANGE, false, false, _local2));
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            if (_arg1.info.code == "NetStream.Play.Stop"){
                if (this.durationUpdateTimer){
                    this.durationUpdateTimer.stop();
                };
                signalComplete();
            };
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import org.osmf.utils.*;
    import flash.errors.*;

    public class DVRCastStreamInfo {

        public var callTime:Date;
        public var offline:Boolean;
        public var beginOffset:Number;
        public var endOffset:Number;
        public var windowDuration:Number;
        public var recordingStart:Date;
        public var recordingEnd:Date;
        public var isRecording:Boolean;
        public var streamName:String;
        public var lastUpdate:Date;
        public var currentLength:Number;
        public var maxLength:Number;

        public function DVRCastStreamInfo(_arg1:Object):void{
            this.readFromDynamicObject(_arg1);
        }
        public function readFromDynamicObject(_arg1:Object):void{
            var value:* = _arg1;
            try {
                this.callTime = value.callTime;
                this.offline = value.offline;
                this.beginOffset = value.begOffset;
                this.endOffset = value.endOffset;
                this.windowDuration = value.windowDuration;
                this.recordingStart = value.startRec;
                this.recordingEnd = value.stopRec;
                this.isRecording = value.isRec;
                this.streamName = value.streamName;
                this.lastUpdate = value.lastUpdate;
                this.currentLength = value.currLen;
                this.maxLength = value.maxLen;
            } catch(e:Error) {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
        }
        public function readFromDVRCastStreamInfo(_arg1:DVRCastStreamInfo):void{
            var value:* = _arg1;
            try {
                this.callTime = value.callTime;
                this.offline = value.offline;
                this.beginOffset = value.beginOffset;
                this.endOffset = value.endOffset;
                this.windowDuration = value.windowDuration;
                this.recordingStart = value.recordingStart;
                this.recordingEnd = value.recordingEnd;
                this.isRecording = value.isRecording;
                this.streamName = value.streamName;
                this.lastUpdate = value.lastUpdate;
                this.currentLength = value.currentLength;
                this.maxLength = value.maxLength;
            } catch(e:Error) {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
        }
        public function toString():String{
            return (((((((((((((((((((((((("callTime: " + this.callTime) + "\noffline: ") + this.offline) + "\nbeginOffset: ") + this.beginOffset) + "\nendOffset: ") + this.endOffset) + "\nwindowDuration: ") + this.windowDuration) + "\nrecordingStart: ") + this.recordingStart) + "\nrecordingEnd: ") + this.recordingEnd) + "\nisRecording: ") + this.isRecording) + "\nstreamName: ") + this.streamName) + "\nlastUpdate: ") + this.lastUpdate) + "\ncurrentLength: ") + this.currentLength) + "\nmaxLength: ") + this.maxLength));
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import org.osmf.net.*;
    import flash.net.*;
    import org.osmf.net.rtmpstreaming.*;

    public class DVRCastNetLoader extends RTMPDynamicStreamingNetLoader {

        public function DVRCastNetLoader(_arg1:DVRCastNetConnectionFactory=null){
            if (_arg1 == null){
                _arg1 = new DVRCastNetConnectionFactory();
            };
            super(_arg1);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local2:Boolean;
            var _local3:StreamingURLResource;
            if (super.canHandleResource(_arg1)){
                _local3 = (_arg1 as StreamingURLResource);
                if (_local3 != null){
                    _local2 = (((_local3.streamType == StreamType.DVR)) && (NetStreamUtils.isRTMPStream(_local3.url)));
                };
            };
            return (_local2);
        }
        override protected function createNetStream(_arg1:NetConnection, _arg2:URLResource):NetStream{
            return (new DVRCastNetStream(_arg1, _arg2));
        }
        override protected function processFinishLoading(_arg1:NetStreamLoadTrait):void{
            _arg1.setTrait(new DVRCastDVRTrait(_arg1.connection, _arg1.netStream, _arg1.resource));
            _arg1.setTrait(new DVRCastTimeTrait(_arg1.connection, _arg1.netStream, _arg1.resource));
            updateLoadTrait(_arg1, LoadState.READY);
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import flash.utils.*;

    public class DVRCastNetConnectionFactory extends NetConnectionFactoryBase {

        private var innerFactory:NetConnectionFactoryBase;
        private var subscribedStreams:Dictionary;

        public function DVRCastNetConnectionFactory(_arg1:NetConnectionFactoryBase=null){
            this.subscribedStreams = new Dictionary();
            this.innerFactory = ((_arg1) || (new NetConnectionFactory()));
            this.innerFactory.addEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, this.onCreationComplete);
            this.innerFactory.addEventListener(NetConnectionFactoryEvent.CREATION_ERROR, this.onCreationError);
            super();
        }
        override public function create(_arg1:URLResource):void{
            this.innerFactory.create(_arg1);
        }
        override public function closeNetConnection(_arg1:NetConnection):void{
            var _local2:String = this.subscribedStreams[_arg1];
            if (_local2 != null){
                _arg1.call(DVRCastConstants.RPC_UNSUBSCRIBE, null, _local2);
                delete this.subscribedStreams[_arg1];
            };
            this.innerFactory.closeNetConnection(_arg1);
        }
        private function onCreationComplete(_arg1:NetConnectionFactoryEvent):void{
            var urlResource:* = null;
            var netConnection:* = null;
            var streamNames:* = null;
            var totalRpcSubscribeInvocation:* = 0;
            var streamingResource:* = null;
            var onStreamSubscriptionResult:* = null;
            var onStreamInfoRetrieverComplete:* = null;
            var onServerCallError:* = null;
            var items:* = null;
            var i:* = 0;
            var event:* = _arg1;
            onStreamSubscriptionResult = function (_arg1:Object):void{
                var _local2:DVRCastStreamInfoRetriever;
                totalRpcSubscribeInvocation--;
                if (totalRpcSubscribeInvocation <= 0){
                    _local2 = new DVRCastStreamInfoRetriever(netConnection, streamNames[0]);
                    _local2.addEventListener(Event.COMPLETE, onStreamInfoRetrieverComplete);
                    _local2.retrieve();
                };
            };
            onStreamInfoRetrieverComplete = function (_arg1:Event):void{
                var _local3:DVRCastRecordingInfo;
                var _local2:DVRCastStreamInfoRetriever = (_arg1.target as DVRCastStreamInfoRetriever);
                removeEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, onCreationComplete);
                if (_local2.streamInfo != null){
                    if (_local2.streamInfo.offline == true){
                        dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_ERROR, false, false, netConnection, urlResource, new MediaError(MediaErrorCodes.DVRCAST_CONTENT_OFFLINE)));
                        i = 0;
                        while (i < streamNames.length) {
                            netConnection.call(DVRCastConstants.RPC_UNSUBSCRIBE, null, streamNames[i]);
                            i++;
                        };
                        netConnection = null;
                    } else {
                        _local3 = new DVRCastRecordingInfo();
                        _local3.startDuration = _local2.streamInfo.currentLength;
                        _local3.startOffset = calculateOffset(_local2.streamInfo);
                        _local3.startTime = new Date();
                        streamingResource.addMetadataValue(DVRCastConstants.STREAM_INFO_KEY, _local2.streamInfo);
                        streamingResource.addMetadataValue(DVRCastConstants.RECORDING_INFO_KEY, _local3);
                        subscribedStreams[netConnection] = streamNames[0];
                        dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_COMPLETE, false, false, netConnection, urlResource));
                    };
                } else {
                    onServerCallError(_local2.error);
                };
            };
            onServerCallError = function (_arg1:Object):void{
                dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_ERROR, false, false, netConnection, urlResource, new MediaError(MediaErrorCodes.DVRCAST_SUBSCRIBE_FAILED, ((_arg1) ? _arg1.message : ""))));
            };
            urlResource = (event.resource as URLResource);
            netConnection = event.netConnection;
            streamNames = new Vector.<String>();
            totalRpcSubscribeInvocation = 0;
            event.stopImmediatePropagation();
            streamingResource = (urlResource as StreamingURLResource);
            var urlIncludesFMSApplicationInstance:* = ((streamingResource) ? streamingResource.urlIncludesFMSApplicationInstance : false);
            var dynamicResource:* = (streamingResource as DynamicStreamingResource);
            if (dynamicResource != null){
                items = dynamicResource.streamItems;
                totalRpcSubscribeInvocation = items.length;
                i = 0;
                while (i < items.length) {
                    streamNames.push(items[i].streamName);
                    i = (i + 1);
                };
            } else {
                totalRpcSubscribeInvocation = 1;
                streamNames.push(NetStreamUtils.getStreamNameFromURL(urlResource.url, urlIncludesFMSApplicationInstance));
            };
            var responder:* = new TestableResponder(onStreamSubscriptionResult, onServerCallError);
            i = 0;
            while (i < streamNames.length) {
                event.netConnection.call(DVRCastConstants.RPC_SUBSCRIBE, responder, streamNames[i]);
                i = (i + 1);
            };
        }
        private function onCreationError(_arg1:NetConnectionFactoryEvent):void{
            dispatchEvent(_arg1.clone());
        }
        private function calculateOffset(_arg1:DVRCastStreamInfo):Number{
            return (DVRUtils.calculateOffset(_arg1.beginOffset, _arg1.endOffset, _arg1.currentLength));
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {

    public class DVRUtils {

        public static function calculateOffset(_arg1:Number, _arg2:Number, _arg3:Number):Number{
            var _local4:Number = 0;
            if (_arg2 != 0){
                if (_arg3 > _arg2){
                    _local4 = (_arg3 - _arg2);
                } else {
                    _local4 = Math.min(_arg1, _arg3);
                };
            } else {
                if (_arg1 != 0){
                    _local4 = Math.min(_arg1, _arg3);
                };
            };
            return (_local4);
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {

    public class DVRCastConstants {

        public static const RPC_GET_STREAM_INFO:String = "DVRGetStreamInfo";
        public static const RPC_SUBSCRIBE:String = "DVRSubscribe";
        public static const RPC_UNSUBSCRIBE:String = "DVRUnsubscribe";
        public static const RESULT_GET_STREAM_INFO_SUCCESS:String = "NetStream.DVRStreamInfo.Success";
        public static const RESULT_GET_STREAM_INFO_RETRY:String = "NetStream.DVRStreamInfo.Retry";
        public static const STREAM_INFO_KEY:String = "http://www.osmf.org/dvrCast/1.0/streamInfo";
        public static const RECORDING_INFO_KEY:String = "http://www.osmf.org/dvrCast/1.0/recordingInfo";
        public static const STREAM_INFO_UPDATE_DELAY:Number = 3000;
        public static const LOCAL_DURATION_UPDATE_INTERVAL:Number = 500;
        public static const LIVE_POSITION_SEEK_DELAY:Number = 1.5;

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.dvr.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    class DVRCastStreamInfoRetriever extends EventDispatcher {

        private var connection:NetConnection;
        private var streamName:String;
        private var retries:Number;
        private var timer:Timer;
        private var _streamInfo:DVRCastStreamInfo;
        private var _error:Object;

        public function DVRCastStreamInfoRetriever(_arg1:NetConnection, _arg2:String){
            if ((((_arg1 == null)) || ((_arg2 == null)))){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.connection = _arg1;
            this.streamName = _arg2;
        }
        public function get streamInfo():DVRCastStreamInfo{
            return (this._streamInfo);
        }
        public function get error():Object{
            return (this._error);
        }
        public function retrieve(_arg1:int=5, _arg2:Number=3):void{
            if (!isNaN(this.retries)){
            } else {
                _arg1 = ((_arg1) || (1));
                this._streamInfo = null;
                this._error = (this._error = {message:OSMFStrings.getString(OSMFStrings.DVR_MAXIMUM_RPC_ATTEMPTS).replace("%i", _arg1)});
                this.retries = _arg1;
                this.timer = new Timer((_arg2 * 1000), 1);
                this.getStreamInfo();
            };
        }
        private function getStreamInfo():void{
            var _local1:Responder = new TestableResponder(this.onGetStreamInfoResult, this.onServerCallError);
            this.retries--;
            this.connection.call(DVRCastConstants.RPC_GET_STREAM_INFO, _local1, this.streamName);
        }
        private function onGetStreamInfoResult(_arg1:Object):void{
            if (((_arg1) && ((_arg1.code == DVRCastConstants.RESULT_GET_STREAM_INFO_SUCCESS)))){
                this._error = null;
                this._streamInfo = new DVRCastStreamInfo(_arg1.data);
                this.complete();
            } else {
                if (((_arg1) && ((_arg1.code == DVRCastConstants.RESULT_GET_STREAM_INFO_RETRY)))){
                    if (this.retries != 0){
                        this.timer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onTimerComplete);
                        this.timer.start();
                    } else {
                        this.complete();
                    };
                } else {
                    this._error = {message:(OSMFStrings.getString(OSMFStrings.DVR_UNEXPECTED_SERVER_RESPONSE) + _arg1.code)};
                    this.complete();
                };
            };
        }
        private function onServerCallError(_arg1:Object):void{
            this._error = _arg1;
            this.complete();
        }
        private function onTimerComplete(_arg1:TimerEvent):void{
            this.timer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onTimerComplete);
            this.getStreamInfo();
        }
        private function complete():void{
            this.retries = NaN;
            this.timer = null;
            dispatchEvent(new Event(Event.COMPLETE));
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {

    public class DVRCastRecordingInfo {

        public var startTime:Date = null;
        public var startDuration:Number;
        public var startOffset:Number;

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net.dvr {
    import flash.net.*;

    class TestableResponder extends Responder {

        private var _result:Function;
        private var _status:Function;

        public function TestableResponder(_arg1:Function, _arg2:Function=null){
            this._result = _arg1;
            this._status = _arg2;
            super(_arg1, _arg2);
        }
        function get result():Function{
            return (this._result);
        }
        function get status():Function{
            return (this._status);
        }

    }
}//package org.osmf.net.dvr 
﻿package org.osmf.net {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;

    public class NetStreamTimeTrait extends TimeTrait {

        private var durationOffset:Number = 0;
        private var _audioDelay:Number = 0;
        private var netStream:NetStream;
        private var resource:MediaResourceBase;
        private var multicast:Boolean = false;

        public function NetStreamTimeTrait(_arg1:NetStream, _arg2:MediaResourceBase, _arg3:Number=NaN){
            this.netStream = _arg1;
            NetClient(_arg1.client).addHandler(NetStreamCodes.ON_META_DATA, this.onMetaData);
            NetClient(_arg1.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus);
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, 0, true);
            this.resource = _arg2;
            if (isNaN(_arg3) == false){
                setDuration(_arg3);
            };
            var _local4:MulticastResource = (_arg2 as MulticastResource);
            if (((((!((_local4 == null))) && (!((_local4.groupspec == null))))) && ((_local4.groupspec.length > 0)))){
                this.multicast = true;
                setDuration(Number.MAX_VALUE);
            };
        }
        override public function get currentTime():Number{
            if (this.multicast){
                return (0);
            };
            if (this.durationOffset == (duration - (this.netStream.time - this._audioDelay))){
                return (((this.netStream.time - this._audioDelay) + this.durationOffset));
            };
            return ((this.netStream.time - this._audioDelay));
        }
        private function onMetaData(_arg1:Object):void{
            var _local2:Object = NetStreamUtils.getPlayArgsForResource(this.resource);
            this._audioDelay = ((_arg1.hasOwnProperty("audiodelay")) ? _arg1.audiodelay : 0);
            var _local3:Number = Math.max(0, _local2.start);
            var _local4:Number = _local2.len;
            if (_local4 == NetStreamUtils.PLAY_LEN_ARG_ALL){
                _local4 = Number.MAX_VALUE;
            };
            setDuration(Math.min(((_arg1.duration - this._audioDelay) - _local3), _local4));
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_COMPLETE:
                    this.signalComplete();
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    if (NetStreamUtils.isStreamingResource(this.resource) == false){
                        this.signalComplete();
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_UNPUBLISH_NOTIFY:
                    this.signalComplete();
                    break;
            };
        }
        override protected function signalComplete():void{
            if ((this.netStream.time - this._audioDelay) != duration){
                this.durationOffset = (duration - (this.netStream.time - this._audioDelay));
            };
            super.signalComplete();
        }
        function get audioDelay():Number{
            return (this._audioDelay);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net.drm {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.system.*;

    public class NetStreamDRMTrait extends DRMTrait {

        private var drmServices:DRMServices;

        public function NetStreamDRMTrait(){
            this.drmServices = new DRMServices();
            super();
            this.drmServices.addEventListener(DRMEvent.DRM_STATE_CHANGE, this.onStateChange);
        }
        public function set drmMetadata(_arg1:Object):void{
            if (_arg1 != this.drmServices.drmMetadata){
                this.drmServices.drmMetadata = _arg1;
            };
        }
        public function get drmMetadata():Object{
            return (this.drmServices.drmMetadata);
        }
        public function update(_arg1:String):SystemUpdater{
            return (this.drmServices.update(_arg1));
        }
        override public function authenticate(_arg1:String=null, _arg2:String=null):void{
            this.drmServices.authenticate(_arg1, _arg2);
        }
        override public function authenticateWithToken(_arg1:Object):void{
            this.drmServices.authenticateWithToken(_arg1);
        }
        public function inlineDRMFailed(_arg1:MediaError):void{
            this.drmServices.inlineDRMFailed(_arg1);
        }
        public function inlineOnVoucher(_arg1:DRMStatusEvent):void{
            this.drmServices.inlineOnVoucher(_arg1);
        }
        private function onStateChange(_arg1:DRMEvent):void{
            setPeriod(_arg1.period);
            setStartDate(_arg1.startDate);
            setEndDate(_arg1.endDate);
            setDrmState(_arg1.drmState);
            dispatchEvent(new DRMEvent(DRMEvent.DRM_STATE_CHANGE, drmState, false, false, startDate, endDate, period, _arg1.serverURL, _arg1.token, _arg1.mediaError));
        }

    }
}//package org.osmf.net.drm 
﻿package org.osmf.net.drm {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.utils.*;
    import flash.system.*;
    import org.osmf.utils.*;
    import org.osmf.net.drm.*;
    import flash.net.drm.*;
    import flash.errors.*;

    class DRMServices extends EventDispatcher {

        private static const DRM_AUTHENTICATION_FAILED:int = 3301;
        private static const DRM_NEEDS_AUTHENTICATION:int = 3330;
        private static const DRM_CONTENT_NOT_YET_VALID:int = 3331;

        private static var updater:SystemUpdater;

        private var _drmState:String = "uninitialized";
        private var lastToken:ByteArray;
        private var drmContentData:DRMContentData;
        private var voucher:DRMVoucher;
        private var drmManager:DRMManager;

        public function DRMServices(){
            this.drmManager = DRMManager.getDRMManager();
        }
        public static function convertToken(_arg1:Object):ByteArray{
            var _local3:String;
            var _local2:ByteArray;
            if (_arg1 != null){
                _local2 = (_arg1 as ByteArray);
                if (_local2 == null){
                    _local3 = _arg1.toString();
                    if (((!((_local3 == null))) && ((_local3.length > 0)))){
                        _local2 = new ByteArray();
                        _local2.writeUTFBytes(_local3);
                        _local2.position = 0;
                    };
                };
            };
            return (_local2);
        }

        public function get drmState():String{
            return (this._drmState);
        }
        public function set drmMetadata(_arg1:Object):void{
            var onComplete:* = null;
            var value:* = _arg1;
            this.lastToken = null;
            if ((value is DRMContentData)){
                this.drmContentData = (value as DRMContentData);
                this.retrieveVoucher();
            } else {
                try {
                    this.drmContentData = new DRMContentData((value as ByteArray));
                    this.retrieveVoucher();
                } catch(argError:ArgumentError) {
                    updateDRMState(DRMState.AUTHENTICATION_ERROR, new MediaError(argError.errorID, "DRMContentData invalid"));
                } catch(error:IllegalOperationError) {
                    onComplete = function (_arg1:Event):void{
                        updater.removeEventListener(Event.COMPLETE, onComplete);
                        drmMetadata = value;
                    };
                    update(SystemUpdaterType.DRM);
                    updater.addEventListener(Event.COMPLETE, onComplete);
                };
            };
        }
        public function get drmMetadata():Object{
            return (this.drmContentData);
        }
        public function authenticate(_arg1:String=null, _arg2:String=null):void{
            if (this.drmContentData == null){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.DRM_METADATA_NOT_SET)));
            };
            this.drmManager.addEventListener(DRMAuthenticationErrorEvent.AUTHENTICATION_ERROR, this.authError);
            this.drmManager.addEventListener(DRMAuthenticationCompleteEvent.AUTHENTICATION_COMPLETE, this.authComplete);
            if ((((_arg2 == null)) && ((_arg1 == null)))){
                this.retrieveVoucher();
            } else {
                this.drmManager.authenticate(this.drmContentData.serverURL, this.drmContentData.domain, _arg1, _arg2);
            };
        }
        public function authenticateWithToken(_arg1:Object):void{
            if (this.drmContentData == null){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.DRM_METADATA_NOT_SET)));
            };
            this.drmManager.setAuthenticationToken(this.drmContentData.serverURL, this.drmContentData.domain, convertToken(_arg1));
            this.retrieveVoucher();
        }
        public function get startDate():Date{
            if (this.voucher != null){
                return (((this.voucher.playbackTimeWindow) ? this.voucher.playbackTimeWindow.startDate : this.voucher.voucherStartDate));
            };
            return (null);
        }
        public function get endDate():Date{
            if (this.voucher != null){
                return (((this.voucher.playbackTimeWindow) ? this.voucher.playbackTimeWindow.endDate : this.voucher.voucherEndDate));
            };
            return (null);
        }
        public function get period():Number{
            if (this.voucher != null){
                return (((this.voucher.playbackTimeWindow) ? this.voucher.playbackTimeWindow.period : ((((this.voucher.voucherEndDate) && (this.voucher.voucherStartDate))) ? ((this.voucher.voucherEndDate.time - this.voucher.voucherStartDate.time) / 1000) : 0)));
            };
            return (NaN);
        }
        public function inlineDRMFailed(_arg1:MediaError):void{
            this.updateDRMState(DRMState.AUTHENTICATION_ERROR, _arg1);
        }
        public function inlineOnVoucher(_arg1:DRMStatusEvent):void{
            this.drmContentData = _arg1.contentData;
            this.onVoucherLoaded(_arg1);
        }
        public function update(_arg1:String):SystemUpdater{
            this.updateDRMState(DRMState.DRM_SYSTEM_UPDATING);
            if (updater == null){
                updater = new SystemUpdater();
                this.toggleErrorListeners(updater, true);
                updater.update(_arg1);
            } else {
                this.toggleErrorListeners(updater, true);
            };
            return (updater);
        }
        private function retrieveVoucher():void{
            this.updateDRMState(DRMState.AUTHENTICATING);
            this.drmManager.addEventListener(DRMErrorEvent.DRM_ERROR, this.onDRMError);
            this.drmManager.addEventListener(DRMStatusEvent.DRM_STATUS, this.onVoucherLoaded);
            this.drmManager.loadVoucher(this.drmContentData, LoadVoucherSetting.ALLOW_SERVER);
        }
        private function onVoucherLoaded(_arg1:DRMStatusEvent):void{
            var _local2:Date;
            if (_arg1.contentData == this.drmContentData){
                _local2 = new Date();
                if (((_arg1.voucher) && ((((((_arg1.voucher.voucherEndDate == null)) || ((_arg1.voucher.voucherEndDate.time >= _local2.time)))) && ((((_arg1.voucher.voucherStartDate == null)) || ((_arg1.voucher.voucherStartDate.time <= _local2.time)))))))){
                    this.voucher = _arg1.voucher;
                    this.removeEventListeners();
                    if (this.voucher.playbackTimeWindow == null){
                        this.updateDRMState(DRMState.AUTHENTICATION_COMPLETE, null, this.voucher.voucherStartDate, this.voucher.voucherEndDate, this.period, this.lastToken);
                    } else {
                        this.updateDRMState(DRMState.AUTHENTICATION_COMPLETE, null, this.voucher.playbackTimeWindow.startDate, this.voucher.playbackTimeWindow.endDate, this.voucher.playbackTimeWindow.period, this.lastToken);
                    };
                } else {
                    this.forceRefreshVoucher();
                };
            };
        }
        private function forceRefreshVoucher():void{
            this.drmManager.loadVoucher(this.drmContentData, LoadVoucherSetting.FORCE_REFRESH);
        }
        private function onDRMError(_arg1:DRMErrorEvent):void{
            if (_arg1.contentData == this.drmContentData){
                switch (_arg1.errorID){
                    case DRM_CONTENT_NOT_YET_VALID:
                        this.forceRefreshVoucher();
                        break;
                    case DRM_NEEDS_AUTHENTICATION:
                        this.updateDRMState(DRMState.AUTHENTICATION_NEEDED, null, null, null, 0, null, _arg1.contentData.serverURL);
                        break;
                    default:
                        this.removeEventListeners();
                        this.updateDRMState(DRMState.AUTHENTICATION_ERROR, new MediaError(_arg1.errorID, _arg1.text));
                };
            };
        }
        private function removeEventListeners():void{
            this.drmManager.removeEventListener(DRMErrorEvent.DRM_ERROR, this.onDRMError);
            this.drmManager.removeEventListener(DRMStatusEvent.DRM_STATUS, this.onVoucherLoaded);
        }
        private function authComplete(_arg1:DRMAuthenticationCompleteEvent):void{
            this.drmManager.removeEventListener(DRMAuthenticationErrorEvent.AUTHENTICATION_ERROR, this.authError);
            this.drmManager.removeEventListener(DRMAuthenticationCompleteEvent.AUTHENTICATION_COMPLETE, this.authComplete);
            this.lastToken = _arg1.token;
            this.retrieveVoucher();
        }
        private function authError(_arg1:DRMAuthenticationErrorEvent):void{
            this.drmManager.removeEventListener(DRMAuthenticationErrorEvent.AUTHENTICATION_ERROR, this.authError);
            this.drmManager.removeEventListener(DRMAuthenticationCompleteEvent.AUTHENTICATION_COMPLETE, this.authComplete);
            this.updateDRMState(DRMState.AUTHENTICATION_ERROR, new MediaError(_arg1.errorID, _arg1.toString()));
        }
        private function toggleErrorListeners(_arg1:SystemUpdater, _arg2:Boolean):void{
            if (_arg2){
                _arg1.addEventListener(Event.COMPLETE, this.onUpdateComplete);
                _arg1.addEventListener(Event.CANCEL, this.onUpdateComplete);
                _arg1.addEventListener(IOErrorEvent.IO_ERROR, this.onUpdateError);
                _arg1.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onUpdateError);
                _arg1.addEventListener(StatusEvent.STATUS, this.onUpdateError);
            } else {
                _arg1.removeEventListener(Event.COMPLETE, this.onUpdateComplete);
                _arg1.removeEventListener(Event.CANCEL, this.onUpdateComplete);
                _arg1.removeEventListener(IOErrorEvent.IO_ERROR, this.onUpdateError);
                _arg1.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onUpdateError);
                _arg1.removeEventListener(StatusEvent.STATUS, this.onUpdateError);
            };
        }
        private function onUpdateComplete(_arg1:Event):void{
            this.toggleErrorListeners(updater, false);
        }
        private function onUpdateError(_arg1:Event):void{
            this.toggleErrorListeners(updater, false);
            this.updateDRMState(DRMState.AUTHENTICATION_ERROR, new MediaError(MediaErrorCodes.DRM_SYSTEM_UPDATE_ERROR, _arg1.toString()));
        }
        private function updateDRMState(_arg1:String, _arg2:MediaError=null, _arg3:Date=null, _arg4:Date=null, _arg5:Number=0, _arg6:Object=null, _arg7:String=null):void{
            this._drmState = _arg1;
            dispatchEvent(new DRMEvent(DRMEvent.DRM_STATE_CHANGE, _arg1, false, false, _arg3, _arg4, _arg5, _arg7, _arg6, _arg2));
        }

    }
}//package org.osmf.net.drm 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.display.*;
    import flash.net.*;
    import org.osmf.media.videoClasses.*;

    public class NetStreamDisplayObjectTrait extends DisplayObjectTrait {

        private var videoSurface:VideoSurface;
        private var netStream:NetStream;

        public function NetStreamDisplayObjectTrait(_arg1:NetStream, _arg2:DisplayObject, _arg3:Number=0, _arg4:Number=0){
            super(_arg2, _arg3, _arg4);
            this.netStream = _arg1;
            this.videoSurface = (_arg2 as VideoSurface);
            NetClient(_arg1.client).addHandler(NetStreamCodes.ON_META_DATA, this.onMetaData);
            if ((this.videoSurface is VideoSurface)){
                this.videoSurface.addEventListener(Event.ADDED_TO_STAGE, this.onStage);
            };
        }
        private function onStage(_arg1:Event):void{
            this.videoSurface.removeEventListener(Event.ADDED_TO_STAGE, this.onStage);
            this.videoSurface.addEventListener(Event.ENTER_FRAME, this.onFrame);
        }
        private function onFrame(_arg1:Event):void{
            if (((!((this.videoSurface.videoWidth == 0))) && (!((this.videoSurface.videoHeight == 0))))){
                if (((!((this.videoSurface.videoWidth == mediaWidth))) && (!((this.videoSurface.videoHeight == mediaHeight))))){
                    this.newMediaSize(this.videoSurface.videoWidth, this.videoSurface.videoHeight);
                };
                this.videoSurface.removeEventListener(Event.ENTER_FRAME, this.onFrame);
            };
        }
        private function onMetaData(_arg1:Object):void{
            if (((((!(isNaN(_arg1.width))) && (!(isNaN(_arg1.height))))) && (((!((_arg1.width == mediaWidth))) || (!((_arg1.height == mediaHeight))))))){
                this.newMediaSize(_arg1.width, _arg1.height);
            };
        }
        private function newMediaSize(_arg1:Number, _arg2:Number):void{
            if (((((!((this.videoSurface == null))) && ((this.videoSurface.width == 0)))) && ((this.videoSurface.height == 0)))){
                this.videoSurface.width = _arg1;
                this.videoSurface.height = _arg2;
            };
            setMediaSize(_arg1, _arg2);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import org.osmf.net.qos.*;
    import flash.utils.*;

    public class NetStreamPlaybackDetailsRecorder {

        private static const DFPS_AFTER_TRANSITION_IGNORE_TIME:Number = 2000;

        private var _playingIndex:uint;
        private var netStream:NetStream;
        private var lastDroppedFrames:Number;
        private var lastNetStreamTime:Number;
        private var lastTransitionTime:Number = -INF;
        private var resource:DynamicStreamingResource;
        private var playbackDetailsRecord:Vector.<PlaybackDetails>;
        private var timer:Timer;
        private var seeking:Boolean = false;

        public function NetStreamPlaybackDetailsRecorder(_arg1:NetStream, _arg2:NetClient, _arg3:DynamicStreamingResource){
            this.netStream = _arg1;
            this.resource = _arg3;
            this._playingIndex = Math.max(_arg3.initialIndex, 0);
            this.resetRecord();
            this.timer = new Timer(DFPS_AFTER_TRANSITION_IGNORE_TIME, 1);
            this.timer.addEventListener(TimerEvent.TIMER, this.onTimer);
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            _arg2.addHandler("onPlayStatus", this.onPlayStatus);
        }
        public function computeAndGetRecord():Vector.<PlaybackDetails>{
            if (!this.seeking){
                this.performComputation();
            };
            var _local1:Vector.<PlaybackDetails> = this.playbackDetailsRecord.slice();
            this.resetRecord();
            return (_local1);
        }
        public function get playingIndex():uint{
            return (this._playingIndex);
        }
        public function resetRecord():void{
            this.playbackDetailsRecord = new Vector.<PlaybackDetails>();
            this.lastNetStreamTime = this.netStream.time;
            this.lastDroppedFrames = this.netStream.info.droppedFrames;
        }
        private function onTimer(_arg1:TimerEvent):void{
            this.timer.reset();
            this.lastDroppedFrames = this.netStream.info.droppedFrames;
        }
        private function performComputation():void{
            var _local6:PlaybackDetails;
            var _local7:PlaybackDetails;
            var _local1:Number = this.netStream.time;
            var _local2:Number = this.netStream.info.droppedFrames;
            if ((getTimer() - this.lastTransitionTime) < DFPS_AFTER_TRANSITION_IGNORE_TIME){
                this.lastDroppedFrames = _local2;
            };
            var _local3:Number = (_local1 - this.lastNetStreamTime);
            var _local4:Number = (_local2 - this.lastDroppedFrames);
            var _local5:Boolean;
            for each (_local6 in this.playbackDetailsRecord) {
                if (_local6.index == this._playingIndex){
                    _local5 = true;
                    _local6.duration = (_local6.duration + _local3);
                    _local6.droppedFrames = (_local6.droppedFrames + _local4);
                    break;
                };
            };
            if (!_local5){
                _local7 = new PlaybackDetails(this._playingIndex, _local3, _local4);
                this.playbackDetailsRecord.push(_local7);
            };
            this.lastNetStreamTime = _local1;
            this.lastDroppedFrames = _local2;
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_SEEK_START:
                    this.performComputation();
                    this.seeking = true;
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_NOTIFY:
                    this.resetRecord();
                    this.seeking = false;
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    this.resetRecord();
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            var _local2:int;
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE:
                    _local2 = this.resource.indexFromName(_arg1.details);
                    if (_local2 >= 0){
                        if (!this.seeking){
                            this.performComputation();
                        };
                        this._playingIndex = _local2;
                        this.timer.start();
                        this.lastTransitionTime = getTimer();
                    };
                    break;
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.media.videoClasses.*;

    public class NetStreamBufferTrait extends BufferTrait {

        private var netStream:NetStream;
        private var videoSurface:VideoSurface;

        public function NetStreamBufferTrait(_arg1:NetStream, _arg2:VideoSurface=null){
            this.netStream = _arg1;
            this.videoSurface = _arg2;
            bufferTime = _arg1.bufferTime;
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, 0, true);
        }
        override public function get bufferLength():Number{
            return (this.netStream.bufferLength);
        }
        override protected function bufferTimeChangeStart(_arg1:Number):void{
            this.netStream.bufferTime = _arg1;
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_START:
                case NetStreamCodes.NETSTREAM_BUFFER_EMPTY:
                    bufferTime = this.netStream.bufferTime;
                    setBuffering(true);
                    if (this.netStream.bufferTime == 0){
                        setBuffering(false);
                    };
                    if (this.bufferNotSupported){
                        setBuffering(false);
                    };
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_START:
                    setBuffering(true);
                    break;
                case NetStreamCodes.NETSTREAM_BUFFER_FLUSH:
                case NetStreamCodes.NETSTREAM_BUFFER_FULL:
                    setBuffering(false);
                    break;
            };
        }
        private function get bufferNotSupported():Boolean{
            return ((((((this.netStream.bytesLoaded == 0)) && (!((this.videoSurface == null))))) && ((this.videoSurface.info.renderStatus == "accelerated"))));
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    class FMSHost {

        private var _host:String;
        private var _port:String;

        public function FMSHost(_arg1:String, _arg2:String="1935"){
            this._host = _arg1;
            this._port = _arg2;
        }
        public function get host():String{
            return (this._host);
        }
        public function set host(_arg1:String):void{
            this._host = _arg1;
        }
        public function get port():String{
            return (this._port);
        }
        public function set port(_arg1:String):void{
            this._port = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import __AS3__.vec.*;
    import org.osmf.utils.*;

    public class DynamicStreamingResource extends StreamingURLResource {

        private var _streamItems:Vector.<DynamicStreamingItem>;
        private var _initialIndex:int;

        public function DynamicStreamingResource(_arg1:String, _arg2:String=null){
            super(_arg1, _arg2);
            this._initialIndex = 0;
        }
        public function get host():String{
            return (url);
        }
        public function get streamItems():Vector.<DynamicStreamingItem>{
            if (this._streamItems == null){
                this._streamItems = new Vector.<DynamicStreamingItem>();
            };
            return (this._streamItems);
        }
        public function set streamItems(_arg1:Vector.<DynamicStreamingItem>):void{
            this._streamItems = _arg1;
            if (_arg1 != null){
                _arg1.sort(this.compareStreamItems);
            };
        }
        public function get initialIndex():int{
            return (this._initialIndex);
        }
        public function set initialIndex(_arg1:int):void{
            if ((((this._streamItems == null)) || ((_arg1 >= this._streamItems.length)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this._initialIndex = _arg1;
        }
        public function indexFromName(_arg1:String):int{
            var _local2:int;
            while (_local2 < this._streamItems.length) {
                if ((((this._streamItems[_local2].streamName.indexOf(_arg1) == 0)) || ((this._streamItems[_local2].streamName.indexOf(("mp4:" + _arg1)) == 0)))){
                    return (_local2);
                };
                _local2++;
            };
            return (-1);
        }
        private function compareStreamItems(_arg1:DynamicStreamingItem, _arg2:DynamicStreamingItem):Number{
            var _local3:Number = -1;
            if (_arg1.bitrate == _arg2.bitrate){
                _local3 = 0;
            } else {
                if (_arg1.bitrate > _arg2.bitrate){
                    _local3 = 1;
                };
            };
            return (_local3);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public final class StreamType {

        public static const LIVE:String = "live";
        public static const RECORDED:String = "recorded";
        public static const LIVE_OR_RECORDED:String = "liveOrRecorded";
        public static const DVR:String = "dvr";

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.utils.*;

    public class NetStreamPlayTrait extends PlayTrait {

        private static const NETCONNECTION_FAILURE_ERROR_CODE:int = 2154;

        private var streamStarted:Boolean;
        private var netStream:NetStream;
        private var netConnection:NetConnection;
        private var urlResource:URLResource;
        private var multicastResource:MulticastResource;
        private var reconnectStreams:Boolean;

        public function NetStreamPlayTrait(_arg1:NetStream, _arg2:MediaResourceBase, _arg3:Boolean, _arg4:NetConnection){
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.netStream = _arg1;
            this.netConnection = _arg4;
            this.urlResource = (_arg2 as URLResource);
            this.multicastResource = (_arg2 as MulticastResource);
            this.reconnectStreams = _arg3;
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, 1, true);
            NetClient(_arg1.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus, 1);
        }
        override protected function playStateChangeStart(_arg1:String):void{
            var _local2:Object;
            var _local3:StreamingURLResource;
            var _local4:Boolean;
            var _local5:String;
            var _local6:Number;
            var _local7:Number;
            var _local8:DynamicStreamingResource;
            var _local9:NetStreamPlayOptions;
            if (_arg1 == PlayState.PLAYING){
                if (this.streamStarted){
                    if (this.multicastResource != null){
                        this.netStream.play(this.multicastResource.streamName, -1, -1);
                    } else {
                        this.netStream.resume();
                    };
                } else {
                    if (this.urlResource != null){
                        _local3 = (this.urlResource as StreamingURLResource);
                        _local4 = ((_local3) ? _local3.urlIncludesFMSApplicationInstance : false);
                        _local5 = NetStreamUtils.getStreamNameFromURL(this.urlResource.url, _local4);
                        _local2 = NetStreamUtils.getPlayArgsForResource(this.urlResource);
                        _local6 = _local2.start;
                        _local7 = _local2.len;
                        _local8 = (this.urlResource as DynamicStreamingResource);
                        if (_local8 != null){
                            _local9 = new NetStreamPlayOptions();
                            _local9.start = _local6;
                            _local9.len = _local7;
                            _local9.streamName = _local8.streamItems[_local8.initialIndex].streamName;
                            _local9.transition = NetStreamPlayTransitions.RESET;
                            this.doPlay2(_local9);
                        } else {
                            if (((((this.reconnectStreams) && (!((_local3 == null))))) && (NetStreamUtils.isRTMPStream(_local3.url)))){
                                _local9 = new NetStreamPlayOptions();
                                _local9.start = _local6;
                                _local9.len = _local7;
                                _local9.transition = NetStreamPlayTransitions.RESET;
                                _local9.streamName = _local5;
                                this.doPlay2(_local9);
                            } else {
                                if (((((!((this.multicastResource == null))) && (!((this.multicastResource.groupspec == null))))) && ((this.multicastResource.groupspec.length > 0)))){
                                    this.doPlay(this.multicastResource.streamName, _local6, _local7);
                                } else {
                                    this.doPlay(_local5, _local6, _local7);
                                };
                            };
                        };
                    };
                };
            } else {
                if (this.multicastResource != null){
                    this.netStream.play(false);
                } else {
                    this.netStream.pause();
                };
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                case NetStreamCodes.NETSTREAM_PLAY_FILESTRUCTUREINVALID:
                case NetStreamCodes.NETSTREAM_PLAY_STREAMNOTFOUND:
                case NetStreamCodes.NETSTREAM_PLAY_NOSUPPORTEDTRACKFOUND:
                case NetStreamCodes.NETSTREAM_FAILED:
                    this.netStream.pause();
                    this.streamStarted = false;
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    if (((!((this.urlResource == null))) && ((NetStreamUtils.isStreamingResource(this.urlResource) == false)))){
                        stop();
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_LIVE_STALL:
                    dispatchEvent(new PlayEvent(PlayEvent.LIVE_STALL));
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_LIVE_RESUME:
                    dispatchEvent(new PlayEvent(PlayEvent.LIVE_RESUME));
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_COMPLETE:
                    stop();
                    break;
            };
        }
        private function doPlay(... _args):void{
            var args:* = _args;
            try {
                this.netStream.play.apply(this, args);
                this.streamStarted = true;
            } catch(error:Error) {
                streamStarted = false;
                stop();
                dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.NETSTREAM_PLAY_FAILED)));
            };
        }
        private function doPlay2(_arg1:NetStreamPlayOptions):void{
            this.netStream.play2(_arg1);
            this.streamStarted = true;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import flash.events.*;

    public class NetStreamSwitchManagerBase extends EventDispatcher {

        protected var _autoSwitch:Boolean;
        protected var _maxAllowedIndex:int;

        public function NetStreamSwitchManagerBase(){
            this._autoSwitch = true;
            this._maxAllowedIndex = int.MAX_VALUE;
        }
        public function get autoSwitch():Boolean{
            return (this._autoSwitch);
        }
        public function set autoSwitch(_arg1:Boolean):void{
            this._autoSwitch = _arg1;
        }
        public function get currentIndex():uint{
            return (0);
        }
        public function get maxAllowedIndex():int{
            return (this._maxAllowedIndex);
        }
        public function set maxAllowedIndex(_arg1:int):void{
            this._maxAllowedIndex = _arg1;
        }
        public function switchTo(_arg1:int):void{
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public class PortProtocol {

        private var _port:int;
        private var _protocol:String;

        public function get port():int{
            return (this._port);
        }
        public function set port(_arg1:int):void{
            this._port = _arg1;
        }
        public function get protocol():String{
            return (this._protocol);
        }
        public function set protocol(_arg1:String):void{
            this._protocol = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public final class NetStreamCodes {

        public static const NETSTREAM_BUFFER_EMPTY:String = "NetStream.Buffer.Empty";
        public static const NETSTREAM_BUFFER_FULL:String = "NetStream.Buffer.Full";
        public static const NETSTREAM_BUFFER_FLUSH:String = "NetStream.Buffer.Flush";
        public static const NETSTREAM_FAILED:String = "NetStream.Failed";
        public static const NETSTREAM_PLAY_START:String = "NetStream.Play.Start";
        public static const NETSTREAM_PLAY_STOP:String = "NetStream.Play.Stop";
        public static const NETSTREAM_PLAY_FAILED:String = "NetStream.Play.Failed";
        public static const NETSTREAM_PLAY_STREAMNOTFOUND:String = "NetStream.Play.StreamNotFound";
        public static const NETSTREAM_PLAY_RESET:String = "NetStream.Play.Reset";
        public static const NETSTREAM_PLAY_INSUFFICIENTBW:String = "NetStream.Play.InsufficientBW";
        public static const NETSTREAM_PLAY_FILESTRUCTUREINVALID:String = "NetStream.Play.FileStructureInvalid";
        public static const NETSTREAM_PLAY_NOSUPPORTEDTRACKFOUND:String = "NetStream.Play.NoSupportedTrackFound";
        public static const NETSTREAM_PLAY_TRANSITION:String = "NetStream.Play.Transition";
        public static const NETSTREAM_PAUSE_NOTIFY:String = "NetStream.Pause.Notify";
        public static const NETSTREAM_PLAY_PUBLISH_NOTIFY:String = "NetStream.Play.PublishNotify";
        public static const NETSTREAM_PLAY_UNPUBLISH_NOTIFY:String = "NetStream.Play.UnpublishNotify";
        public static const NETSTREAM_UNPAUSE_NOTIFY:String = "NetStream.Unpause.Notify";
        public static const NETSTREAM_SEEK_FAILED:String = "NetStream.Seek.Failed";
        public static const NETSTREAM_SEEK_INVALIDTIME:String = "NetStream.Seek.InvalidTime";
        public static const NETSTREAM_SEEK_NOTIFY:String = "NetStream.Seek.Notify";
        public static const NETSTREAM_PLAY_COMPLETE:String = "NetStream.Play.Complete";
        public static const NETSTREAM_PLAY_TRANSITION_COMPLETE:String = "NetStream.Play.TransitionComplete";
        public static const NETSTREAM_SEEK_START:String = "NetStream.Seek.Start";
        public static const NETSTREAM_PLAY_LIVE_STALL:String = "NetStream.Play.LiveStall";
        public static const NETSTREAM_PLAY_LIVE_RESUME:String = "NetStream.Play.LiveResume";
        public static const ON_META_DATA:String = "onMetaData";
        public static const ON_CUE_POINT:String = "onCuePoint";
        public static const ON_PLAY_STATUS:String = "onPlayStatus";
        public static const NETSTREAM_DRM_UPDATE:String = "DRM.UpdateNeeded";

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class NetStreamLoadTrait extends LoadTrait {

        private var _connection:NetConnection;
        private var _switchManager:NetStreamSwitchManagerBase;
        private var traits:Dictionary;
        private var _netConnectionFactory:NetConnectionFactoryBase;
        private var isStreamingResource:Boolean;
        private var _netStream:NetStream;
        private var _netGroup:NetGroup;

        public function NetStreamLoadTrait(_arg1:LoaderBase, _arg2:MediaResourceBase){
            this.traits = new Dictionary();
            super(_arg1, _arg2);
            this.isStreamingResource = NetStreamUtils.isStreamingResource(_arg2);
        }
        public function get connection():NetConnection{
            return (this._connection);
        }
        public function set connection(_arg1:NetConnection):void{
            this._connection = _arg1;
        }
        public function get netStream():NetStream{
            return (this._netStream);
        }
        public function set netStream(_arg1:NetStream):void{
            this._netStream = _arg1;
        }
        public function get switchManager():NetStreamSwitchManagerBase{
            return (this._switchManager);
        }
        public function set switchManager(_arg1:NetStreamSwitchManagerBase):void{
            this._switchManager = _arg1;
        }
        public function setTrait(_arg1:MediaTraitBase):void{
            if (_arg1 == null){
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.NULL_PARAM)));
            };
            this.traits[_arg1.traitType] = _arg1;
        }
        public function getTrait(_arg1:String):MediaTraitBase{
            return (this.traits[_arg1]);
        }
        public function get netConnectionFactory():NetConnectionFactoryBase{
            return (this._netConnectionFactory);
        }
        public function set netConnectionFactory(_arg1:NetConnectionFactoryBase):void{
            this._netConnectionFactory = _arg1;
        }
        override protected function loadStateChangeStart(_arg1:String):void{
            if (_arg1 == LoadState.READY){
                if (((!(this.isStreamingResource)) && ((((this.netStream.bytesTotal <= 0)) || ((this.netStream.bytesTotal == uint.MAX_VALUE)))))){
                    this.netStream.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
                };
            } else {
                if (_arg1 == LoadState.UNINITIALIZED){
                    this.netStream = null;
                    dispatchEvent(new LoadEvent(LoadEvent.BYTES_LOADED_CHANGE, false, false, null, this.bytesLoaded));
                    dispatchEvent(new LoadEvent(LoadEvent.BYTES_TOTAL_CHANGE, false, false, null, this.bytesTotal));
                };
            };
        }
        override public function get bytesLoaded():Number{
            if (((!((this.netStream == null))) && (((!(this.isStreamingResource)) || ((this.netStream is HTTPNetStream)))))){
                return (this.netStream.bytesLoaded);
            };
            return (NaN);
        }
        override public function get bytesTotal():Number{
            return (((this.isStreamingResource) ? NaN : ((this.netStream)!=null) ? this.netStream.bytesTotal : NaN));
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            if (((!((this.netStream == null))) && ((this.netStream.bytesTotal > 0)))){
                dispatchEvent(new LoadEvent(LoadEvent.BYTES_TOTAL_CHANGE, false, false, null, this.netStream.bytesTotal));
                this.netStream.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            };
        }
        public function get netGroup():NetGroup{
            return (this._netGroup);
        }
        public function set netGroup(_arg1:NetGroup):void{
            this._netGroup = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public class DynamicStreamingItem {

        private var _bitrate:Number;
        private var _stream:String;
        private var _width:int;
        private var _height:int;

        public function DynamicStreamingItem(_arg1:String, _arg2:Number, _arg3:int=-1, _arg4:int=-1){
            this._stream = _arg1;
            this._bitrate = _arg2;
            this._width = _arg3;
            this._height = _arg4;
        }
        public function get streamName():String{
            return (this._stream);
        }
        public function set streamName(_arg1:String):void{
            this._stream = _arg1;
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function set bitrate(_arg1:Number):void{
            this._bitrate = _arg1;
        }
        public function get width():int{
            return (this._width);
        }
        public function set width(_arg1:int):void{
            this._width = _arg1;
        }
        public function get height():int{
            return (this._height);
        }
        public function set height(_arg1:int):void{
            this._height = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.net.metrics.*;
    import org.osmf.net.rules.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class RuleSwitchManagerBase extends NetStreamSwitchManagerBase {

        private var _metricRepository:MetricRepository;
        private var _emergencyRules:Vector.<RuleBase> = null;
        private var switcher:NetStreamSwitcher;
        private var notifier:EventDispatcher;

        public function RuleSwitchManagerBase(_arg1:EventDispatcher, _arg2:NetStreamSwitcher, _arg3:MetricRepository, _arg4:Vector.<RuleBase>=null, _arg5:Boolean=true){
            if (_arg1 == null){
                throw (new ArgumentError("Invalid netStream"));
            };
            if (_arg2 == null){
                throw (new ArgumentError("Invalid switcher"));
            };
            if (_arg3 == null){
                throw (new ArgumentError("Invalid metric repository"));
            };
            this.notifier = _arg1;
            this.switcher = _arg2;
            this._metricRepository = _arg3;
            if (_arg4 != null){
                this._emergencyRules = _arg4.slice();
            };
            this.autoSwitch = _arg5;
        }
        override public function set autoSwitch(_arg1:Boolean):void{
            super.autoSwitch = _arg1;
            if (_arg1){
                this.notifier.addEventListener(HTTPStreamingEvent.RUN_ALGORITHM, this.onRunAlgorithm);
            } else {
                this.notifier.removeEventListener(HTTPStreamingEvent.RUN_ALGORITHM, this.onRunAlgorithm);
            };
        }
        public function get actualIndex():int{
            return (this.switcher.actualIndex);
        }
        public function get metricRepository():MetricRepository{
            return (this._metricRepository);
        }
        public function get emergencyRules():Vector.<RuleBase>{
            return (this._emergencyRules);
        }
        public function getNewIndex():uint{
            throw (new IllegalOperationError("The getNewIndex() function must be overriden by the subclass."));
        }
        public function getNewEmergencyIndex(_arg1:Number):uint{
            throw (new IllegalOperationError("The getNewEmergencyIndex() function must be overriden by the subclass."));
        }
        override public function get currentIndex():uint{
            return (this.switcher.currentIndex);
        }
        override public function switchTo(_arg1:int):void{
            if (!_autoSwitch){
                if ((((_arg1 < 0)) || ((_arg1 > maxAllowedIndex)))){
                    throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
                };
                this.switcher.switchTo(_arg1);
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_STREAM_NOT_IN_MANUAL_MODE)));
            };
        }
        private function onRunAlgorithm(_arg1:HTTPStreamingEvent):void{
            var _local3:RuleBase;
            var _local4:uint;
            var _local5:Recommendation;
            var _local2:Number = Number.POSITIVE_INFINITY;
            for each (_local3 in this._emergencyRules) {
                _local5 = _local3.getRecommendation();
                if (_local5.confidence == 1){
                    _local2 = _local5.bitrate;
                };
            };
            _local4 = 0;
            if (_local2 < Number.POSITIVE_INFINITY){
                _local4 = this.getNewEmergencyIndex(_local2);
            } else {
                _local4 = this.getNewIndex();
            };
            if (_local4 != this.switcher.actualIndex){
                _local4 = Math.min(_local4, maxAllowedIndex);
            } else {
                if (this.switcher.actualIndex > maxAllowedIndex){
                    _local4 = maxAllowedIndex;
                };
            };
            if (((!((_local4 == this.switcher.actualIndex))) && (!(this.switcher.switching)))){
                this.switcher.switchTo(_local4);
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.media.*;
    import org.osmf.metadata.*;
    import org.osmf.utils.*;

    public class NetStreamUtils {

        public static const PLAY_START_ARG_ANY:int = -2;
        public static const PLAY_START_ARG_LIVE:int = -1;
        public static const PLAY_START_ARG_RECORDED:int = 0;
        public static const PLAY_LEN_ARG_ALL:int = -1;

        public static function getStreamNameFromURL(_arg1:String, _arg2:Boolean=false):String{
            var _local4:FMSURL;
            var _local3 = "";
            if (_arg1 != null){
                if (isRTMPStream(_arg1)){
                    _local4 = new FMSURL(_arg1, _arg2);
                    _local3 = _local4.streamName;
                    if (((!((_local4.query == null))) && (!((_local4.query == ""))))){
                        _local3 = (_local3 + ("?" + _local4.query));
                    };
                } else {
                    _local3 = _arg1;
                };
            };
            return (_local3);
        }
        public static function isStreamingResource(_arg1:MediaResourceBase):Boolean{
            var _local3:URLResource;
            var _local2:Boolean;
            if (_arg1 != null){
                _local3 = (_arg1 as URLResource);
                if (_local3 != null){
                    _local2 = NetStreamUtils.isRTMPStream(_local3.url);
                    if (_local2 == false){
                        _local2 = !((_local3.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) == null));
                    };
                };
            };
            return (_local2);
        }
        public static function isRTMPStream(_arg1:String):Boolean{
            var _local3:URL;
            var _local4:String;
            var _local2:Boolean;
            if (_arg1 != null){
                _local3 = new URL(_arg1);
                _local4 = _local3.protocol;
                if (((!((_local4 == null))) && ((_local4.length > 0)))){
                    _local2 = !((_local4.search(/^rtmp$|rtmp[tse]$|rtmpte$/i) == -1));
                };
            };
            return (_local2);
        }
        public static function getStreamType(_arg1:MediaResourceBase):String{
            var _local2:String = StreamType.RECORDED;
            var _local3:StreamingURLResource = (_arg1 as StreamingURLResource);
            if (_local3 != null){
                _local2 = _local3.streamType;
            };
            return (_local2);
        }
        public static function getPlayArgsForResource(_arg1:MediaResourceBase):Object{
            var _local4:StreamingURLResource;
            var _local2:Number = PLAY_START_ARG_ANY;
            var _local3:Number = PLAY_LEN_ARG_ALL;
            switch (getStreamType(_arg1)){
                case StreamType.LIVE_OR_RECORDED:
                    _local2 = PLAY_START_ARG_ANY;
                    break;
                case StreamType.LIVE:
                    _local2 = PLAY_START_ARG_LIVE;
                    break;
                case StreamType.RECORDED:
                    _local2 = PLAY_START_ARG_RECORDED;
                    break;
            };
            if (((!((_local2 == PLAY_START_ARG_LIVE))) && (!((_arg1 == null))))){
                _local4 = (_arg1 as StreamingURLResource);
                if (((!((_local4 == null))) && (isStreamingResource(_local4)))){
                    if (!isNaN(_local4.clipStartTime)){
                        _local2 = _local4.clipStartTime;
                    };
                    if (!isNaN(_local4.clipEndTime)){
                        _local2 = Math.max(0, _local2);
                        _local3 = Math.max(0, (_local4.clipEndTime - _local2));
                    };
                };
            };
            return ({
                start:_local2,
                len:_local3
            });
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net.httpstreaming {
    import flash.events.*;
    import flash.net.*;

    public class HTTPStreamRequest {

        private var _kind:String = null;
        private var _retryAfter:int = -1;
        private var _bestEffortDownloaderMonitor:IEventDispatcher = null;
        private var _urlRequest:URLRequest = null;

        public function HTTPStreamRequest(_arg1:String, _arg2:String=null, _arg3:Number=-1, _arg4:IEventDispatcher=null){
            this._kind = _arg1;
            if (_arg2){
                this._urlRequest = new URLRequest(HTTPStreamingUtils.normalizeURL(_arg2));
            } else {
                this._urlRequest = null;
            };
            this._retryAfter = _arg3;
            this._bestEffortDownloaderMonitor = _arg4;
        }
        public function get kind():String{
            return (this._kind);
        }
        public function get retryAfter():int{
            return (this._retryAfter);
        }
        public function get bestEffortDownloaderMonitor():IEventDispatcher{
            return (this._bestEffortDownloaderMonitor);
        }
        public function get urlRequest():URLRequest{
            return (this._urlRequest);
        }
        public function get url():String{
            if (this._urlRequest == null){
                return (null);
            };
            return (this._urlRequest.url);
        }
        public function toString():String{
            var _local1:String = ("[HTTPStreamRequest kind=" + this.kind);
            switch (this.kind){
                case HTTPStreamRequestKind.BEST_EFFORT_DOWNLOAD:
                case HTTPStreamRequestKind.DOWNLOAD:
                    _local1 = (_local1 + (", url=" + this.url));
                    break;
                case HTTPStreamRequestKind.LIVE_STALL:
                case HTTPStreamRequestKind.RETRY:
                    _local1 = (_local1 + (", retryAfter=" + this.retryAfter));
                    break;
                case HTTPStreamRequestKind.DONE:
            };
            _local1 = (_local1 + "]");
            return (_local1);
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.utils.*;

    public class HTTPStreamSource implements IHTTPStreamSource, IHTTPStreamHandler {

        private var _dispatcher:IEventDispatcher = null;
        private var _resource:MediaResourceBase = null;
        private var _qosInfo:HTTPStreamHandlerQoSInfo;
        private var _downloader:HTTPStreamDownloader = null;
        private var _request:HTTPStreamRequest = null;
        private var _indexHandler:HTTPStreamingIndexHandlerBase = null;
        private var _fileHandler:HTTPStreamingFileHandlerBase = null;
        private var _indexInfo:HTTPStreamingIndexInfoBase = null;
        private var _streamName:String = null;
        private var _seekTarget:Number = -1;
        private var _didBeginSeek:Boolean = false;
        private var _didCompleteSeek:Boolean = false;
        private var _streamNames:Array = null;
        private var _qualityRates:Array = null;
        private var _numQualityLevels:int = 0;
        private var _qualityLevel:int = 0;
        private var _qualityLevelChanged:Boolean = false;
        private var _desiredQualityLevel:int = -1;
        private var _desiredQualityStreamName:String = null;
        private var _qualityAndStreamNameInSync:Boolean = false;
        private var _fragmentDuration:Number = 0;
        private var _endFragment:Boolean = false;
        private var _indexDownloaderMonitor:EventDispatcher;
        private var _indexDownloader:HTTPStreamDownloader;
        private var _currentIndexDownloadEvent:HTTPStreamingIndexHandlerEvent = null;
        private var _pendingIndexDownloadRequests:Vector.<HTTPStreamingIndexHandlerEvent>;
        private var _pendingIndexDownloadRequestsLenght:int = 0;
        private var _hasErrors:Boolean = false;
        private var _isReady:Boolean = false;
        private var _ratesAreReady:Boolean = false;
        private var _endOfStream:Boolean = false;
        private var _isLive:Boolean = false;
        private var _offset:Number = -1;
        private var _dvrInfo:DVRInfo = null;
        private var _state:String = null;
        private var _retryAfterTime:Number = -1;
        private var _bestEffortDownloadResult:String = null;
        private var _isLiveStalled:Boolean = false;

        public function HTTPStreamSource(_arg1:HTTPStreamingFactory, _arg2:MediaResourceBase, _arg3:IEventDispatcher){
            this._indexDownloaderMonitor = new EventDispatcher();
            this._indexDownloader = new HTTPStreamDownloader();
            this._pendingIndexDownloadRequests = new Vector.<HTTPStreamingIndexHandlerEvent>();
            super();
            if (_arg3 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (_arg2 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this._dispatcher = _arg3;
            this._resource = _arg2;
            this._fileHandler = _arg1.createFileHandler(_arg2);
            if (this._fileHandler == null){
                throw (new ArgumentError("Null file handler in HTTPStreamSourceHandler constructor. Probably invalid factory object or resource."));
            };
            this._indexHandler = _arg1.createIndexHandler(_arg2, this._fileHandler);
            if (this._indexHandler == null){
                throw (new ArgumentError("Null index handler in HTTPStreamSourceHandler constructor. Probably invalid factory object or resource."));
            };
            this._indexInfo = _arg1.createIndexInfo(_arg2);
            this._fileHandler.addEventListener(HTTPStreamingEvent.FRAGMENT_DURATION, this.onFragmentDuration);
            this._fileHandler.addEventListener(HTTPStreamingEvent.SCRIPT_DATA, this.onScriptData);
            this._fileHandler.addEventListener(HTTPStreamingEvent.FILE_ERROR, this.onError);
            this._indexHandler.addEventListener(HTTPStreamingIndexHandlerEvent.INDEX_READY, this.onIndexReady);
            this._indexHandler.addEventListener(HTTPStreamingIndexHandlerEvent.RATES_READY, this.onRatesReady);
            this._indexHandler.addEventListener(HTTPStreamingIndexHandlerEvent.REQUEST_LOAD_INDEX, this.onRequestLoadIndex);
            this._indexHandler.addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, this.onDVRStreamInfo);
            this._indexHandler.addEventListener(HTTPStreamingEvent.FRAGMENT_DURATION, this.onFragmentDuration);
            this._indexHandler.addEventListener(HTTPStreamingEvent.SCRIPT_DATA, this.onScriptData);
            this._indexHandler.addEventListener(HTTPStreamingEvent.INDEX_ERROR, this.onError);
            this._indexHandler.addEventListener(HTTPStreamingEvent.DOWNLOAD_CONTINUE, this.onBestEffortDownloadEvent);
            this._indexHandler.addEventListener(HTTPStreamingEvent.DOWNLOAD_SKIP, this.onBestEffortDownloadEvent);
            this._indexHandler.addEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onBestEffortDownloadEvent);
            this._indexHandler.addEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onBestEffortDownloadEvent);
            this._indexDownloaderMonitor.addEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onIndexComplete);
            this._indexDownloaderMonitor.addEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onIndexError);
            this.setState(HTTPStreamingState.INIT);
        }
        public function get source():IHTTPStreamSource{
            return (this);
        }
        public function get isReady():Boolean{
            return (this._isReady);
        }
        public function get endOfStream():Boolean{
            return (this._endOfStream);
        }
        public function get hasErrors():Boolean{
            return (this._hasErrors);
        }
        public function get isLiveStalled():Boolean{
            return (this._isLiveStalled);
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get qosInfo():HTTPStreamHandlerQoSInfo{
            return (this._qosInfo);
        }
        public function get isOpen():Boolean{
            return (!((this._streamName == null)));
        }
        public function open(_arg1:String):void{
            if (this._streamName != null){
                this.close();
            };
            this._streamName = _arg1;
            this._qualityAndStreamNameInSync = false;
            this._indexHandler.initialize(((this._indexInfo)!=null) ? this._indexInfo : _arg1);
        }
        public function close():void{
            if (this._downloader != null){
                this._downloader.close();
            };
            this._indexHandler.dispose();
            this._endFragment = true;
            this._endOfStream = true;
            this._streamName = null;
        }
        public function seek(_arg1:Number):void{
            this._endOfStream = false;
            this._hasErrors = false;
            this._isLiveStalled = false;
            this._seekTarget = _arg1;
            this._didBeginSeek = false;
            this._didCompleteSeek = false;
            if (this._seekTarget < 0){
                if (this._dvrInfo != null){
                    this._seekTarget = Math.floor(((this._dvrInfo.startTime + this._dvrInfo.curLength) - OSMFSettings.hdsDVRLiveOffset));
                } else {
                    if (this._isLive){
                        this._seekTarget = Math.floor(this._offset);
                    } else {
                        this._seekTarget = 0;
                    };
                };
            };
            this.setState(HTTPStreamingState.SEEK);
        }
        public function getBytes():ByteArray{
            return (this.doSomeProcessingAndGetBytes());
        }
        public function getDVRInfo(_arg1:Object):void{
            this._indexHandler.dvrGetStreamInfo(((this._indexInfo)!=null) ? this._indexInfo : _arg1);
        }
        public function changeQualityLevel(_arg1:String):void{
            var _local3:int;
            var _local2 = -1;
            if (this._streamNames != null){
                _local3 = 0;
                while (_local3 < this._streamNames.length) {
                    if (_arg1 == this._streamNames[_local3]){
                        _local2 = _local3;
                        break;
                    };
                    _local3++;
                };
            };
            if (_local2 == -1){
                throw (new Error("Quality level cannot be set at this time."));
            };
            if (_local2 != this._desiredQualityLevel){
                this.beginQualityLevelChange(_local2);
            };
        }
        public function get isBestEffortFetchEnabled():Boolean{
            return (((!((this._indexHandler == null))) && (this._indexHandler.isBestEffortFetchEnabled)));
        }
        public function get fragmentDuration():Number{
            return (this._fragmentDuration);
        }
        protected function doSomeProcessingAndGetBytes():ByteArray{
            var _local3:Date;
            var _local4:Boolean;
            var _local5:Vector.<QualityLevel>;
            var _local6:String;
            var _local7:String;
            var _local8:FragmentDetails;
            var _local9:IEventDispatcher;
            var _local10:uint;
            var _local1:ByteArray;
            var _local2:IDataInput;
            switch (this._state){
                case HTTPStreamingState.INIT:
                    break;
                case HTTPStreamingState.SEEK:
                    if (this._downloader != null){
                        this._downloader.close();
                        this._fileHandler.flushFileSegment(this._downloader.getBytes());
                    };
                    this.setState(HTTPStreamingState.LOAD);
                    break;
                case HTTPStreamingState.WAIT:
                    _local3 = new Date();
                    if (_local3.getTime() > this._retryAfterTime){
                        this.setState(HTTPStreamingState.LOAD);
                    };
                    break;
                case HTTPStreamingState.LOAD:
                    if (this._qualityLevelChanged){
                        this.endQualityLevelChange();
                    };
                    this._fragmentDuration = -1;
                    this._endOfStream = false;
                    _local4 = false;
                    if (!this._didBeginSeek){
                        this._request = this._indexHandler.getFileForTime(this._seekTarget, this._qualityLevel);
                        _local4 = true;
                    } else {
                        this._request = this._indexHandler.getNextFile(this._qualityLevel);
                    };
                    this._isLiveStalled = (this._request.kind == HTTPStreamRequestKind.LIVE_STALL);
                    switch (this._request.kind){
                        case HTTPStreamRequestKind.DOWNLOAD:
                        case HTTPStreamRequestKind.BEST_EFFORT_DOWNLOAD:
                            if (_local4){
                                this._didBeginSeek = true;
                            };
                            if (this._downloader == null){
                                this._downloader = new HTTPStreamDownloader();
                            };
                            _local9 = this._dispatcher;
                            if (this._request.kind == HTTPStreamRequestKind.BEST_EFFORT_DOWNLOAD){
                                _local9 = this._request.bestEffortDownloaderMonitor;
                                this._bestEffortDownloadResult = null;
                            };
                            this._downloader.open(this._request.urlRequest, _local9, OSMFSettings.hdsFragmentDownloadTimeout);
                            this.setState(HTTPStreamingState.BEGIN_FRAGMENT);
                            break;
                        case HTTPStreamRequestKind.RETRY:
                        case HTTPStreamRequestKind.LIVE_STALL:
                            _local3 = new Date();
                            this._retryAfterTime = (_local3.getTime() + (1000 * this._request.retryAfter));
                            this.setState(HTTPStreamingState.WAIT);
                            break;
                        case HTTPStreamRequestKind.DONE:
                            this._endFragment = true;
                            this._endOfStream = true;
                            if (this._downloader != null){
                                _local1 = this._fileHandler.flushFileSegment(this._downloader.getBytes());
                            };
                            this.setState(HTTPStreamingState.STOP);
                            break;
                    };
                    break;
                case HTTPStreamingState.BEGIN_FRAGMENT:
                    if (this._request.kind == HTTPStreamRequestKind.BEST_EFFORT_DOWNLOAD){
                        if (this._bestEffortDownloadResult == null){
                            break;
                        };
                        if (this._bestEffortDownloadResult == HTTPStreamingEvent.DOWNLOAD_ERROR){
                            break;
                        };
                        if (this._bestEffortDownloadResult == HTTPStreamingEvent.DOWNLOAD_SKIP){
                            this.setState(HTTPStreamingState.LOAD);
                            break;
                        };
                        if (this._bestEffortDownloadResult == HTTPStreamingEvent.DOWNLOAD_CONTINUE){
                        } else {
                            break;
                        };
                        this._isLiveStalled = false;
                    };
                    this._endFragment = false;
                    this._hasErrors = false;
                    if (!this._didCompleteSeek){
                        this._fileHandler.beginProcessFile(true, this._seekTarget);
                        this._didCompleteSeek = true;
                    } else {
                        this._fileHandler.beginProcessFile(false, 0);
                    };
                    this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.BEGIN_FRAGMENT, false, true, NaN, null, null, this._streamName));
                    this.setState(HTTPStreamingState.READ);
                    break;
                case HTTPStreamingState.READ:
                    if (this._downloader != null){
                        _local2 = this._downloader.getBytes(this._fileHandler.inputBytesNeeded);
                        if (_local2 != null){
                            _local1 = this._fileHandler.processFileSegment(_local2);
                        } else {
                            this._endFragment = ((((((!((this._downloader == null))) && (this._downloader.isOpen))) && (this._downloader.isComplete))) && (!(this._downloader.hasData)));
                            this._hasErrors = ((!((this._downloader == null))) && (this._downloader.hasErrors));
                        };
                    };
                    if (this._state == HTTPStreamingState.READ){
                        if (this._endFragment){
                            if (this._downloader != null){
                                this._downloader.saveRemainingBytes();
                            };
                            this.setState(HTTPStreamingState.END_FRAGMENT);
                        };
                    };
                    break;
                case HTTPStreamingState.END_FRAGMENT:
                    if (this._downloader != null){
                        _local2 = this._downloader.getBytes();
                        if (_local2 != null){
                            _local1 = this._fileHandler.endProcessFile(_local2);
                        };
                    };
                    _local5 = new Vector.<QualityLevel>();
                    _local10 = 0;
                    while (_local10 < this._qualityRates.length) {
                        _local5.push(new QualityLevel(_local10, this._qualityRates[_local10], this._streamNames[_local10]));
                        _local10++;
                    };
                    _local6 = this._request.urlRequest.url;
                    _local7 = this._request.urlRequest.url.substr(_local6.lastIndexOf("Seg"));
                    _local8 = new FragmentDetails(this._downloader.downloadBytesCount, this._fragmentDuration, this._downloader.downloadDuration, this._qualityLevel, _local7);
                    this._qosInfo = new HTTPStreamHandlerQoSInfo(_local5, this._qualityLevel, _local8);
                    this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.END_FRAGMENT, false, true, NaN, null, null, this._streamName));
                    this.setState(HTTPStreamingState.LOAD);
                    break;
            };
            return (_local1);
        }
        protected function setState(_arg1:String):void{
            this._state = _arg1;
        }
        private function onDVRStreamInfo(_arg1:DVRStreamInfoEvent):void{
            this._dvrInfo = (_arg1.info as DVRInfo);
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function onIndexReady(_arg1:HTTPStreamingIndexHandlerEvent):void{
            this._isReady = true;
            this._isLive = _arg1.live;
            this._offset = _arg1.offset;
            if (!this._qualityAndStreamNameInSync){
                this._qualityAndStreamNameInSync = true;
                this.changeQualityLevel(this._streamName);
            };
        }
        private function onRatesReady(_arg1:HTTPStreamingIndexHandlerEvent):void{
            this._ratesAreReady = true;
            this._qualityRates = _arg1.rates;
            this._streamNames = _arg1.streamNames;
            this._numQualityLevels = this._qualityRates.length;
        }
        private function onRequestLoadIndex(_arg1:HTTPStreamingIndexHandlerEvent):void{
            this._pendingIndexDownloadRequests[this._pendingIndexDownloadRequestsLenght] = _arg1;
            this._pendingIndexDownloadRequestsLenght++;
            if (this._currentIndexDownloadEvent == null){
                this._currentIndexDownloadEvent = _arg1;
                this._indexDownloader.open(this._currentIndexDownloadEvent.request, this._indexDownloaderMonitor, OSMFSettings.hdsIndexDownloadTimeout);
            };
        }
        private function onIndexComplete(_arg1:HTTPStreamingEvent):void{
            this._dispatcher.dispatchEvent(_arg1);
            var _local2:IDataInput = this._indexDownloader.getBytes(this._indexDownloader.downloadBytesCount);
            var _local3:ByteArray = new ByteArray();
            _local2.readBytes(_local3, 0, _local2.bytesAvailable);
            _local3.position = 0;
            this._indexHandler.processIndexData(_local3, this._currentIndexDownloadEvent.requestContext);
            this.processPendingIndexLoadingRequest();
        }
        private function onIndexError(_arg1:HTTPStreamingEvent):void{
            if (this._indexDownloader != null){
                this._indexDownloader.close();
            };
            this._currentIndexDownloadEvent = null;
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function processPendingIndexLoadingRequest():void{
            this._pendingIndexDownloadRequests.shift();
            this._pendingIndexDownloadRequestsLenght--;
            if (this._pendingIndexDownloadRequestsLenght == 0){
                if (this._indexDownloader != null){
                    this._indexDownloader.close();
                };
                this._currentIndexDownloadEvent = null;
            } else {
                this._currentIndexDownloadEvent = this._pendingIndexDownloadRequests[0];
                this._indexDownloader.open(this._currentIndexDownloadEvent.request, this._indexDownloaderMonitor, OSMFSettings.hdsIndexDownloadTimeout);
            };
        }
        private function onFragmentDuration(_arg1:HTTPStreamingEvent):void{
            this._fragmentDuration = _arg1.fragmentDuration;
        }
        private function onScriptData(_arg1:HTTPStreamingEvent):void{
            this._dispatcher.dispatchEvent(new HTTPStreamingEvent(_arg1.type, _arg1.bubbles, _arg1.cancelable, _arg1.fragmentDuration, _arg1.scriptDataObject, _arg1.scriptDataMode, this._streamName));
        }
        private function onError(_arg1:HTTPStreamingEvent):void{
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function beginQualityLevelChange(_arg1:int):void{
            this._qualityLevelChanged = true;
            this._desiredQualityLevel = _arg1;
            this._desiredQualityStreamName = this._streamNames[this._desiredQualityLevel];
            this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.TRANSITION, false, false, NaN, null, null, this._desiredQualityStreamName));
        }
        private function endQualityLevelChange():void{
            this._qualityLevel = this._desiredQualityLevel;
            this._streamName = this._desiredQualityStreamName;
            this._desiredQualityLevel = -1;
            this._desiredQualityStreamName = null;
            this._qualityLevelChanged = false;
            this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.TRANSITION_COMPLETE, false, false, NaN, null, null, this._streamName));
        }
        private function onBestEffortDownloadEvent(_arg1:HTTPStreamingEvent):void{
            if (_arg1.type == HTTPStreamingEvent.DOWNLOAD_COMPLETE){
                this.forwardEventToDispatcher(_arg1);
            } else {
                if (this._bestEffortDownloadResult != null){
                    return;
                };
                this._bestEffortDownloadResult = _arg1.type;
                this.forwardEventToDispatcher(_arg1);
            };
        }
        private function forwardEventToDispatcher(_arg1:Event):void{
            if (this._dispatcher != null){
                this._dispatcher.dispatchEvent(_arg1);
            };
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import flash.net.*;
    import org.osmf.net.qos.*;
    import org.osmf.net.metrics.*;
    import org.osmf.net.rules.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.net.httpstreaming.f4f.*;

    public class HTTPStreamingNetLoader extends NetLoader {

        protected static const BANDWIDTH_BUFFER_RULE_WEIGHTS:Vector.<Number> = new <Number>[7, 3];
;
        protected static const BANDWIDTH_BUFFER_RULE_BUFFER_FRAGMENTS_THRESHOLD:uint = 2;
        protected static const AFTER_UP_SWITCH_BANDWIDTH_BUFFER_RULE_BUFFER_FRAGMENTS_THRESHOLD:uint = 2;
        protected static const AFTER_UP_SWITCH_BANDWIDTH_BUFFER_RULE_MIN_RATIO:Number = 0.5;
        protected static const EMPTY_BUFFER_RULE_SCALE_DOWN_FACTOR:Number = 0.4;
        private static const QOS_MAX_HISTORY_LENGTH:Number = 10;

        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            return (!(((_arg1.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) as Metadata) == null)));
        }
        override protected function createNetStream(_arg1:NetConnection, _arg2:URLResource):NetStream{
            var _local3:HTTPStreamingFactory = this.createHTTPStreamingFactory();
            var _local4:HTTPNetStream = new HTTPNetStream(_arg1, _local3, _arg2);
            return (_local4);
        }
        override protected function createNetStreamSwitchManager(_arg1:NetConnection, _arg2:NetStream, _arg3:DynamicStreamingResource):NetStreamSwitchManagerBase{
            var _local4:QoSInfoHistory = this.createNetStreamQoSInfoHistory(_arg2);
            var _local5:MetricFactory = this.createMetricFactory(_local4);
            var _local6:MetricRepository = new MetricRepository(_local5);
            var _local7:Vector.<RuleBase> = new Vector.<RuleBase>();
            var _local8:Vector.<Number> = new Vector.<Number>();
            _local7.push(new BufferBandwidthRule(_local6, BANDWIDTH_BUFFER_RULE_WEIGHTS, BANDWIDTH_BUFFER_RULE_BUFFER_FRAGMENTS_THRESHOLD));
            _local8.push(1);
            var _local9:Vector.<RuleBase> = new Vector.<RuleBase>();
            _local9.push(new DroppedFPSRule(_local6, 10, 0.1));
            _local9.push(new EmptyBufferRule(_local6, EMPTY_BUFFER_RULE_SCALE_DOWN_FACTOR));
            _local9.push(new AfterUpSwitchBufferBandwidthRule(_local6, AFTER_UP_SWITCH_BANDWIDTH_BUFFER_RULE_BUFFER_FRAGMENTS_THRESHOLD, AFTER_UP_SWITCH_BANDWIDTH_BUFFER_RULE_MIN_RATIO));
            var _local10:NetStreamSwitcher = new NetStreamSwitcher(_arg2, _arg3);
            return (new DefaultHTTPStreamingSwitchManager(_arg2, _local10, _local6, _local9, true, _local7, _local8));
        }
        override protected function processFinishLoading(_arg1:NetStreamLoadTrait):void{
            var netStream:* = null;
            var onDVRStreamInfo:* = null;
            var loadTrait:* = _arg1;
            onDVRStreamInfo = function (_arg1:DVRStreamInfoEvent):void{
                netStream.removeEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, onDVRStreamInfo);
                loadTrait.setTrait(new HTTPStreamingDVRCastDVRTrait(loadTrait.connection, netStream, (_arg1.info as DVRInfo)));
                loadTrait.setTrait(new HTTPStreamingDVRCastTimeTrait(loadTrait.connection, netStream, (_arg1.info as DVRInfo)));
                updateLoadTrait(loadTrait, LoadState.READY);
            };
            var resource:* = (loadTrait.resource as URLResource);
            if (!this.dvrMetadataPresent(resource)){
                updateLoadTrait(loadTrait, LoadState.READY);
                return;
            };
            netStream = (loadTrait.netStream as HTTPNetStream);
            netStream.addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, onDVRStreamInfo);
            netStream.DVRGetStreamInfo(null);
        }
        protected function createNetStreamQoSInfoHistory(_arg1:NetStream):QoSInfoHistory{
            return (new QoSInfoHistory(_arg1, QOS_MAX_HISTORY_LENGTH));
        }
        protected function createMetricFactory(_arg1:QoSInfoHistory):MetricFactory{
            return (new DefaultMetricFactory(_arg1));
        }
        protected function createHTTPStreamingFactory():HTTPStreamingFactory{
            return (new HTTPStreamingF4FFactory());
        }
        private function dvrMetadataPresent(_arg1:URLResource):Boolean{
            var _local2:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.DVR_METADATA) as Metadata);
            return (!((_local2 == null)));
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.events.*;
    import flash.events.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.flv.*;
    import org.osmf.utils.*;

    public class HTTPStreamMixer extends EventDispatcher implements IHTTPStreamSource {

        private static const FILTER_NONE:uint = 0;
        private static const FILTER_VIDEO:uint = 1;
        private static const FILTER_AUDIO:uint = 2;
        private static const FILTER_DATA:uint = 4;
        private static const FILTER_ALL:uint = 0xFF;
        private static const HIGH_PRIORITY:int = 10000;

        private var _dispatcher:IEventDispatcher = null;
        private var _currentTime:uint = 0;
        private var _mediaTime:int = -1;
        private var _alternateTime:int = -1;
        private var _mediaTag:FLVTag = null;
        private var _mediaTagDataLoaded:Boolean = true;
        private var _mediaInput:ByteArray;
        private var _mediaFilterTags:uint = 0;
        private var _mediaHandler:IHTTPStreamHandler = null;
        private var _desiredMediaHandler:IHTTPStreamHandler = null;
        private var _mediaNeedsInitialization:Boolean = false;
        private var _mediaNeedsMoreData:Boolean = false;
        private var _alternateTag:FLVTag = null;
        private var _alternateTagDataLoaded:Boolean = true;
        private var _alternateInput:ByteArray;
        private var _alternateFilterTags:uint = 0;
        private var _alternateHandler:IHTTPStreamHandler = null;
        private var _desiredAlternateHandler:IHTTPStreamHandler = null;
        private var _alternateNeedsInitialization:Boolean = false;
        private var _alternateNeedsMoreData:Boolean = false;
        private var _alternateNeedsSynchronization:Boolean = true;
        private var _alternateIgnored:Boolean = false;
        private var _state:String = null;
        private var _fragmentDuration:Number = 0;

        public function HTTPStreamMixer(_arg1:IEventDispatcher){
            this._mediaInput = new ByteArray();
            this._alternateInput = new ByteArray();
            super();
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this._dispatcher = _arg1;
            addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, this.onDVRStreamInfo, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.SCRIPT_DATA, this.onScriptData, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.BEGIN_FRAGMENT, this.onBeginFragment, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.END_FRAGMENT, this.onEndFragment, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.TRANSITION, this.onHTTPStreamingEvent, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.TRANSITION_COMPLETE, this.onHTTPStreamingEvent, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onHTTPStreamingEvent, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.FRAGMENT_DURATION, this.onFragmentDuration, false, HIGH_PRIORITY, true);
            addEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onHTTPStreamingEvent, false, HIGH_PRIORITY, true);
            this.setState(HTTPStreamingState.INIT);
            this._alternateIgnored = true;
        }
        public function get isReady():Boolean{
            return (((!((this.video == null))) && (this.video.source.isReady)));
        }
        public function get endOfStream():Boolean{
            return (((!((this.video == null))) && (this.video.source.endOfStream)));
        }
        public function get hasErrors():Boolean{
            return (((!((this.video == null))) && (this.video.source.hasErrors)));
        }
        public function get isLiveStalled():Boolean{
            return (((((!((this.video == null))) && (!((this.video.source == null))))) && (this.video.source.isLiveStalled)));
        }
        public function close():void{
            this.setState(HTTPStreamingState.HALT);
            this.clearBuffers();
            if (this._alternateHandler != null){
                this._alternateHandler.close();
            };
            if (((!((this._desiredAlternateHandler == null))) && (!((this._desiredAlternateHandler == this._alternateHandler))))){
                this._desiredAlternateHandler.close();
            };
            if (this._mediaHandler != null){
                this._mediaHandler.close();
            };
            if (((!((this._desiredMediaHandler == null))) && (!((this._desiredMediaHandler == this._mediaHandler))))){
                this._desiredMediaHandler.close();
            };
        }
        public function seek(_arg1:Number):void{
            this.setState(HTTPStreamingState.SEEK);
            this.clearBuffers();
            this._currentTime = 0;
            this._alternateIgnored = (this._alternateHandler == null);
            this.updateFilters();
            if (this._mediaHandler != null){
                this._mediaHandler.source.seek(_arg1);
            };
            if (((!((this._desiredMediaHandler == null))) && (!((this._desiredMediaHandler == this._mediaHandler))))){
                this._desiredMediaHandler.source.seek(_arg1);
            };
            if (this._alternateHandler != null){
                this._alternateHandler.source.seek(_arg1);
            };
            if (((!((this._desiredAlternateHandler == null))) && (!((this._desiredAlternateHandler == this._alternateHandler))))){
                this._desiredAlternateHandler.source.seek(_arg1);
            };
        }
        public function getBytes():ByteArray{
            return (this.doSomeProcessingAndGetBytes());
        }
        public function get audio():IHTTPStreamHandler{
            return (this._desiredAlternateHandler);
        }
        public function set audio(_arg1:IHTTPStreamHandler):void{
            if (this._desiredAlternateHandler != _arg1){
                this._desiredAlternateHandler = _arg1;
                this._alternateNeedsInitialization = true;
                this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.TRANSITION, false, false, NaN, null, null, ((this._desiredAlternateHandler)!=null) ? this._desiredAlternateHandler.streamName : null));
            };
        }
        public function get video():IHTTPStreamHandler{
            return (this._desiredMediaHandler);
        }
        public function set video(_arg1:IHTTPStreamHandler):void{
            if (_arg1 == null){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            if (this._desiredMediaHandler != _arg1){
                this._desiredMediaHandler = _arg1;
                this._mediaNeedsInitialization = true;
            };
        }
        public function get fragmentDuration():Number{
            return (this._fragmentDuration);
        }
        public function get isBestEffortFetchEnabled():Boolean{
            return (((((!((this._desiredMediaHandler == null))) && (!((this._desiredMediaHandler.source == null))))) && (this._desiredMediaHandler.source.isBestEffortFetchEnabled)));
        }
        protected function doSomeProcessingAndGetBytes():ByteArray{
            var _local2:int;
            var _local3:ByteArray;
            var _local4:ByteArray;
            var _local1:ByteArray;
            switch (this._state){
                case HTTPStreamingState.INIT:
                    break;
                case HTTPStreamingState.SEEK:
                    this.setState(HTTPStreamingState.READ);
                    break;
                case HTTPStreamingState.READ:
                    _local1 = this.internalMixBytes();
                    if (_local1.length == 0){
                        _local1 = null;
                    } else {
                        _local1.position = 0;
                    };
                    if (((((this._mediaNeedsInitialization) && ((this._mediaTag == null)))) || (((this._alternateNeedsInitialization) && ((this._alternateTag == null)))))){
                        this.updateHandlers();
                        this.updateFilters();
                    };
                    if (((this._alternateNeedsSynchronization) && (((!((this._mediaTime == -1))) || (!((this._alternateTime == -1))))))){
                        this._alternateNeedsSynchronization = false;
                        if (this._alternateHandler != null){
                            _local2 = ((this._alternateTime)!=-1) ? this._alternateTime : this._mediaTime;
                            this._alternateHandler.source.seek((_local2 / 1000));
                        };
                    };
                    this._mediaNeedsMoreData = ((((!(this._mediaTagDataLoaded)) || ((this._mediaInput.bytesAvailable == 0)))) || (((!((this._mediaInput.bytesAvailable == 0))) && ((this._mediaTag == null)))));
                    this._alternateNeedsMoreData = ((((!(this._alternateTagDataLoaded)) || ((this._alternateInput.bytesAvailable == 0)))) || (((!((this._alternateInput.bytesAvailable == 0))) && ((this._alternateTag == null)))));
                    if (((this._mediaNeedsMoreData) || (this._alternateNeedsMoreData))){
                        _local3 = null;
                        if (((((((!(this._alternateIgnored)) && (this._alternateNeedsMoreData))) && (!((this._alternateHandler == null))))) && (this._alternateHandler.source.isReady))){
                            _local3 = this._alternateHandler.source.getBytes();
                            if ((((_local3 == null)) && (((this._alternateHandler.source.hasErrors) || (this._alternateHandler.source.endOfStream))))){
                                this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.ACTION_NEEDED, false, false, NaN, null, null, ((this._alternateHandler)!=null) ? this._alternateHandler.streamName : null));
                                this._alternateIgnored = true;
                                this.updateFilters();
                            };
                        };
                        _local4 = null;
                        if (((((this._mediaNeedsMoreData) && (!((this._mediaHandler == null))))) && (this._mediaHandler.source.isReady))){
                            _local4 = this._mediaHandler.source.getBytes();
                        };
                        if (((!((_local4 == null))) || (!((_local3 == null))))){
                            this.updateBuffers(_local4, _local3);
                        };
                    };
                    break;
            };
            return (_local1);
        }
        private function internalMixBytes():ByteArray{
            var _local1:ByteArray = new ByteArray();
            var _local2:Boolean;
            while (_local2) {
                if (this._mediaTag == null){
                    this._mediaTagDataLoaded = false;
                };
                while (((!(this._mediaTagDataLoaded)) && (this._mediaInput.bytesAvailable))) {
                    if ((((this._mediaTag == null)) && ((this._mediaInput.bytesAvailable < FLVTag.TAG_HEADER_BYTE_COUNT)))){
                        return (_local1);
                    };
                    if (this._mediaTag == null){
                        this._mediaTag = this.createTag(this._mediaInput.readByte());
                        this._mediaTag.readRemainingHeader(this._mediaInput);
                    };
                    if (!this._mediaTagDataLoaded){
                        if (this._mediaInput.bytesAvailable < (this._mediaTag.dataSize + FLVTag.PREV_TAG_BYTE_COUNT)){
                            return (_local1);
                        };
                        if (this.shouldFilterTag(this._mediaTag, this._mediaFilterTags)){
                            this._mediaInput.position = (this._mediaInput.position + (this._mediaTag.dataSize + FLVTag.PREV_TAG_BYTE_COUNT));
                            this._mediaTag = null;
                        } else {
                            this._mediaTag.readData(this._mediaInput);
                            this._mediaTag.readPrevTag(this._mediaInput);
                            this._mediaTagDataLoaded = true;
                            this.updateTimes(this._mediaTag);
                        };
                    };
                };
                if (this._alternateTag == null){
                    this._alternateTagDataLoaded = false;
                };
                while (((((!(this._alternateIgnored)) && (!(this._alternateTagDataLoaded)))) && (this._alternateInput.bytesAvailable))) {
                    if ((((this._alternateTag == null)) && ((this._alternateInput.bytesAvailable < FLVTag.TAG_HEADER_BYTE_COUNT)))){
                        return (_local1);
                    };
                    if (this._alternateTag == null){
                        this._alternateTag = this.createTag(this._alternateInput.readByte());
                        this._alternateTag.readRemainingHeader(this._alternateInput);
                    };
                    if (!this._alternateTagDataLoaded){
                        if (this._alternateInput.bytesAvailable < (this._alternateTag.dataSize + FLVTag.PREV_TAG_BYTE_COUNT)){
                            return (_local1);
                        };
                        if (this.shouldFilterTag(this._alternateTag, this._alternateFilterTags)){
                            this._alternateInput.position = (this._alternateInput.position + (this._alternateTag.dataSize + FLVTag.PREV_TAG_BYTE_COUNT));
                            this._alternateTag = null;
                        } else {
                            this._alternateTag.readData(this._alternateInput);
                            this._alternateTag.readPrevTag(this._alternateInput);
                            this._alternateTagDataLoaded = true;
                            this.updateTimes(this._alternateTag);
                        };
                    };
                };
                if (((this._mediaTagDataLoaded) || (this._alternateTagDataLoaded))){
                    if (this._alternateIgnored){
                        this._currentTime = this._mediaTag.timestamp;
                        this._mediaTag.write(_local1);
                        this._mediaTag = null;
                        _local2 = true;
                    } else {
                        if ((((this._mediaTime > -1)) || ((this._alternateTime > -1)))){
                            if (((((((!((this._alternateTag == null))) && (this._alternateTagDataLoaded))) && ((this._alternateTag.timestamp >= this._currentTime)))) && ((this._alternateTag.timestamp <= this._mediaTime)))){
                                this._currentTime = this._alternateTag.timestamp;
                                this._alternateTag.write(_local1);
                                this._alternateTag = null;
                            } else {
                                if (((((((!((this._mediaTag == null))) && (this._mediaTagDataLoaded))) && ((this._mediaTag.timestamp >= this._currentTime)))) && ((this._mediaTag.timestamp <= this._alternateTime)))){
                                    this._currentTime = this._mediaTag.timestamp;
                                    this._mediaTag.write(_local1);
                                    this._mediaTag = null;
                                };
                            };
                            _local2 = ((this._mediaInput.bytesAvailable) && (this._alternateInput.bytesAvailable));
                        } else {
                            if (((!((this._alternateTime == -1))) && (this._alternateNeedsSynchronization))){
                                this._alternateNeedsSynchronization = false;
                            };
                            _local2 = false;
                        };
                    };
                } else {
                    _local2 = false;
                };
            };
            return (_local1);
        }
        private function updateBuffers(_arg1:IDataInput, _arg2:IDataInput):void{
            var _local3:ByteArray = new ByteArray();
            if ((((((this._mediaTag == null)) && (!((this._mediaInput.position == 0))))) && ((this._mediaInput.bytesAvailable < (this._mediaInput.length / 2))))){
                this._mediaInput.readBytes(_local3, 0, this._mediaInput.bytesAvailable);
                this._mediaInput.clear();
                _local3.readBytes(this._mediaInput, 0, _local3.bytesAvailable);
                _local3.clear();
            };
            if ((((((this._alternateTag == null)) && (!((this._alternateInput.position == 0))))) && ((this._alternateInput.bytesAvailable < (this._alternateInput.length / 2))))){
                this._alternateInput.readBytes(_local3, 0, this._alternateInput.bytesAvailable);
                this._alternateInput.clear();
                _local3.readBytes(this._alternateInput, 0, _local3.bytesAvailable);
                _local3.clear();
            };
            if (((!((_arg1 == null))) && (_arg1.bytesAvailable))){
                _arg1.readBytes(this._mediaInput, this._mediaInput.length, _arg1.bytesAvailable);
            };
            if (((!((_arg2 == null))) && (_arg2.bytesAvailable))){
                _arg2.readBytes(this._alternateInput, this._alternateInput.length, _arg2.bytesAvailable);
            };
        }
        private function clearBuffers():void{
            this.clearAlternateBuffers();
            this.clearMediaBuffers();
        }
        private function clearAlternateBuffers():void{
            this._alternateTime = -1;
            this._alternateTag = null;
            this._alternateTagDataLoaded = false;
            this._alternateInput.clear();
        }
        private function clearMediaBuffers():void{
            this._mediaTime = -1;
            this._mediaTag = null;
            this._mediaTagDataLoaded = false;
            this._mediaInput.clear();
        }
        private function createTag(_arg1:int):FLVTag{
            var _local2:FLVTag;
            switch (_arg1){
                case FLVTag.TAG_TYPE_AUDIO:
                case FLVTag.TAG_TYPE_ENCRYPTED_AUDIO:
                    _local2 = new FLVTagAudio(_arg1);
                    break;
                case FLVTag.TAG_TYPE_VIDEO:
                case FLVTag.TAG_TYPE_ENCRYPTED_VIDEO:
                    _local2 = new FLVTagVideo(_arg1);
                    break;
                case FLVTag.TAG_TYPE_SCRIPTDATAOBJECT:
                case FLVTag.TAG_TYPE_ENCRYPTED_SCRIPTDATAOBJECT:
                    _local2 = new FLVTagScriptDataObject(_arg1);
                    break;
                default:
                    _local2 = new FLVTag(_arg1);
            };
            return (_local2);
        }
        private function shouldFilterTag(_arg1:FLVTag, _arg2:uint):Boolean{
            if (_arg1 == null){
                return (true);
            };
            if (_arg1.timestamp < this._currentTime){
                return (true);
            };
            switch (_arg1.tagType){
                case FLVTag.TAG_TYPE_AUDIO:
                case FLVTag.TAG_TYPE_ENCRYPTED_AUDIO:
                    return ((((FILTER_AUDIO & _arg2)) || ((_arg1.timestamp < this._alternateTime))));
                case FLVTag.TAG_TYPE_VIDEO:
                case FLVTag.TAG_TYPE_ENCRYPTED_VIDEO:
                    return ((((FILTER_VIDEO & _arg2)) || ((_arg1.timestamp < this._mediaTime))));
                case FLVTag.TAG_TYPE_SCRIPTDATAOBJECT:
                case FLVTag.TAG_TYPE_ENCRYPTED_SCRIPTDATAOBJECT:
                    return ((((FILTER_DATA & _arg2)) || ((_arg1.timestamp < this._mediaTime))));
            };
            return (false);
        }
        private function updateTimes(_arg1:FLVTag):void{
            if (_arg1 != null){
                if ((_arg1 is FLVTagAudio)){
                    this._alternateTime = _arg1.timestamp;
                } else {
                    this._mediaTime = _arg1.timestamp;
                };
            };
        }
        private function updateHandlers():void{
            if (this._mediaNeedsInitialization){
                if (this._mediaHandler != this._desiredMediaHandler){
                    if (this._mediaHandler != null){
                        this._mediaHandler.close();
                        this._mediaHandler = null;
                    };
                    this._mediaHandler = this._desiredMediaHandler;
                    this.clearMediaBuffers();
                };
                this._mediaNeedsInitialization = false;
            };
            if (this._alternateNeedsInitialization){
                if (this._alternateHandler != this._desiredAlternateHandler){
                    if (this._alternateHandler != null){
                        this._alternateHandler.close();
                        this._alternateHandler = null;
                    };
                    this._alternateHandler = this._desiredAlternateHandler;
                    this.clearAlternateBuffers();
                    this._alternateNeedsSynchronization = true;
                    this._alternateIgnored = (this._alternateHandler == null);
                };
                this._alternateNeedsInitialization = false;
                this._dispatcher.dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.TRANSITION_COMPLETE, false, false, NaN, null, null, ((this._alternateHandler)!=null) ? this._alternateHandler.streamName : null));
            };
        }
        private function updateFilters():void{
            if (this._alternateIgnored){
                this._mediaFilterTags = FILTER_NONE;
                this._alternateFilterTags = FILTER_ALL;
            } else {
                this._mediaFilterTags = FILTER_AUDIO;
                this._alternateFilterTags = FILTER_VIDEO;
            };
        }
        private function setState(_arg1:String):void{
            this._state = _arg1;
        }
        private function onScriptData(_arg1:HTTPStreamingEvent):void{
            var _local2:*;
            if (((!((this._alternateHandler == null))) && ((this._alternateHandler.streamName == _arg1.url)))){
                _local2 = _arg1.scriptDataObject.objects[0];
                if ((((_local2 == "onMetaData")) || ((_local2 == "onXMPData")))){
                    return;
                };
            };
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function onDVRStreamInfo(_arg1:DVRStreamInfoEvent):void{
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function onBeginFragment(_arg1:HTTPStreamingEvent):void{
            if (((!((this._mediaHandler == null))) && ((this._mediaHandler.streamName == _arg1.url)))){
                if (((!((this._alternateHandler == null))) && (this._alternateIgnored))){
                    this._alternateIgnored = false;
                    this._alternateNeedsSynchronization = true;
                };
                this._dispatcher.dispatchEvent(_arg1);
            };
        }
        private function onEndFragment(_arg1:HTTPStreamingEvent):void{
            if (((!((this._mediaHandler == null))) && ((this._mediaHandler.streamName == _arg1.url)))){
                this._dispatcher.dispatchEvent(_arg1);
            };
        }
        private function onHTTPStreamingEvent(_arg1:HTTPStreamingEvent):void{
            this._dispatcher.dispatchEvent(_arg1);
        }
        private function onFragmentDuration(_arg1:HTTPStreamingEvent):void{
            if (((!((this._mediaHandler == null))) && ((this._mediaHandler.streamName == _arg1.url)))){
                this._fragmentDuration = _arg1.fragmentDuration;
            };
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {

    public interface IHTTPStreamHandler {

        function get source():IHTTPStreamSource;
        function get isOpen():Boolean;
        function get streamName():String;
        function get qosInfo():HTTPStreamHandlerQoSInfo;
        function open(_arg1:String):void;
        function close():void;
        function getDVRInfo(_arg1:Object):void;
        function changeQualityLevel(_arg1:String):void;

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming.dvr {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.*;

    public class HTTPStreamingDVRCastDVRTrait extends DVRTrait {

        private var _connection:NetConnection;
        private var _stream:HTTPNetStream;
        private var _dvrInfo:DVRInfo;

        public function HTTPStreamingDVRCastDVRTrait(_arg1:NetConnection, _arg2:HTTPNetStream, _arg3:DVRInfo){
            this._connection = _arg1;
            this._stream = _arg2;
            this._dvrInfo = _arg3;
            this._stream.addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, this.onDVRStreamInfo);
            super(_arg3.isRecording, _arg3.windowDuration);
        }
        private function onDVRStreamInfo(_arg1:DVRStreamInfoEvent):void{
            this._dvrInfo = (_arg1.info as DVRInfo);
            setIsRecording((((this._dvrInfo == null)) ? false : this._dvrInfo.isRecording));
        }

    }
}//package org.osmf.net.httpstreaming.dvr 
﻿package org.osmf.net.httpstreaming.dvr {
    import org.osmf.events.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import org.osmf.net.*;
    import flash.net.*;
    import org.osmf.net.httpstreaming.*;

    public class HTTPStreamingDVRCastTimeTrait extends TimeTrait {

        private var _connection:NetConnection;
        private var _stream:HTTPNetStream;
        private var _dvrInfo:DVRInfo;

        public function HTTPStreamingDVRCastTimeTrait(_arg1:NetConnection, _arg2:HTTPNetStream, _arg3:DVRInfo){
            super(NaN);
            this._connection = _arg1;
            this._stream = _arg2;
            this._dvrInfo = _arg3;
            this._stream.addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, this.onDVRStreamInfo);
            this._stream.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            NetClient(this._stream.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus);
        }
        override public function get duration():Number{
            if (this._dvrInfo == null){
                return (NaN);
            };
            return (this._dvrInfo.curLength);
        }
        override public function get currentTime():Number{
            return (this._stream.time);
        }
        private function onDVRStreamInfo(_arg1:DVRStreamInfoEvent):void{
            this._dvrInfo = (_arg1.info as DVRInfo);
            setDuration(this._dvrInfo.curLength);
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_UNPUBLISH_NOTIFY:
                    signalComplete();
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_COMPLETE:
                    signalComplete();
                    break;
            };
        }

    }
}//package org.osmf.net.httpstreaming.dvr 
﻿package org.osmf.net.httpstreaming.dvr {

    public class DVRInfo {

        public var id:String;
        public var url:String;
        public var beginOffset:uint = 0;
        public var endOffset:uint = 0;
        public var windowDuration:int = -1;
        public var offline:Boolean;
        public var isRecording:Boolean;
        public var curLength:Number;
        public var startTime:Number = NaN;

    }
}//package org.osmf.net.httpstreaming.dvr 
﻿package org.osmf.net.httpstreaming {

    class HTTPStreamingState {

        static const INIT:String = "init";
        static const LOAD:String = "load";
        static const WAIT:String = "wait";
        static const BEGIN_FRAGMENT:String = "beginFragment";
        static const END_FRAGMENT:String = "endFragment";
        static const PLAY:String = "play";
        static const READ:String = "read";
        static const SEEK:String = "seek";
        static const STOP:String = "stop";
        static const HALT:String = "halt";

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import org.osmf.net.qos.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.net.httpstreaming.flv.*;
    import org.osmf.utils.*;

    public class HTTPNetStream extends NetStream {

        private static const HIGH_PRIORITY:int = 2147483647;

        private var _desiredBufferTime_Min:Number = 0;
        private var _desiredBufferTime_Max:Number = 0;
        private var _mainTimer:Timer = null;
        private var _state:String = "init";
        private var _playStreamName:String = null;
        private var _playStart:Number = -1;
        private var _playForDuration:Number = -1;
        private var _resource:URLResource = null;
        private var _factory:HTTPStreamingFactory = null;
        private var _mixer:HTTPStreamMixer = null;
        private var _videoHandler:IHTTPStreamHandler = null;
        private var _source:IHTTPStreamSource = null;
        private var _qualityLevelNeedsChanging:Boolean = false;
        private var _desiredQualityStreamName:String = null;
        private var _audioStreamNeedsChanging:Boolean = false;
        private var _desiredAudioStreamName:String = null;
        private var _seekTarget:Number = -1;
        private var _enhancedSeekTarget:Number = -1;
        private var _enhancedSeekTags:Vector.<FLVTag>;
        private var _notifyPlayStartPending:Boolean = false;
        private var _notifyPlayUnpublishPending:Boolean = false;
        private var _initialTime:Number = -1;
        private var _seekTime:Number = -1;
        private var _lastValidTimeTime:Number = 0;
        private var _initializeFLVParser:Boolean = false;
        private var _flvParser:FLVParser = null;
        private var _flvParserDone:Boolean = true;
        private var _flvParserProcessed:uint;
        private var _flvParserIsSegmentStart:Boolean = false;
        private var _insertScriptDataTags:Vector.<FLVTagScriptDataObject> = null;
        private var _fileTimeAdjustment:Number = 0;
        private var _mediaFragmentDuration:Number = 0;
        private var _dvrInfo:DVRInfo = null;
        private var _waitForDRM:Boolean = false;
        private var maxFPS:Number = 0;
        private var playbackDetailsRecorder:NetStreamPlaybackDetailsRecorder = null;
        private var lastTransitionIndex:int = -1;
        private var lastTransitionStreamURL:String = null;
        private var lastTime:Number = NaN;
        private var timeBeforeSeek:Number = NaN;
        private var seeking:Boolean = false;
        private var emptyBufferInterruptionSinceLastQoSUpdate:Boolean = false;
        private var _bytesLoaded:uint = 0;
        private var _wasSourceLiveStalled:Boolean = false;
        private var _issuedLiveStallNetStatus:Boolean = false;
        private var _wasBufferEmptied:Boolean = false;
        private var _isPlaying:Boolean = false;
        private var _isPaused:Boolean = false;
        private var _liveStallStartTime:Date;

        public function HTTPNetStream(_arg1:NetConnection, _arg2:HTTPStreamingFactory, _arg3:URLResource=null){
            super(_arg1);
            this._resource = _arg3;
            this._factory = _arg2;
            addEventListener(DVRStreamInfoEvent.DVRSTREAMINFO, this.onDVRStreamInfo);
            addEventListener(HTTPStreamingEvent.SCRIPT_DATA, this.onScriptData);
            addEventListener(HTTPStreamingEvent.BEGIN_FRAGMENT, this.onBeginFragment);
            addEventListener(HTTPStreamingEvent.END_FRAGMENT, this.onEndFragment);
            addEventListener(HTTPStreamingEvent.TRANSITION, this.onTransition);
            addEventListener(HTTPStreamingEvent.TRANSITION_COMPLETE, this.onTransitionComplete);
            addEventListener(HTTPStreamingEvent.ACTION_NEEDED, this.onActionNeeded);
            addEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onDownloadError);
            addEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onDownloadComplete);
            addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, HIGH_PRIORITY, true);
            addEventListener(DRMErrorEvent.DRM_ERROR, this.onDRMError);
            addEventListener(DRMStatusEvent.DRM_STATUS, this.onDRMStatus);
            this.bufferTime = OSMFSettings.hdsMinimumBufferTime;
            this.bufferTimeMax = 0;
            this.setState(HTTPStreamingState.INIT);
            this.createSource(_arg3);
            this._mainTimer = new Timer(OSMFSettings.hdsMainTimerInterval);
            this._mainTimer.addEventListener(TimerEvent.TIMER, this.onMainTimer);
        }
        override public function set client(_arg1:Object):void{
            super.client = _arg1;
            if ((((client is NetClient)) && ((this._resource is DynamicStreamingResource)))){
                this.playbackDetailsRecorder = new NetStreamPlaybackDetailsRecorder(this, (client as NetClient), (this._resource as DynamicStreamingResource));
            };
        }
        override public function play(... _args):void{
            this.processPlayParameters(_args);
            super.play(null);
            var _local2:FLVHeader = new FLVHeader();
            var _local3:ByteArray = new ByteArray();
            _local2.write(_local3);
            this.attemptAppendBytes(_local3);
            this._mainTimer.start();
            this._initialTime = -1;
            this._seekTime = -1;
            this._isPlaying = true;
            this._isPaused = false;
            this._notifyPlayStartPending = true;
            this._notifyPlayUnpublishPending = false;
            this.changeSourceTo(this._playStreamName, this._playStart);
        }
        override public function pause():void{
            this._isPaused = true;
            super.pause();
        }
        override public function resume():void{
            this._isPaused = false;
            super.resume();
        }
        override public function play2(_arg1:NetStreamPlayOptions):void{
            switch (_arg1.transition){
                case NetStreamPlayTransitions.RESET:
                    this.play(_arg1.streamName, _arg1.start, _arg1.len);
                    break;
                case NetStreamPlayTransitions.SWITCH:
                    this.changeQualityLevelTo(_arg1.streamName);
                    break;
                case NetStreamPlayTransitions.SWAP:
                    this.changeAudioStreamTo(_arg1.streamName);
                    break;
                default:
                    super.play2(_arg1);
            };
        }
        override public function seek(_arg1:Number):void{
            if (_arg1 < 0){
                _arg1 = 0;
            };
            if (this._state != HTTPStreamingState.INIT){
                if (this._initialTime < 0){
                    this._seekTarget = (_arg1 + 0);
                } else {
                    this._seekTarget = (_arg1 + this._initialTime);
                };
                this.setState(HTTPStreamingState.SEEK);
                dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                    code:NetStreamCodes.NETSTREAM_SEEK_START,
                    level:"status"
                }));
            };
            this._notifyPlayUnpublishPending = false;
        }
        override public function close():void{
            if (this._videoHandler != null){
                this._videoHandler.close();
            };
            if (this._mixer != null){
                this._mixer.close();
            };
            this._mainTimer.stop();
            this.notifyPlayStop();
            this.setState(HTTPStreamingState.HALT);
            super.close();
        }
        override public function set bufferTime(_arg1:Number):void{
            super.bufferTime = _arg1;
            this._desiredBufferTime_Min = Math.max(OSMFSettings.hdsMinimumBufferTime, _arg1);
            this._desiredBufferTime_Max = (this._desiredBufferTime_Min + OSMFSettings.hdsAdditionalBufferTime);
        }
        override public function get time():Number{
            if ((((this._seekTime >= 0)) && ((this._initialTime >= 0)))){
                this._lastValidTimeTime = ((super.time + this._seekTime) - this._initialTime);
            };
            return (this._lastValidTimeTime);
        }
        override public function get bytesLoaded():uint{
            return (this._bytesLoaded);
        }
        public function DVRGetStreamInfo(_arg1:Object):void{
            if (this._source.isReady){
            } else {
                this._videoHandler.getDVRInfo(_arg1);
            };
        }
        public function get isBestEffortFetchEnabled():Boolean{
            return (((!((this._source == null))) && (this._source.isBestEffortFetchEnabled)));
        }
        private function setState(_arg1:String):void{
            this._state = _arg1;
        }
        private function processPlayParameters(_arg1:Array):void{
            if (_arg1.length < 1){
                throw (new Error("HTTPNetStream.play() requires at least one argument"));
            };
            this._playStreamName = _arg1[0];
            this._playStart = 0;
            if (_arg1.length >= 2){
                this._playStart = Number(_arg1[1]);
            };
            this._playForDuration = -1;
            if (_arg1.length >= 3){
                this._playForDuration = Number(_arg1[2]);
            };
        }
        private function changeSourceTo(_arg1:String, _arg2:Number):void{
            this._initializeFLVParser = true;
            this._seekTarget = _arg2;
            this._videoHandler.open(_arg1);
            this.setState(HTTPStreamingState.SEEK);
        }
        private function changeQualityLevelTo(_arg1:String):void{
            this._qualityLevelNeedsChanging = true;
            this._desiredQualityStreamName = _arg1;
            if (((this._source.isReady) && (((!((this._videoHandler == null))) && (!((this._videoHandler.streamName == this._desiredQualityStreamName))))))){
                this._videoHandler.changeQualityLevel(this._desiredQualityStreamName);
                this._qualityLevelNeedsChanging = false;
                this._desiredQualityStreamName = null;
            };
            this._notifyPlayUnpublishPending = false;
        }
        private function changeAudioStreamTo(_arg1:String):void{
            var _local2:MediaResourceBase;
            if (this._mixer == null){
                this._audioStreamNeedsChanging = false;
                this._desiredAudioStreamName = null;
                return;
            };
            this._audioStreamNeedsChanging = true;
            this._desiredAudioStreamName = _arg1;
            if (((this._videoHandler.isOpen) && ((((((this._mixer.audio == null)) && (!((this._desiredAudioStreamName == null))))) || (((!((this._mixer.audio == null))) && (!((this._mixer.audio.streamName == this._desiredAudioStreamName))))))))){
                _local2 = HTTPStreamingUtils.createHTTPStreamingResource(this._resource, this._desiredAudioStreamName);
                if (_local2 != null){
                    this._mixer.audio = new HTTPStreamSource(this._factory, _local2, this._mixer);
                    this._mixer.audio.open(this._desiredAudioStreamName);
                } else {
                    this._mixer.audio = null;
                };
                this._audioStreamNeedsChanging = false;
                this._desiredAudioStreamName = null;
            };
            this._notifyPlayUnpublishPending = false;
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_BUFFER_EMPTY:
                    this.emptyBufferInterruptionSinceLastQoSUpdate = true;
                    this._wasBufferEmptied = true;
                    if (this._state == HTTPStreamingState.HALT){
                        if (this._notifyPlayUnpublishPending){
                            this.notifyPlayUnpublish();
                            this._notifyPlayUnpublishPending = false;
                        };
                    };
                    break;
                case NetStreamCodes.NETSTREAM_BUFFER_FULL:
                    this._wasBufferEmptied = false;
                    break;
                case NetStreamCodes.NETSTREAM_BUFFER_FLUSH:
                    this._wasBufferEmptied = false;
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STREAMNOTFOUND:
                    this.close();
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_NOTIFY:
                    if (!_arg1.info.hasOwnProperty("sentFromHTTPNetStream")){
                        _arg1.stopImmediatePropagation();
                    };
                    break;
            };
            if (_arg1.info.code == NetStreamCodes.NETSTREAM_DRM_UPDATE){
                this._waitForDRM = true;
            };
        }
        private function onMainTimer(_arg1:TimerEvent):void{
            var _local2:int;
            var _local3:Boolean;
            var _local4:Object;
            var _local5:FLVTagScriptDataObject;
            var _local6:ByteArray;
            var _local7:Object;
            var _local8:FLVTagScriptDataObject;
            var _local9:ByteArray;
            if (((this.seeking) && (!((this.time == this.timeBeforeSeek))))){
                this.seeking = false;
                this.timeBeforeSeek = Number.NaN;
                dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                    code:NetStreamCodes.NETSTREAM_SEEK_NOTIFY,
                    level:"status",
                    seekPoint:this.time,
                    sentFromHTTPNetStream:true
                }));
            };
            if (currentFPS > this.maxFPS){
                this.maxFPS = currentFPS;
            };
            switch (this._state){
                case HTTPStreamingState.INIT:
                    break;
                case HTTPStreamingState.WAIT:
                    if (((!(this._waitForDRM)) && ((((this.bufferLength < this._desiredBufferTime_Min)) || (this.checkIfExtraBufferingNeeded()))))){
                        this.setState(HTTPStreamingState.PLAY);
                    };
                    break;
                case HTTPStreamingState.SEEK:
                    if (this._source.isReady){
                        this.timeBeforeSeek = this.time;
                        this.seeking = true;
                        this._flvParser = null;
                        if (this._enhancedSeekTags != null){
                            this._enhancedSeekTags.length = 0;
                            this._enhancedSeekTags = null;
                        };
                        this._enhancedSeekTarget = this._seekTarget;
                        super.seek(0);
                        appendBytesAction(NetStreamAppendBytesAction.RESET_SEEK);
                        this._wasBufferEmptied = true;
                        if (this.playbackDetailsRecorder != null){
                            if (this.playbackDetailsRecorder.playingIndex != this.lastTransitionIndex){
                                _local7 = new Object();
                                _local7.code = NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE;
                                _local7.level = "status";
                                _local7.details = this.lastTransitionStreamURL;
                                _local8 = new FLVTagScriptDataObject();
                                _local8.objects = ["onPlayStatus", _local7];
                                this.insertScriptDataTag(_local8);
                            };
                        };
                        this._seekTime = -1;
                        this._source.seek(this._seekTarget);
                        this.setState(HTTPStreamingState.WAIT);
                    };
                    break;
                case HTTPStreamingState.PLAY:
                    if (this._notifyPlayStartPending){
                        this._notifyPlayStartPending = false;
                        this.notifyPlayStart();
                    };
                    if (this._qualityLevelNeedsChanging){
                        this.changeQualityLevelTo(this._desiredQualityStreamName);
                    };
                    if (this._audioStreamNeedsChanging){
                        this.changeAudioStreamTo(this._desiredAudioStreamName);
                    };
                    _local2 = 0;
                    _local3 = true;
                    while (_local3) {
                        _local9 = this._source.getBytes();
                        this.issueLivenessEventsIfNeeded();
                        if (_local9 != null){
                            _local2 = (_local2 + this.processAndAppend(_local9));
                        };
                        if (((((!((this._state == HTTPStreamingState.PLAY))) || ((_local9 == null)))) || ((_local2 >= OSMFSettings.hdsBytesProcessingLimit)))){
                            _local3 = false;
                        };
                    };
                    if (this._state == HTTPStreamingState.PLAY){
                        if (_local2 > 0){
                            if (this._waitForDRM){
                                this.setState(HTTPStreamingState.WAIT);
                            } else {
                                if (this.checkIfExtraBufferingNeeded()){
                                } else {
                                    if (this.bufferLength > this._desiredBufferTime_Max){
                                        this.setState(HTTPStreamingState.WAIT);
                                    };
                                };
                            };
                        } else {
                            if (this._source.endOfStream){
                                super.bufferTime = 0.1;
                                this.setState(HTTPStreamingState.STOP);
                            };
                        };
                    };
                    break;
                case HTTPStreamingState.STOP:
                    appendBytesAction(NetStreamAppendBytesAction.END_SEQUENCE);
                    appendBytesAction(NetStreamAppendBytesAction.RESET_SEEK);
                    _local4 = new Object();
                    _local4.code = NetStreamCodes.NETSTREAM_PLAY_COMPLETE;
                    _local4.level = "status";
                    _local5 = new FLVTagScriptDataObject();
                    _local5.objects = ["onPlayStatus", _local4];
                    _local6 = new ByteArray();
                    _local5.write(_local6);
                    this.attemptAppendBytes(_local6);
                    appendBytesAction(NetStreamAppendBytesAction.END_SEQUENCE);
                    this.setState(HTTPStreamingState.HALT);
                    break;
                case HTTPStreamingState.HALT:
                    break;
            };
        }
        private function checkIfExtraBufferingNeeded():Boolean{
            if (((((!(this._wasBufferEmptied)) || (!(this._isPlaying)))) || (this._isPaused))){
                return (false);
            };
            if (this.bufferLength > (this._desiredBufferTime_Max + 30)){
                return (false);
            };
            return (true);
        }
        private function issueLivenessEventsIfNeeded():void{
            if (((this._source.isLiveStalled) && (this._wasBufferEmptied))){
                if (!this._wasSourceLiveStalled){
                    this._wasSourceLiveStalled = true;
                    this._liveStallStartTime = new Date();
                    this._issuedLiveStallNetStatus = false;
                };
                if (this.shouldIssueLiveStallNetStatus()){
                    dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                        code:NetStreamCodes.NETSTREAM_PLAY_LIVE_STALL,
                        level:"status"
                    }));
                    this._issuedLiveStallNetStatus = true;
                };
            } else {
                if (((this._wasSourceLiveStalled) && (this._issuedLiveStallNetStatus))){
                    dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                        code:NetStreamCodes.NETSTREAM_PLAY_LIVE_RESUME,
                        level:"status"
                    }));
                };
                this._wasSourceLiveStalled = false;
            };
        }
        private function shouldIssueLiveStallNetStatus():Boolean{
            if (this._issuedLiveStallNetStatus){
                return (false);
            };
            if (!this._wasBufferEmptied){
                return (false);
            };
            var _local1:Number = (((this.bufferLength + Math.max(OSMFSettings.hdsLiveStallTolerance, 0)) + 1) * 1000);
            var _local2:Date = new Date();
            if (_local2.valueOf() < (this._liveStallStartTime.valueOf() + _local1)){
                return (false);
            };
            return (true);
        }
        private function onDVRStreamInfo(_arg1:DVRStreamInfoEvent):void{
            this._dvrInfo = (_arg1.info as DVRInfo);
            this._initialTime = this._dvrInfo.startTime;
        }
        private function onBeginFragment(_arg1:HTTPStreamingEvent):void{
            if ((((((((this._initialTime < 0)) || ((this._seekTime < 0)))) || (this._insertScriptDataTags))) || ((this._playForDuration >= 0)))){
                if (this._flvParser == null){
                    if ((((this._enhancedSeekTarget >= 0)) || ((this._playForDuration >= 0)))){
                        this._flvParserIsSegmentStart = true;
                    };
                    this._flvParser = new FLVParser(false);
                };
                this._flvParserDone = false;
            };
        }
        private function onEndFragment(_arg1:HTTPStreamingEvent):void{
            if (this._videoHandler == null){
                return;
            };
            var _local2:Date = new Date();
            var _local3:Number = _local2.getTime();
            var _local4:HTTPStreamHandlerQoSInfo = this._videoHandler.qosInfo;
            var _local5:Vector.<QualityLevel>;
            var _local6:uint;
            var _local7:FragmentDetails;
            if (_local4 != null){
                _local5 = _local4.availableQualityLevels;
                _local6 = _local4.actualIndex;
                _local7 = _local4.lastFragmentDetails;
            };
            var _local8:Vector.<PlaybackDetails>;
            var _local9 = -1;
            if (this.playbackDetailsRecorder != null){
                _local8 = this.playbackDetailsRecorder.computeAndGetRecord();
                _local9 = this.playbackDetailsRecorder.playingIndex;
            };
            var _local10:QoSInfo = new QoSInfo(_local3, this.time, _local5, _local9, _local6, _local7, this.maxFPS, _local8, info, bufferLength, bufferTime, this.emptyBufferInterruptionSinceLastQoSUpdate);
            dispatchEvent(new QoSInfoEvent(QoSInfoEvent.QOS_UPDATE, false, false, _local10));
            this.emptyBufferInterruptionSinceLastQoSUpdate = false;
            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.RUN_ALGORITHM));
        }
        private function onTransition(_arg1:HTTPStreamingEvent):void{
            if ((this._resource is DynamicStreamingResource)){
                this.lastTransitionIndex = (this._resource as DynamicStreamingResource).indexFromName(_arg1.url);
                this.lastTransitionStreamURL = _arg1.url;
            };
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                code:NetStreamCodes.NETSTREAM_PLAY_TRANSITION,
                level:"status",
                details:_arg1.url
            }));
        }
        private function onTransitionComplete(_arg1:HTTPStreamingEvent):void{
            this.onActionNeeded(_arg1);
            var _local2:Object = new Object();
            _local2.code = NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE;
            _local2.level = "status";
            _local2.details = _arg1.url;
            var _local3:FLVTagScriptDataObject = new FLVTagScriptDataObject();
            _local3.objects = ["onPlayStatus", _local2];
            this.insertScriptDataTag(_local3);
        }
        private function onDownloadError(_arg1:HTTPStreamingEvent):void{
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                code:NetStreamCodes.NETSTREAM_PLAY_STREAMNOTFOUND,
                level:"error",
                details:_arg1.url
            }));
        }
        private function onDownloadComplete(_arg1:HTTPStreamingEvent):void{
            this._bytesLoaded = (this._bytesLoaded + _arg1.bytesDownloaded);
        }
        private function notifyPlayStart():void{
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                code:NetStreamCodes.NETSTREAM_PLAY_START,
                level:"status"
            }));
        }
        private function notifyPlayStop():void{
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                code:NetStreamCodes.NETSTREAM_PLAY_STOP,
                level:"status"
            }));
        }
        private function notifyPlayUnpublish():void{
            dispatchEvent(new NetStatusEvent(NetStatusEvent.NET_STATUS, false, false, {
                code:NetStreamCodes.NETSTREAM_PLAY_UNPUBLISH_NOTIFY,
                level:"status"
            }));
        }
        private function insertScriptDataTag(_arg1:FLVTagScriptDataObject, _arg2:Boolean=false):void{
            if (!this._insertScriptDataTags){
                this._insertScriptDataTags = new Vector.<FLVTagScriptDataObject>();
            };
            if (_arg2){
                this._insertScriptDataTags.unshift(_arg1);
            } else {
                this._insertScriptDataTags.push(_arg1);
            };
        }
        private function consumeAllScriptDataTags(_arg1:Number):int{
            var _local2:int;
            var _local3:int;
            var _local4:ByteArray;
            var _local5:FLVTagScriptDataObject;
            _local3 = 0;
            while (_local3 < this._insertScriptDataTags.length) {
                _local4 = new ByteArray();
                _local5 = this._insertScriptDataTags[_local3];
                if (_local5 != null){
                    _local5.timestamp = _arg1;
                    _local5.write(_local4);
                    this.attemptAppendBytes(_local4);
                    _local2 = (_local2 + _local4.length);
                };
                _local3++;
            };
            this._insertScriptDataTags.length = 0;
            this._insertScriptDataTags = null;
            return (_local2);
        }
        private function processAndAppend(_arg1:ByteArray):uint{
            var _local2:ByteArray;
            if (((!(_arg1)) || ((_arg1.length == 0)))){
                return (0);
            };
            var _local3:uint;
            if (this._flvParser == null){
                _local2 = _arg1;
            } else {
                this._flvParserProcessed = 0;
                _arg1.position = 0;
                this._flvParser.parse(_arg1, true, this.onTag);
                _local3 = (_local3 + this._flvParserProcessed);
                if (!this._flvParserDone){
                    return (_local3);
                };
                _local2 = new ByteArray();
                this._flvParser.flush(_local2);
                this._flvParser = null;
            };
            _local3 = (_local3 + _local2.length);
            if (this._state != HTTPStreamingState.STOP){
                this.attemptAppendBytes(_local2);
            };
            return (_local3);
        }
        private function doConsumeAllScriptDataTags(_arg1:uint):void{
            if (this._insertScriptDataTags != null){
                this._flvParserProcessed = (this._flvParserProcessed + this.consumeAllScriptDataTags(_arg1));
            };
        }
        private function onTag(_arg1:FLVTag):Boolean{
            var _local2:int;
            var _local5:FLVTagVideo;
            var _local6:int;
            var _local7:Boolean;
            var _local8:FLVTag;
            var _local9:FLVTagVideo;
            var _local10:int;
            var _local11:int;
            var _local12:FLVTagVideo;
            var _local3:Number = ((_arg1.timestamp / 1000) + this._fileTimeAdjustment);
            while (_local3 < this._initialTime) {
                _local3 = (_local3 + 4294967.296);
            };
            if (this._playForDuration >= 0){
                if (this._initialTime >= 0){
                    if (_local3 > (this._initialTime + this._playForDuration)){
                        this.setState(HTTPStreamingState.STOP);
                        this._flvParserDone = true;
                        if (this._seekTime < 0){
                            this._seekTime = (this._playForDuration + this._initialTime);
                        };
                        return (false);
                    };
                };
            };
            if (this._enhancedSeekTarget < 0){
                if (this._initialTime < 0){
                    this._initialTime = ((this._dvrInfo)!=null) ? this._dvrInfo.startTime : _local3;
                };
                if (this._seekTime < 0){
                    this._seekTime = _local3;
                };
            } else {
                if (_local3 < this._enhancedSeekTarget){
                    if (this._enhancedSeekTags == null){
                        this._enhancedSeekTags = new Vector.<FLVTag>();
                    };
                    if ((_arg1 is FLVTagVideo)){
                        if (this._flvParserIsSegmentStart){
                            _local5 = new FLVTagVideo();
                            _local5.timestamp = _arg1.timestamp;
                            _local5.codecID = FLVTagVideo(_arg1).codecID;
                            _local5.frameType = FLVTagVideo.FRAME_TYPE_INFO;
                            _local5.infoPacketValue = FLVTagVideo.INFO_PACKET_SEEK_START;
                            this._enhancedSeekTags.push(_local5);
                            this._flvParserIsSegmentStart = false;
                        };
                        this._enhancedSeekTags.push(_arg1);
                    } else {
                        if ((((_arg1 is FLVTagScriptDataObject)) || ((((_arg1 is FLVTagAudio)) && (FLVTagAudio(_arg1).isCodecConfiguration))))){
                            this._enhancedSeekTags.push(_arg1);
                        };
                    };
                } else {
                    this.doConsumeAllScriptDataTags(_arg1.timestamp);
                    this._enhancedSeekTarget = -1;
                    if (this._seekTime < 0){
                        this._seekTime = _local3;
                    };
                    if (this._initialTime < 0){
                        this._initialTime = _local3;
                    };
                    if (((!((this._enhancedSeekTags == null))) && ((this._enhancedSeekTags.length > 0)))){
                        _local7 = false;
                        _local2 = 0;
                        while (_local2 < this._enhancedSeekTags.length) {
                            _local8 = this._enhancedSeekTags[_local2];
                            if (_local8.tagType == FLVTag.TAG_TYPE_VIDEO){
                                _local9 = (_local8 as FLVTagVideo);
                                if ((((_local9.codecID == FLVTagVideo.CODEC_ID_AVC)) && ((_local9.avcPacketType == FLVTagVideo.AVC_PACKET_TYPE_NALU)))){
                                    _local10 = (_arg1.timestamp - _local9.timestamp);
                                    _local11 = _local9.avcCompositionTimeOffset;
                                    _local11 = (_local11 - _local10);
                                    _local9.avcCompositionTimeOffset = _local11;
                                };
                                _local6 = _local9.codecID;
                                _local7 = true;
                            };
                            _local8.timestamp = _arg1.timestamp;
                            var _local4:ByteArray = new ByteArray();
                            _local8.write(_local4);
                            this._flvParserProcessed = (this._flvParserProcessed + _local4.length);
                            this.attemptAppendBytes(_local4);
                            _local2++;
                        };
                        if (_local7){
                            _local12 = new FLVTagVideo();
                            _local12.timestamp = _arg1.timestamp;
                            _local12.codecID = _local6;
                            _local12.frameType = FLVTagVideo.FRAME_TYPE_INFO;
                            _local12.infoPacketValue = FLVTagVideo.INFO_PACKET_SEEK_END;
                            _local4 = new ByteArray();
                            _local12.write(_local4);
                            this._flvParserProcessed = (this._flvParserProcessed + _local4.length);
                            this.attemptAppendBytes(_local4);
                        };
                        this._enhancedSeekTags = null;
                    };
                    _local4 = new ByteArray();
                    _arg1.write(_local4);
                    this._flvParserProcessed = (this._flvParserProcessed + _local4.length);
                    this.attemptAppendBytes(_local4);
                    if (this._playForDuration >= 0){
                        return (true);
                    };
                    this._flvParserDone = true;
                    return (false);
                };
                return (true);
            };
            this.doConsumeAllScriptDataTags(_arg1.timestamp);
            _local4 = new ByteArray();
            _arg1.write(_local4);
            this.attemptAppendBytes(_local4);
            this._flvParserProcessed = (this._flvParserProcessed + _local4.length);
            if (this._playForDuration >= 0){
                if ((((this._source.fragmentDuration >= 0)) && (this._flvParserIsSegmentStart))){
                    this._flvParserIsSegmentStart = false;
                    _local3 = ((_arg1.timestamp / 1000) + this._fileTimeAdjustment);
                    if ((_local3 + this._source.fragmentDuration) >= (this._initialTime + this._playForDuration)){
                        return (true);
                    };
                    this._flvParserDone = true;
                    return (false);
                };
                return (true);
            };
            this._flvParserDone = true;
            return (false);
        }
        private function onScriptData(_arg1:HTTPStreamingEvent):void{
            var _local2:*;
            var _local3:*;
            if ((((_arg1.scriptDataMode == null)) || ((_arg1.scriptDataObject == null)))){
                return;
            };
            switch (_arg1.scriptDataMode){
                case FLVTagScriptDataMode.NORMAL:
                    this.insertScriptDataTag(_arg1.scriptDataObject, false);
                    break;
                case FLVTagScriptDataMode.FIRST:
                    this.insertScriptDataTag(_arg1.scriptDataObject, true);
                    break;
                case FLVTagScriptDataMode.IMMEDIATE:
                    if (client){
                        _local2 = _arg1.scriptDataObject.objects[0];
                        _local3 = _arg1.scriptDataObject.objects[1];
                        if (client.hasOwnProperty(_local2)){
                            var _local4 = client;
                            _local4[_local2](_local3);
                        };
                    };
                    break;
            };
        }
        private function onActionNeeded(_arg1:HTTPStreamingEvent):void{
            var _local2:FLVHeader;
            var _local3:ByteArray;
            if (this._mixer != null){
                appendBytesAction(NetStreamAppendBytesAction.RESET_BEGIN);
                _local2 = new FLVHeader();
                _local3 = new ByteArray();
                _local2.write(_local3);
                this.attemptAppendBytes(_local3);
            };
        }
        private function attemptAppendBytes(_arg1:ByteArray):void{
            appendBytes(_arg1);
        }
        protected function createSource(_arg1:URLResource):void{
            var _local4:HTTPStreamSource;
            var _local2:IHTTPStreamSource;
            var _local3:StreamingURLResource = (_arg1 as StreamingURLResource);
            if ((((((_local3 == null)) || ((_local3.alternativeAudioStreamItems == null)))) || ((_local3.alternativeAudioStreamItems.length == 0)))){
                _local4 = new HTTPStreamSource(this._factory, this._resource, this);
                this._source = _local4;
                this._videoHandler = _local4;
            } else {
                this._mixer = new HTTPStreamMixer(this);
                this._mixer.video = new HTTPStreamSource(this._factory, this._resource, this._mixer);
                this._source = this._mixer;
                this._videoHandler = this._mixer.video;
            };
        }
        private function onDRMError(_arg1:DRMErrorEvent):void{
            this._waitForDRM = true;
            this.setState(HTTPStreamingState.WAIT);
        }
        private function onDRMStatus(_arg1:DRMStatusEvent):void{
            if (_arg1.voucher != null){
                this._waitForDRM = false;
            };
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import flash.events.*;
    import flash.errors.*;

    public class HTTPStreamingIndexHandlerBase extends EventDispatcher {

        public function initialize(_arg1:Object):void{
            throw (new IllegalOperationError("The initialize() method must be overridden by the derived class."));
        }
        public function dispose():void{
            throw (new IllegalOperationError("The dispose() method must be overridden by the derived class."));
        }
        public function processIndexData(_arg1, _arg2:Object):void{
            throw (new IllegalOperationError("The processIndexData() method must be overridden by the derived class."));
        }
        public function getFileForTime(_arg1:Number, _arg2:int):HTTPStreamRequest{
            throw (new IllegalOperationError("The getFileForTime() method must be overridden by the derived class."));
        }
        public function getNextFile(_arg1:int):HTTPStreamRequest{
            throw (new IllegalOperationError("The getNextFile() method must be overridden by the derived class."));
        }
        public function dvrGetStreamInfo(_arg1:Object):void{
            throw (new IllegalOperationError("The dvrGetStreamInfo() method must be overridden by the derived class."));
        }
        public function get isBestEffortFetchEnabled():Boolean{
            throw (new IllegalOperationError("The isBestEffortFetchEnabled method must be overridden by the derived class."));
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;

    public class HTTPStreamHandlerQoSInfo {

        private var _availableQualityLevels:Vector.<QualityLevel>;
        private var _actualIndex:uint;
        private var _lastFragmentDetails:FragmentDetails;

        public function HTTPStreamHandlerQoSInfo(_arg1:Vector.<QualityLevel>, _arg2:uint, _arg3:FragmentDetails=null){
            this._availableQualityLevels = _arg1;
            this._actualIndex = _arg2;
            this._lastFragmentDetails = _arg3;
        }
        public function get availableQualityLevels():Vector.<QualityLevel>{
            return (this._availableQualityLevels);
        }
        public function get actualIndex():uint{
            return (this._actualIndex);
        }
        public function get lastFragmentDetails():FragmentDetails{
            return (this._lastFragmentDetails);
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import flash.events.*;
    import flash.utils.*;
    import flash.errors.*;

    public class HTTPStreamingFileHandlerBase extends EventDispatcher {

        public function beginProcessFile(_arg1:Boolean, _arg2:Number):void{
            throw (new IllegalOperationError("The beginProcessFile() method must be overridden by HttpStreamingFileHandlerBase's derived class."));
        }
        public function get inputBytesNeeded():Number{
            throw (new IllegalOperationError("The inputBytesNeeded() method must be overridden by HttpStreamingFileHandlerBase's derived class."));
        }
        public function processFileSegment(_arg1:IDataInput):ByteArray{
            throw (new IllegalOperationError("The processFileSegment() method must be overridden by HttpStreamingFileHandlerBase's derived class."));
        }
        public function endProcessFile(_arg1:IDataInput):ByteArray{
            throw (new IllegalOperationError("The endProcessFile() method must be overridden by HttpStreamingFileHandlerBase's derived class."));
        }
        public function flushFileSegment(_arg1:IDataInput):ByteArray{
            throw (new IllegalOperationError("The flushFileSegment() method must be overridden by HttpStreamingFileHandlerBase's derived class."));
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.events.*;
    import flash.events.*;
    import flash.net.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.flv.*;
    import org.osmf.utils.*;

    public class HTTPStreamDownloader {

        private var _isOpen:Boolean = false;
        private var _isComplete:Boolean = false;
        private var _hasData:Boolean = false;
        private var _hasErrors:Boolean = false;
        private var _savedBytes:ByteArray = null;
        private var _urlStream:URLStream = null;
        private var _request:URLRequest = null;
        private var _dispatcher:IEventDispatcher = null;
        private var _downloadBeginDate:Date = null;
        private var _downloadEndDate:Date = null;
        private var _downloadDuration:Number = 0;
        private var _downloadBytesCount:Number = 0;
        private var _timeoutTimer:Timer = null;
        private var _timeoutInterval:Number = 1000;
        private var _currentRetry:Number = 0;

        public function get isOpen():Boolean{
            return (this._isOpen);
        }
        public function get isComplete():Boolean{
            return (this._isComplete);
        }
        public function get hasData():Boolean{
            return (this._hasData);
        }
        public function get hasErrors():Boolean{
            return (this._hasErrors);
        }
        public function get downloadDuration():Number{
            return (this._downloadDuration);
        }
        public function get downloadBytesCount():Number{
            return (this._downloadBytesCount);
        }
        public function open(_arg1:URLRequest, _arg2:IEventDispatcher, _arg3:Number):void{
            if (((this.isOpen) || (((!((this._urlStream == null))) && (this._urlStream.connected))))){
                this.close();
            };
            if (_arg1 == null){
                throw (new ArgumentError("Null request in HTTPStreamDownloader open method."));
            };
            this._isComplete = false;
            this._hasData = false;
            this._hasErrors = false;
            this._dispatcher = _arg2;
            if (this._savedBytes == null){
                this._savedBytes = new ByteArray();
            };
            if (this._urlStream == null){
                this._urlStream = new URLStream();
                this._urlStream.addEventListener(Event.OPEN, this.onOpen);
                this._urlStream.addEventListener(Event.COMPLETE, this.onComplete);
                this._urlStream.addEventListener(ProgressEvent.PROGRESS, this.onProgress);
                this._urlStream.addEventListener(IOErrorEvent.IO_ERROR, this.onError);
                this._urlStream.addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onError);
            };
            if ((((this._timeoutTimer == null)) && (!((_arg3 == -1))))){
                this._timeoutTimer = new Timer(_arg3, 1);
                this._timeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onTimeout);
            };
            if (this._urlStream != null){
                this._timeoutInterval = _arg3;
                this._request = _arg1;
                this._downloadBeginDate = null;
                this._downloadBytesCount = 0;
                this.startTimeoutMonitor(this._timeoutInterval);
                this._urlStream.load(this._request);
            };
        }
        public function close(_arg1:Boolean=false):void{
            this.stopTimeoutMonitor();
            this._isOpen = false;
            this._isComplete = false;
            this._hasData = false;
            this._hasErrors = false;
            this._request = null;
            if (this._timeoutTimer != null){
                this._timeoutTimer.stop();
                if (_arg1){
                    this._timeoutTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, this.onTimeout);
                    this._timeoutTimer = null;
                };
            };
            if (this._urlStream != null){
                if (this._urlStream.connected){
                    this._urlStream.close();
                };
                if (_arg1){
                    this._urlStream.removeEventListener(Event.OPEN, this.onOpen);
                    this._urlStream.removeEventListener(Event.COMPLETE, this.onComplete);
                    this._urlStream.removeEventListener(ProgressEvent.PROGRESS, this.onProgress);
                    this._urlStream.removeEventListener(IOErrorEvent.IO_ERROR, this.onError);
                    this._urlStream.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onError);
                    this._urlStream = null;
                };
            };
            if (this._savedBytes != null){
                this._savedBytes.length = 0;
                if (_arg1){
                    this._savedBytes = null;
                };
            };
        }
        public function get totalAvailableBytes():int{
            if (!this.isOpen){
                return (0);
            };
            return ((this._savedBytes.bytesAvailable + this._urlStream.bytesAvailable));
        }
        public function getBytes(_arg1:int=0):IDataInput{
            var _local3:int;
            if (((!(this.isOpen)) || ((_arg1 < 0)))){
                return (null);
            };
            if (_arg1 == 0){
                _arg1 = 1;
            };
            var _local2:int = this.totalAvailableBytes;
            if (_local2 == 0){
                this._hasData = false;
            };
            if (_local2 < _arg1){
                return (null);
            };
            if (this._savedBytes.bytesAvailable){
                _local3 = (_arg1 - this._savedBytes.bytesAvailable);
                if (_local3 > 0){
                    this._urlStream.readBytes(this._savedBytes, this._savedBytes.length, _local3);
                };
                return (this._savedBytes);
            };
            this._savedBytes.length = 0;
            return (this._urlStream);
        }
        public function clearSavedBytes():void{
            if (this._savedBytes == null){
                return;
            };
            this._savedBytes.length = 0;
            this._savedBytes.position = 0;
        }
        public function appendToSavedBytes(_arg1:IDataInput, _arg2:uint):void{
            if (this._savedBytes == null){
                return;
            };
            _arg1.readBytes(this._savedBytes, this._savedBytes.length, _arg2);
        }
        public function saveRemainingBytes():void{
            if (this._savedBytes == null){
                return;
            };
            if (((((!((this._urlStream == null))) && (this._urlStream.connected))) && (this._urlStream.bytesAvailable))){
                this._urlStream.readBytes(this._savedBytes, this._savedBytes.length);
            };
        }
        public function toString():String{
            return ("HTTPStreamSource");
        }
        private function onOpen(_arg1:Event):void{
            this._isOpen = true;
        }
        private function onComplete(_arg1:Event):void{
            var _local2:HTTPStreamingEvent;
            if (this._downloadBeginDate == null){
                this._downloadBeginDate = new Date();
            };
            this._downloadEndDate = new Date();
            this._downloadDuration = ((this._downloadEndDate.valueOf() - this._downloadBeginDate.valueOf()) / 1000);
            this._isComplete = true;
            this._hasErrors = false;
            if (this._dispatcher != null){
                _local2 = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_COMPLETE, false, false, 0, null, FLVTagScriptDataMode.NORMAL, this._request.url, this._downloadBytesCount, HTTPStreamingEventReason.NORMAL, this);
                this._dispatcher.dispatchEvent(_local2);
            };
        }
        private function onProgress(_arg1:ProgressEvent):void{
            var _local2:HTTPStreamingEvent;
            if (this._downloadBeginDate == null){
                this._downloadBeginDate = new Date();
            };
            if (this._downloadBytesCount == 0){
                if (this._timeoutTimer != null){
                    this.stopTimeoutMonitor();
                };
                this._currentRetry = 0;
                this._downloadBytesCount = _arg1.bytesTotal;
            };
            this._hasData = true;
            if (this._dispatcher != null){
                _local2 = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_PROGRESS, false, false, 0, null, FLVTagScriptDataMode.NORMAL, this._request.url, 0, HTTPStreamingEventReason.NORMAL, this);
                this._dispatcher.dispatchEvent(_local2);
            };
        }
        private function onError(_arg1:Event):void{
            var _local2:String;
            var _local3:HTTPStreamingEvent;
            if (this._timeoutTimer != null){
                this.stopTimeoutMonitor();
            };
            if (this._downloadBeginDate == null){
                this._downloadBeginDate = new Date();
            };
            this._downloadEndDate = new Date();
            this._downloadDuration = ((this._downloadEndDate.valueOf() - this._downloadBeginDate.valueOf()) / 1000);
            this._isComplete = false;
            this._hasErrors = true;
            if (this._dispatcher != null){
                _local2 = HTTPStreamingEventReason.NORMAL;
                if (_arg1.type == Event.CANCEL){
                    _local2 = HTTPStreamingEventReason.TIMEOUT;
                };
                _local3 = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_ERROR, false, false, 0, null, FLVTagScriptDataMode.NORMAL, this._request.url, 0, _local2, this);
                this._dispatcher.dispatchEvent(_local3);
            };
        }
        private function startTimeoutMonitor(_arg1:Number):void{
            if (this._timeoutTimer != null){
                if (_arg1 > 0){
                    this._timeoutTimer.delay = _arg1;
                };
                this._timeoutTimer.reset();
                this._timeoutTimer.start();
            };
        }
        private function stopTimeoutMonitor():void{
            if (this._timeoutTimer != null){
                this._timeoutTimer.stop();
            };
        }
        private function onTimeout(_arg1:TimerEvent):void{
            if (OSMFSettings.hdsMaximumRetries > -1){
                this._currentRetry++;
            };
            if ((((OSMFSettings.hdsMaximumRetries == -1)) || (((!((OSMFSettings.hdsMaximumRetries == -1))) && ((this._currentRetry < OSMFSettings.hdsMaximumRetries)))))){
                this.open(this._request, this._dispatcher, (this._timeoutInterval + OSMFSettings.hdsTimeoutAdjustmentOnRetry));
            } else {
                this.close();
                this.onError(new Event(Event.CANCEL));
            };
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.media.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import org.osmf.elements.f4mClasses.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.net.httpstreaming.f4f.*;
    import org.osmf.utils.*;

    public class HTTPStreamingUtils {

        public static function createHTTPStreamingMetadata(_arg1:String, _arg2:ByteArray, _arg3:Vector.<String>):Metadata{
            var _local4:Metadata = new Metadata();
            var _local5:BootstrapInfo = new BootstrapInfo();
            if (((!((_arg1 == null))) && ((_arg1.length > 0)))){
                _local5.url = _arg1;
            };
            _local5.data = _arg2;
            _local4.addValue(MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY, _local5);
            if (((!((_arg3 == null))) && ((_arg3.length > 0)))){
                _local4.addValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY, _arg3);
            };
            return (_local4);
        }
        public static function createHTTPStreamingResource(_arg1:MediaResourceBase, _arg2:String):MediaResourceBase{
            var _local4:Object;
            var _local5:ByteArray;
            var _local6:Vector.<String>;
            if (_arg2 == null){
                return (null);
            };
            var _local3:BootstrapInfo;
            var _local7:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) as Metadata);
            if (_local7 == null){
                return (null);
            };
            var _local8:Metadata = new Metadata();
            _local3 = (_local7.getValue((MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY + _arg2)) as BootstrapInfo);
            if (_local3 != null){
                _local8.addValue(MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY, _local3);
            };
            _local4 = _local7.getValue((MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY + _arg2));
            if (_local4 != null){
                _local8.addValue(MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY, _local4);
            };
            _local5 = (_local7.getValue((MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY + _arg2)) as ByteArray);
            if (_local5 != null){
                _local8.addValue(MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY, _local5);
            };
            _local6 = (_local7.getValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY) as Vector.<String>);
            if (_local6 != null){
                _local8.addValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY, _local6);
            };
            var _local9 = "";
            if (((!((_local6 == null))) && ((_local6.length > 0)))){
                _local9 = _local6[0].toString();
            };
            var _local10:String = _arg2;
            if (!URL.isAbsoluteURL(_local10)){
                _local10 = (URL.normalizeRootURL(_local9) + URL.normalizeRelativeURL(_local10));
            };
            var _local11:MediaResourceBase = new StreamingURLResource(_local10);
            _local11.addMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA, _local8);
            var _local12:DVRInfo = generateDVRInfo((_arg1.getMetadataValue(MetadataNamespaces.DVR_METADATA) as Metadata));
            addDVRInfoMetadataToResource(_local12, _local11);
            var _local13:BestEffortFetchInfo = generateBestEffortFetchInfo((_arg1.getMetadataValue(MetadataNamespaces.BEST_EFFORT_FETCH_METADATA) as Metadata));
            addBestEffortFetchInfoMetadataToResource(_local13, _local11);
            return (_local11);
        }
        public static function addDVRInfoMetadataToResource(_arg1:DVRInfo, _arg2:MediaResourceBase):void{
            if (_arg1 == null){
                return;
            };
            var _local3:Metadata = new Metadata();
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_DVR_BEGIN_OFFSET_KEY, _arg1.beginOffset);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_DVR_END_OFFSET_KEY, _arg1.endOffset);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_DVR_WINDOW_DURATION_KEY, _arg1.windowDuration);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_DVR_OFFLINE_KEY, _arg1.offline);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_DVR_ID_KEY, _arg1.id);
            _arg2.addMetadataValue(MetadataNamespaces.DVR_METADATA, _local3);
        }
        public static function addBestEffortFetchInfoMetadataToResource(_arg1:BestEffortFetchInfo, _arg2:MediaResourceBase):void{
            if (_arg1 == null){
                return;
            };
            var _local3:Metadata = new Metadata();
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_FORWARD_FETCHES, _arg1.maxForwardFetches);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_BACKWARD_FETCHES, _arg1.maxBackwardFetches);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_SEGMENT_DURATION, _arg1.segmentDuration);
            _local3.addValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_FRAGMENT_DURATION, _arg1.fragmentDuration);
            _arg2.addMetadataValue(MetadataNamespaces.BEST_EFFORT_FETCH_METADATA, _local3);
        }
        public static function createF4FIndexInfo(_arg1:URLResource):HTTPStreamingF4FIndexInfo{
            var _local6:Vector.<String>;
            var _local7:Vector.<HTTPStreamingF4FStreamInfo>;
            var _local8:DVRInfo;
            var _local9:BestEffortFetchInfo;
            var _local2:HTTPStreamingF4FIndexInfo;
            var _local3:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) as Metadata);
            var _local4:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.DVR_METADATA) as Metadata);
            var _local5:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.BEST_EFFORT_FETCH_METADATA) as Metadata);
            if (_local3 != null){
                _local6 = (_local3.getValue(MetadataNamespaces.HTTP_STREAMING_SERVER_BASE_URLS_KEY) as Vector.<String>);
                _local7 = generateStreamInfos(_arg1);
                _local8 = generateDVRInfo(_local4);
                _local9 = generateBestEffortFetchInfo(_local5);
                _local2 = new HTTPStreamingF4FIndexInfo(((((!((_local6 == null))) && ((_local6.length > 0)))) ? _local6[0] : null), _local7, _local8, _local9);
            };
            return (_local2);
        }
        public static function normalizeURL(_arg1:String):String{
            var _local4:String;
            var _local7:int;
            var _local2 = "";
            var _local3 = "";
            if (_arg1.indexOf("http://") == 0){
                _local3 = "http://";
            } else {
                if (_arg1.indexOf("https://") == 0){
                    _local3 = "https://";
                };
            };
            if (_local3.length > 0){
                _local4 = _arg1.substr(_local3.length);
            } else {
                _local4 = _arg1;
            };
            var _local5:Array = _local4.split("/");
            var _local6:int = _local5.indexOf("..");
            while (_local6 >= 0) {
                _local5.splice((_local6 - 1), 2);
                _local6 = _local5.indexOf("..");
            };
            _local2 = _local3;
            if (_local5.length > 0){
                _local7 = 0;
                while (_local7 < _local5.length) {
                    if (_local7 != 0){
                        _local2 = (_local2 + "/");
                    };
                    _local2 = (_local2 + (_local5[_local7] as String));
                    _local7++;
                };
            };
            return (_local2);
        }
        private static function generateDVRInfo(_arg1:Metadata):DVRInfo{
            if (_arg1 == null){
                return (null);
            };
            var _local2:DVRInfo = new DVRInfo();
            _local2.id = "";
            _local2.beginOffset = NaN;
            _local2.endOffset = NaN;
            _local2.windowDuration = NaN;
            _local2.offline = false;
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_ID_KEY) != null){
                _local2.id = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_ID_KEY) as String);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_BEGIN_OFFSET_KEY) != null){
                _local2.beginOffset = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_BEGIN_OFFSET_KEY) as uint);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_END_OFFSET_KEY) != null){
                _local2.endOffset = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_END_OFFSET_KEY) as uint);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_WINDOW_DURATION_KEY) != null){
                _local2.windowDuration = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_WINDOW_DURATION_KEY) as int);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_OFFLINE_KEY) != null){
                _local2.offline = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_DVR_OFFLINE_KEY) as Boolean);
            };
            return (_local2);
        }
        private static function generateBestEffortFetchInfo(_arg1:Metadata):BestEffortFetchInfo{
            if (_arg1 == null){
                return (null);
            };
            var _local2:BestEffortFetchInfo = new BestEffortFetchInfo();
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_FORWARD_FETCHES) != null){
                _local2.maxForwardFetches = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_FORWARD_FETCHES) as uint);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_BACKWARD_FETCHES) != null){
                _local2.maxBackwardFetches = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_MAX_BACKWARD_FETCHES) as uint);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_SEGMENT_DURATION) != null){
                _local2.segmentDuration = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_SEGMENT_DURATION) as uint);
            };
            if (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_FRAGMENT_DURATION) != null){
                _local2.fragmentDuration = (_arg1.getValue(MetadataNamespaces.HTTP_STREAMING_BEST_EFFORT_FETCH_FRAGMENT_DURATION) as uint);
            };
            return (_local2);
        }
        private static function generateStreamInfos(_arg1:URLResource):Vector.<HTTPStreamingF4FStreamInfo>{
            var _local8:Object;
            var _local9:ByteArray;
            var _local10:DynamicStreamingItem;
            var _local11:String;
            var _local2:Vector.<HTTPStreamingF4FStreamInfo> = new Vector.<HTTPStreamingF4FStreamInfo>();
            var _local3:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.DRM_METADATA) as Metadata);
            var _local4:Metadata = (_arg1.getMetadataValue(MetadataNamespaces.HTTP_STREAMING_METADATA) as Metadata);
            var _local5:ByteArray;
            var _local6:BootstrapInfo;
            var _local7:DynamicStreamingResource = (_arg1 as DynamicStreamingResource);
            if (_local7 != null){
                for each (_local10 in _local7.streamItems) {
                    _local5 = null;
                    _local6 = null;
                    _local8 = null;
                    _local9 = null;
                    if (_local3 != null){
                        _local5 = (_local3.getValue((MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY + _local10.streamName)) as ByteArray);
                    };
                    if (_local4 != null){
                        _local6 = (_local4.getValue((MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY + _local10.streamName)) as BootstrapInfo);
                        _local8 = _local4.getValue((MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY + _local10.streamName));
                        _local9 = (_local4.getValue((MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY + _local10.streamName)) as ByteArray);
                    };
                    _local2.push(new HTTPStreamingF4FStreamInfo(_local6, _local10.streamName, _local10.bitrate, _local5, _local8, _local9));
                };
            } else {
                if (_local3 != null){
                    _local5 = (_local3.getValue(MetadataNamespaces.DRM_ADDITIONAL_HEADER_KEY) as ByteArray);
                };
                if (_local4 != null){
                    _local6 = (_local4.getValue(MetadataNamespaces.HTTP_STREAMING_BOOTSTRAP_KEY) as BootstrapInfo);
                    _local8 = _local4.getValue(MetadataNamespaces.HTTP_STREAMING_STREAM_METADATA_KEY);
                    _local9 = (_local4.getValue(MetadataNamespaces.HTTP_STREAMING_XMP_METADATA_KEY) as ByteArray);
                };
                _local11 = _arg1.url;
                _local2.push(new HTTPStreamingF4FStreamInfo(_local6, _local11, NaN, _local5, _local8, _local9));
            };
            return (_local2);
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {

    public class HTTPStreamingIndexInfoBase {

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.net.qos.*;
    import org.osmf.net.metrics.*;
    import org.osmf.net.rules.*;

    public class DefaultHTTPStreamingSwitchManager extends RuleSwitchManagerBase {

        private static const ACTUAL_BITRATE_MAX_FRAGMENTS:uint = 10;

        private var _minReliability:Number;
        private var _maxReliabilityRecordSize:uint;
        private var _minReliabilityRecordSize:uint;
        private var _normalRuleWeights:Vector.<Number>;
        private var _climbFactor:Number;
        private var _maxUpSwitchLimit:int;
        private var _maxDownSwitchLimit:int;
        private var decisionHistory:Vector.<Switch>;
        private var availableQualityLevelsMetric:MetricBase;
        private var actualBitrateMetric:MetricBase;
        private var _normalRules:Vector.<RuleBase>;

        public function DefaultHTTPStreamingSwitchManager(_arg1:EventDispatcher, _arg2:NetStreamSwitcher, _arg3:MetricRepository, _arg4:Vector.<RuleBase>=null, _arg5:Boolean=true, _arg6:Vector.<RuleBase>=null, _arg7:Vector.<Number>=null, _arg8:Number=0.85, _arg9:uint=5, _arg10:uint=30, _arg11:Number=0.9, _arg12:int=1, _arg13:int=2){
            super(_arg1, _arg2, _arg3, _arg4, _arg5);
            this.setNormalRules(_arg6);
            this.normalRuleWeights = _arg7;
            this.minReliability = _arg8;
            this.minReliabilityRecordSize = _arg9;
            this.maxReliabilityRecordSize = _arg10;
            this.climbFactor = _arg11;
            this.maxUpSwitchLimit = _arg12;
            this.maxDownSwitchLimit = _arg13;
            this.decisionHistory = new Vector.<Switch>();
            this.pushToHistory(currentIndex);
            this.availableQualityLevelsMetric = _arg3.getMetric(MetricType.AVAILABLE_QUALITY_LEVELS);
            this.actualBitrateMetric = _arg3.getMetric(MetricType.ACTUAL_BITRATE, ACTUAL_BITRATE_MAX_FRAGMENTS);
        }
        public function get normalRules():Vector.<RuleBase>{
            return (this._normalRules);
        }
        public function get normalRuleWeights():Vector.<Number>{
            return (this._normalRuleWeights);
        }
        public function set normalRuleWeights(_arg1:Vector.<Number>):void{
            ABRUtils.validateWeights(_arg1, this.normalRules.length);
            this._normalRuleWeights = _arg1.slice();
        }
        public function get minReliability():Number{
            return (this._minReliability);
        }
        public function set minReliability(_arg1:Number):void{
            if (((((isNaN(_arg1)) || ((_arg1 < 0)))) || ((_arg1 > 1)))){
                throw (new ArgumentError("The minReliability must be a number between 0 and 1."));
            };
            this._minReliability = _arg1;
        }
        public function get minReliabilityRecordSize():uint{
            return (this._minReliabilityRecordSize);
        }
        public function set minReliabilityRecordSize(_arg1:uint):void{
            if (_arg1 < 2){
                throw (new ArgumentError("The minReliabilityRecordSize must be equal or greater than 2."));
            };
            this._minReliabilityRecordSize = _arg1;
        }
        public function get maxReliabilityRecordSize():uint{
            return (this._maxReliabilityRecordSize);
        }
        public function set maxReliabilityRecordSize(_arg1:uint):void{
            if (_arg1 < this.minReliabilityRecordSize){
                this._maxReliabilityRecordSize = this.minReliabilityRecordSize;
            } else {
                this._maxReliabilityRecordSize = _arg1;
            };
        }
        public function get climbFactor():Number{
            return (this._climbFactor);
        }
        public function set climbFactor(_arg1:Number):void{
            if (((isNaN(_arg1)) || ((_arg1 <= 0)))){
                throw (new ArgumentError("The climbFactor must be a number greater than 0."));
            };
            this._climbFactor = _arg1;
        }
        public function get maxUpSwitchLimit():int{
            return (this._maxUpSwitchLimit);
        }
        public function set maxUpSwitchLimit(_arg1:int):void{
            if (_arg1 < 1){
                this._maxUpSwitchLimit = -1;
            } else {
                this._maxUpSwitchLimit = _arg1;
            };
        }
        public function get maxDownSwitchLimit():int{
            return (this._maxDownSwitchLimit);
        }
        public function set maxDownSwitchLimit(_arg1:int):void{
            if (_arg1 < 1){
                this._maxDownSwitchLimit = -1;
            } else {
                this._maxDownSwitchLimit = _arg1;
            };
        }
        public function getCurrentReliability(_arg1:uint):Number{
            var _local2:uint;
            var _local3:uint;
            var _local4:uint;
            while (_local4 < (this.decisionHistory.length - 1)) {
                if (this.decisionHistory[_local4].index == _arg1){
                    _local3++;
                    if (this.decisionHistory[(_local4 + 1)].index < this.decisionHistory[_local4].index){
                        if (this.decisionHistory[(_local4 + 1)].emergency == true){
                            return (0);
                        };
                        _local2++;
                    };
                };
                _local4++;
            };
            if (this.decisionHistory.length < this._minReliabilityRecordSize){
                return (Number.NaN);
            };
            if (_local3 == 0){
                return (Number.NaN);
            };
            if (_local2 == 0){
                return (1);
            };
            return ((1 - ((_local2 * _local2) / (_local3 * Math.floor((this.decisionHistory.length / 2))))));
        }
        override public function getNewIndex():uint{
            var _local2:QualityLevel;
            var _local8:Recommendation;
            var _local9:Number;
            var _local10:Number;
            var _local11:Number;
            var _local1:uint;
            var _local3:Number = 0;
            var _local4:Number = 0;
            var _local5:MetricValue = this.availableQualityLevelsMetric.value;
            if (!_local5.valid){
                throw (new Error("The available quality levels metric should always be valid"));
            };
            var _local6:Vector.<QualityLevel> = _local5.value;
            var _local7:uint;
            while (_local7 < this.normalRules.length) {
                _local8 = this.normalRules[_local7].getRecommendation();
                _local9 = (_local8.confidence * this.normalRuleWeights[_local7]);
                _local3 = (_local3 + (_local8.bitrate * _local9));
                _local4 = (_local4 + _local9);
                _local7++;
            };
            if (_local4 == 0){
                _local1 = actualIndex;
            } else {
                _local10 = (_local3 / _local4);
                _local11 = this.getCurrentActualBitrate();
                if (_local10 > _local11){
                    _local10 = (_local11 + (this._climbFactor * (_local10 - _local11)));
                };
                _local1 = this.getMaxIndex(_local10);
            };
            this.pushToHistory(_local1);
            return (_local1);
        }
        override public function getNewEmergencyIndex(_arg1:Number):uint{
            var _local2:uint = this.getMaxIndex(_arg1, true);
            this.pushToHistory(_local2, (_local2 < actualIndex));
            return (_local2);
        }
        protected function setNormalRules(_arg1:Vector.<RuleBase>):void{
            if ((((_arg1 == null)) || ((_arg1.length == 0)))){
                throw (new ArgumentError("You must provide at least one normal rule"));
            };
            this._normalRules = _arg1.slice();
        }
        protected function getMaxIndex(_arg1:Number, _arg2:Boolean=false):uint{
            var _local8:QualityLevel;
            var _local3:MetricValue = this.availableQualityLevelsMetric.value;
            if (!_local3.valid){
                throw (new Error("The available quality levels metric should always be valid"));
            };
            var _local4:Vector.<QualityLevel> = _local3.value;
            var _local5:QualityLevel = _local4[0];
            var _local6:uint;
            while (_local6 < _local4.length) {
                _local8 = _local4[_local6];
                if ((((((_local8.bitrate > _local5.bitrate)) && ((_local8.bitrate <= _arg1)))) && (this.isReliable(_local8.index)))){
                    _local5 = _local8;
                };
                _local6++;
            };
            var _local7:uint = _local5.index;
            if (((!(_arg2)) && (!((_local7 == actualIndex))))){
                if (_local7 > actualIndex){
                    if (this.maxUpSwitchLimit > 0){
                        while (((((((_local7 - actualIndex) > this.maxUpSwitchLimit)) || (!(this.isReliable(_local7))))) && ((_local7 > actualIndex)))) {
                            _local7--;
                        };
                    };
                } else {
                    if (this.maxDownSwitchLimit > 0){
                        while (((((((actualIndex - _local7) > this.maxDownSwitchLimit)) || (!(this.isReliable(_local7))))) && ((_local7 < actualIndex)))) {
                            _local7++;
                        };
                    };
                };
                _local5 = _local4[_local7];
            };
            return (_local5.index);
        }
        protected function isReliable(_arg1:uint):Boolean{
            var _local2:Number = this.getCurrentReliability(_arg1);
            if (isNaN(_local2)){
                return (true);
            };
            return ((_local2 > this._minReliability));
        }
        private function getCurrentActualBitrate():Number{
            var _local5:QualityLevel;
            var _local1:Number = 0;
            var _local2:MetricValue = this.availableQualityLevelsMetric.value;
            if (!_local2.valid){
                throw (new Error("The available quality levels metric should always be valid"));
            };
            var _local3:Vector.<QualityLevel> = _local2.value;
            var _local4:MetricValue = this.actualBitrateMetric.value;
            if (_local4.valid){
                _local1 = (_local4.value as Number);
            } else {
                for each (_local5 in _local3) {
                    if (_local5.index == actualIndex){
                        _local1 = _local5.bitrate;
                    };
                };
            };
            return (_local1);
        }
        private function pushToHistory(_arg1:uint, _arg2:Boolean=false):void{
            var _local3:Switch = new Switch();
            _local3.index = _arg1;
            _local3.emergency = _arg2;
            this.decisionHistory.push(_local3);
            if (this.decisionHistory.length > this._maxReliabilityRecordSize){
                this.decisionHistory.shift();
            };
        }

    }
}//package org.osmf.net.httpstreaming 

class Switch {

    public var index:uint = 0;
    public var emergency:Boolean = false;

    public function Switch(){
    }
}
﻿package org.osmf.net.httpstreaming.f4f {

    class FragmentDurationPair {

        private var _firstFragment:uint;
        private var _duration:uint;
        private var _durationAccrued:Number;
        private var _discontinuityIndicator:uint = 0;

        public function get firstFragment():uint{
            return (this._firstFragment);
        }
        public function set firstFragment(_arg1:uint):void{
            this._firstFragment = _arg1;
        }
        public function get duration():uint{
            return (this._duration);
        }
        public function set duration(_arg1:uint):void{
            this._duration = _arg1;
        }
        public function get durationAccrued():Number{
            return (this._durationAccrued);
        }
        public function set durationAccrued(_arg1:Number):void{
            this._durationAccrued = _arg1;
        }
        public function get discontinuityIndicator():uint{
            return (this._discontinuityIndicator);
        }
        public function set discontinuityIndicator(_arg1:uint):void{
            this._discontinuityIndicator = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import __AS3__.vec.*;

    public class AdobeBootstrapBox extends FullBox {

        private var _bootstrapVersion:uint;
        private var _profile:uint;
        private var _live:Boolean;
        private var _update:Boolean;
        private var _timeScale:uint;
        private var _currentMediaTime:Number;
        private var _smpteTimeCodeOffset:Number;
        private var _movieIdentifier:String;
        private var _serverEntryCount:uint;
        private var _serverBaseURLs:Vector.<String>;
        private var _qualitySegmentURLModifiers:Vector.<String>;
        private var _drmData:String;
        private var _metadata:String;
        private var _segmentRunTables:Vector.<AdobeSegmentRunTable>;
        private var _fragmentRunTables:Vector.<AdobeFragmentRunTable>;

        public function get bootstrapVersion():uint{
            return (this._bootstrapVersion);
        }
        public function set bootstrapVersion(_arg1:uint):void{
            this._bootstrapVersion = _arg1;
        }
        public function get profile():uint{
            return (this._profile);
        }
        public function set profile(_arg1:uint):void{
            this._profile = _arg1;
        }
        public function get live():Boolean{
            return (this._live);
        }
        public function set live(_arg1:Boolean):void{
            this._live = _arg1;
        }
        public function get update():Boolean{
            return (this._update);
        }
        public function set update(_arg1:Boolean):void{
            this._update = _arg1;
        }
        public function get timeScale():uint{
            return (this._timeScale);
        }
        public function set timeScale(_arg1:uint):void{
            this._timeScale = _arg1;
        }
        public function get currentMediaTime():Number{
            return (this._currentMediaTime);
        }
        public function set currentMediaTime(_arg1:Number):void{
            this._currentMediaTime = _arg1;
        }
        public function get smpteTimeCodeOffset():Number{
            return (this._smpteTimeCodeOffset);
        }
        public function set smpteTimeCodeOffset(_arg1:Number):void{
            this._smpteTimeCodeOffset = _arg1;
        }
        public function get movieIdentifier():String{
            return (this._movieIdentifier);
        }
        public function set movieIdentifier(_arg1:String):void{
            this._movieIdentifier = _arg1;
        }
        public function get serverBaseURLs():Vector.<String>{
            return (this._serverBaseURLs);
        }
        public function set serverBaseURLs(_arg1:Vector.<String>):void{
            this._serverBaseURLs = _arg1;
        }
        public function get qualitySegmentURLModifiers():Vector.<String>{
            return (this._qualitySegmentURLModifiers);
        }
        public function set qualitySegmentURLModifiers(_arg1:Vector.<String>):void{
            this._qualitySegmentURLModifiers = _arg1;
        }
        public function get drmData():String{
            return (this._drmData);
        }
        public function set drmData(_arg1:String):void{
            this._drmData = _arg1;
        }
        public function get metadata():String{
            return (this._metadata);
        }
        public function set metadata(_arg1:String):void{
            this._metadata = _arg1;
        }
        public function get segmentRunTables():Vector.<AdobeSegmentRunTable>{
            return (this._segmentRunTables);
        }
        public function set segmentRunTables(_arg1:Vector.<AdobeSegmentRunTable>):void{
            this._segmentRunTables = _arg1;
        }
        public function get fragmentRunTables():Vector.<AdobeFragmentRunTable>{
            return (this._fragmentRunTables);
        }
        public function set fragmentRunTables(_arg1:Vector.<AdobeFragmentRunTable>):void{
            var _local2:AdobeFragmentRunTable;
            this._fragmentRunTables = _arg1;
            if (((!((_arg1 == null))) && ((_arg1.length > 0)))){
                _local2 = _arg1[(_arg1.length - 1)];
                _local2.adjustEndEntryDurationAccrued(this._currentMediaTime);
            };
        }
        public function findSegmentId(_arg1:uint):uint{
            return (this._segmentRunTables[0].findSegmentIdByFragmentId(_arg1));
        }
        public function get totalFragments():uint{
            var _local1:AdobeFragmentRunTable = this._fragmentRunTables[(this._fragmentRunTables.length - 1)];
            var _local2:Vector.<FragmentDurationPair> = _local1.fragmentDurationPairs;
            var _local3:FragmentDurationPair = _local2[(_local2.length - 1)];
            if (_local3.duration == 0){
                _local3 = _local2[(_local2.length - 2)];
            };
            var _local4:Number = (this._currentMediaTime - _local3.durationAccrued);
            var _local5:uint = ((_local4)<=0) ? 0 : (_local4 / _local3.duration);
            return (((_local3.firstFragment + _local5) - 1));
        }
        public function get totalDuration():uint{
            if ((((this._fragmentRunTables == null)) || ((this._fragmentRunTables.length < 1)))){
                return (0);
            };
            var _local1:AdobeFragmentRunTable = this._fragmentRunTables[0];
            return ((this._currentMediaTime - _local1.fragmentDurationPairs[0].durationAccrued));
        }
        public function contentComplete():Boolean{
            var _local1:AdobeFragmentRunTable = this._fragmentRunTables[(this._fragmentRunTables.length - 1)];
            return (_local1.tableComplete());
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import flash.utils.*;

    class MediaDataBox extends Box {

        private var _data:ByteArray;

        public function get data():ByteArray{
            return (this._data);
        }
        public function set data(_arg1:ByteArray):void{
            this._data = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import org.osmf.elements.f4mClasses.*;
    import flash.utils.*;

    public class HTTPStreamingF4FStreamInfo {

        private var _streamName:String;
        private var _bitrate:Number;
        private var _bootstrap:BootstrapInfo;
        private var _additionalHeader:ByteArray;
        private var _streamMetadata:Object;
        private var _xmpMetadata:ByteArray;

        public function HTTPStreamingF4FStreamInfo(_arg1:BootstrapInfo, _arg2:String, _arg3:Number, _arg4:ByteArray, _arg5:Object, _arg6:ByteArray){
            this._streamName = _arg2;
            this._bitrate = _arg3;
            this._additionalHeader = _arg4;
            this._bootstrap = _arg1;
            this._streamMetadata = _arg5;
            this._xmpMetadata = _arg6;
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function get additionalHeader():ByteArray{
            return (this._additionalHeader);
        }
        public function get bootstrapInfo():BootstrapInfo{
            return (this._bootstrap);
        }
        public function get streamMetadata():Object{
            return (this._streamMetadata);
        }
        public function get xmpMetadata():ByteArray{
            return (this._xmpMetadata);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import org.osmf.events.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import org.osmf.net.dvr.*;
    import org.osmf.net.httpstreaming.*;
    import org.osmf.elements.f4mClasses.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.dvr.*;
    import org.osmf.net.httpstreaming.flv.*;
    import org.osmf.utils.*;

    public class HTTPStreamingF4FIndexHandler extends HTTPStreamingIndexHandlerBase {

        public static const DEFAULT_FRAGMENTS_THRESHOLD:uint = 5;
        private static const BEST_EFFORT_STATE_OFF:String = "off";
        private static const BEST_EFFORT_STATE_PLAY:String = "play";
        private static const BEST_EFFORT_STATE_SEEK_BACKWARD:String = "seekBackward";
        private static const BEST_EFFORT_STATE_SEEK_FORWARD:String = "seekForward";
        private static const BEST_EFFORT_PLAY_SITUAUTION_NORMAL:String = "normal";
        private static const BEST_EFFORT_PLAY_SITUAUTION_DROPOUT:String = "dropout";
        private static const BEST_EFFORT_PLAY_SITUAUTION_LIVENESS:String = "liveness";
        private static const BEST_EFFORT_PLAY_SITUAUTION_DONE:String = "done";

        private var _currentQuality:int = -1;
        private var _currentAdditionalHeader:ByteArray = null;
        private var _currentFAI:FragmentAccessInformation = null;
        private var _pureLiveOffset:Number = NaN;
        private var _f4fIndexInfo:HTTPStreamingF4FIndexInfo = null;
        private var _bootstrapBoxes:Vector.<AdobeBootstrapBox> = null;
        private var _bootstrapBoxesURLs:Vector.<String> = null;
        private var _streamInfos:Vector.<HTTPStreamingF4FStreamInfo> = null;
        private var _streamNames:Array = null;
        private var _streamQualityRates:Array = null;
        private var _serverBaseURL:String = null;
        private var _delay:Number = 0.05;
        private var _indexUpdating:Boolean = false;
        private var _pendingIndexLoads:int = 0;
        private var _pendingIndexUpdates:int = 0;
        private var _pendingIndexUrls:Object;
        private var _invokedFromDvrGetStreamInfo:Boolean = false;
        private var playInProgress:Boolean;
        private var bootstrapUpdateTimer:Timer;
        private var bootstrapUpdateInterval:Number = 4000;
        private var _bestEffortInited:Boolean = false;
        private var _bestEffortEnabled:Boolean = false;
        private var _bestEffortState:String = "off";
        private var _bestEffortSeekTime:Number = 0;
        private var _bestEffortDownloaderMonitor:EventDispatcher;
        private var _bestEffortFailedFetches:uint = 0;
        private var _bestEffortDownloadReply:String = null;
        private var _bestEffortNeedsToFireFragmentDuration:Boolean = false;
        private var _bestEffortF4FHandler:HTTPStreamingF4FFileHandler;
        private var _bestEffortSeekBuffer:ByteArray;
        private var _bestEffortNotifyBootstrapBoxInfo:Object = null;
        private var _bestEffortLivenessRestartPoint:uint = 0;
        private var _bestEffortLastGoodFragmentDownloadTime:Date = null;

        public function HTTPStreamingF4FIndexHandler(_arg1:HTTPStreamingFileHandlerBase, _arg2:uint=5){
            this._pendingIndexUrls = new Object();
            this._bestEffortDownloaderMonitor = new EventDispatcher();
            this._bestEffortF4FHandler = new HTTPStreamingF4FFileHandler();
            this._bestEffortSeekBuffer = new ByteArray();
            super();
            _arg1.addEventListener(HTTPStreamingFileHandlerEvent.NOTIFY_BOOTSTRAP_BOX, this.onBootstrapBox);
            this._bestEffortF4FHandler.addEventListener(HTTPStreamingFileHandlerEvent.NOTIFY_BOOTSTRAP_BOX, this.onBestEffortF4FHandlerNotifyBootstrapBox);
        }
        override public function dvrGetStreamInfo(_arg1:Object):void{
            this._invokedFromDvrGetStreamInfo = true;
            this.playInProgress = false;
            this.initialize(_arg1);
        }
        override public function initialize(_arg1:Object):void{
            var _local2:AdobeBootstrapBox;
            var _local5:HTTPStreamingF4FStreamInfo;
            var _local6:BootstrapInfo;
            this._f4fIndexInfo = (_arg1 as HTTPStreamingF4FIndexInfo);
            if ((((((this._f4fIndexInfo == null)) || ((this._f4fIndexInfo.streamInfos == null)))) || ((this._f4fIndexInfo.streamInfos.length <= 0)))){
                dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.INDEX_ERROR));
                return;
            };
            this._indexUpdating = false;
            this._pendingIndexLoads = 0;
            this._pendingIndexUpdates = 0;
            this._pendingIndexUrls = new Object();
            this.playInProgress = false;
            this._pureLiveOffset = NaN;
            this._serverBaseURL = this._f4fIndexInfo.serverBaseURL;
            this._streamInfos = this._f4fIndexInfo.streamInfos;
            var _local3:int = this._streamInfos.length;
            this._streamQualityRates = [];
            this._streamNames = [];
            this._bootstrapBoxesURLs = new Vector.<String>(_local3);
            this._bootstrapBoxes = new Vector.<AdobeBootstrapBox>(_local3);
            var _local4:int;
            while (_local4 < _local3) {
                _local5 = this._streamInfos[_local4];
                if (_local5 != null){
                    this._streamQualityRates[_local4] = _local5.bitrate;
                    this._streamNames[_local4] = _local5.streamName;
                    _local6 = _local5.bootstrapInfo;
                    if ((((_local6 == null)) || ((((_local6.url == null)) && ((_local6.data == null)))))){
                        dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.INDEX_ERROR));
                        return;
                    };
                    if (_local6.data != null){
                        _local2 = this.processBootstrapData(_local6.data, _local4);
                        if (_local2 == null){
                            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.INDEX_ERROR));
                            return;
                        };
                        this._bootstrapBoxes[_local4] = _local2;
                    } else {
                        this._bootstrapBoxesURLs[_local4] = HTTPStreamingUtils.normalizeURL(_local6.url);
                        this._pendingIndexLoads++;
                        this.dispatchIndexLoadRequest(_local4);
                    };
                };
                _local4++;
            };
            if (this._pendingIndexLoads == 0){
                this.notifyRatesReady();
                this.notifyIndexReady(0);
            };
        }
        override public function dispose():void{
            this.destroyBootstrapUpdateTimer();
        }
        override public function processIndexData(_arg1, _arg2:Object):void{
            var _local5:String;
            var _local3:int = (_arg2 as int);
            var _local4:AdobeBootstrapBox = this.processBootstrapData(_arg1, _local3);
            if (_local4 == null){
                dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.INDEX_ERROR));
                return;
            };
            if (!this._indexUpdating){
                this._pendingIndexLoads--;
            } else {
                this._pendingIndexUpdates--;
                _local5 = this._bootstrapBoxesURLs[_local3];
                if (((!((_local5 == null))) && (this._pendingIndexUrls.hasOwnProperty(_local5)))){
                    this._pendingIndexUrls[_local5].active = false;
                };
                if (this._pendingIndexUpdates == 0){
                    this._indexUpdating = false;
                };
            };
            this.updateBootstrapBox(_local3, _local4, true);
            if ((((this._pendingIndexLoads == 0)) && (!(this._indexUpdating)))){
                this.notifyRatesReady();
                this.notifyIndexReady(_local3);
            };
        }
        override public function getFileForTime(_arg1:Number, _arg2:int):HTTPStreamRequest{
            var _local4:HTTPStreamRequest;
            if ((((((_arg2 < 0)) || ((_arg2 >= this._streamInfos.length)))) || ((_arg1 < 0)))){
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            this._bestEffortState = BEST_EFFORT_STATE_OFF;
            var _local3:AdobeBootstrapBox = this._bootstrapBoxes[_arg2];
            if (_local3 == null){
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            if (((!(this.playInProgress)) && (this.isStopped(_local3)))){
                this.destroyBootstrapUpdateTimer();
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            this.updateMetadata(_arg2);
            var _local5:Number = (_arg1 * _local3.timeScale);
            if (this._bestEffortEnabled){
                _local4 = this.getFirstRequestForBestEffortSeek(_local5, _arg2, _local3);
            } else {
                _local4 = this.getSeekRequestForNormalFetch(_local5, _arg2, _local3);
            };
            return (_local4);
        }
        private function getSeekRequestForNormalFetch(_arg1:Number, _arg2:int, _arg3:AdobeBootstrapBox):HTTPStreamRequest{
            var _local4:HTTPStreamRequest;
            var _local5:Boolean;
            var _local6:Number = _arg3.currentMediaTime;
            var _local7:Boolean = _arg3.contentComplete();
            var _local8:AdobeFragmentRunTable = this.getFragmentRunTable(_arg3);
            if (_arg1 <= _local6){
                if (_local8 != null){
                    this._currentFAI = _local8.findFragmentIdByTime(_arg1, _local6, ((_local7) ? false : _arg3.live));
                };
                if ((((this._currentFAI == null)) || (this.fragmentOverflow(_arg3, this._currentFAI.fragId)))){
                    if (((!(_arg3.live)) || (_local7))){
                        return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
                    };
                    return (this.initiateLivenessFailure(_arg2));
                };
                return (this.initiateNormalDownload(_arg3, _arg2));
            };
            if (_arg3.live){
                return (this.initiateBootstrapRefresh(_arg2));
            };
            return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
        }
        override public function getNextFile(_arg1:int):HTTPStreamRequest{
            if ((((_arg1 < 0)) || ((_arg1 >= this._streamInfos.length)))){
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            var _local2:AdobeBootstrapBox = this._bootstrapBoxes[_arg1];
            if (_local2 == null){
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            if (((!(this.playInProgress)) && (this.isStopped(_local2)))){
                this.destroyBootstrapUpdateTimer();
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            this.updateMetadata(_arg1);
            var _local3:HTTPStreamRequest;
            if (this._bestEffortEnabled){
                if ((((this._bestEffortState == BEST_EFFORT_STATE_OFF)) || ((this._bestEffortState == BEST_EFFORT_STATE_PLAY)))){
                    _local3 = this.getNextRequestForBestEffortPlay(_arg1, _local2);
                } else {
                    _local3 = this.getNextRequestForBestEffortSeek(_arg1, _local2);
                };
            } else {
                _local3 = this.getNextRequestForNormalPlay(_arg1, _local2);
            };
            return (_local3);
        }
        private function getNextRequestForNormalPlay(_arg1:int, _arg2:AdobeBootstrapBox):HTTPStreamRequest{
            var _local3:HTTPStreamRequest;
            var _local4:Number = _arg2.currentMediaTime;
            var _local5:Boolean = _arg2.contentComplete();
            var _local6:FragmentAccessInformation = this._currentFAI;
            var _local7:AdobeFragmentRunTable = this.getFragmentRunTable(_arg2);
            if (_local6 == null){
                this._currentFAI = null;
            };
            if (_local7 != null){
                this._currentFAI = _local7.validateFragment((_local6.fragId + 1), _local4, ((_local5) ? false : _arg2.live));
            };
            if ((((this._currentFAI == null)) || (this.fragmentOverflow(_arg2, this._currentFAI.fragId)))){
                this._currentFAI = _local6;
                if (((!(_arg2.live)) || (_local5))){
                    return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
                };
                this._currentFAI = _local6;
                return (this.initiateLivenessFailure(_arg1));
            };
            return (this.initiateNormalDownload(_arg2, _arg1));
        }
        private function initiateLivenessFailure(_arg1:int):HTTPStreamRequest{
            var _local2:Number;
            this.adjustDelay();
            this.refreshBootstrapBox(_arg1);
            if (this._bestEffortEnabled){
                _local2 = Math.max(((this._f4fIndexInfo.bestEffortFetchInfo.fragmentDuration / 2) / 1000), 1);
            } else {
                _local2 = this._delay;
            };
            return (new HTTPStreamRequest(HTTPStreamRequestKind.LIVE_STALL, null, _local2));
        }
        private function initiateBootstrapRefresh(_arg1:int):HTTPStreamRequest{
            this.adjustDelay();
            this.refreshBootstrapBox(_arg1);
            return (new HTTPStreamRequest(HTTPStreamRequestKind.RETRY, null, this._delay));
        }
        private function initiateNormalDownload(_arg1:AdobeBootstrapBox, _arg2:int):HTTPStreamRequest{
            this.stopListeningToBestEffortDownload();
            this._bestEffortLivenessRestartPoint = this._currentFAI.fragId;
            this._bestEffortLastGoodFragmentDownloadTime = new Date();
            this.playInProgress = true;
            this.updateQuality(_arg2);
            this.notifyFragmentDuration((this._currentFAI.fragDuration / _arg1.timeScale));
            return (new HTTPStreamRequest(HTTPStreamRequestKind.DOWNLOAD, this.getFragmentUrl(_arg2, this._currentFAI)));
        }
        private function fragmentOverflow(_arg1:AdobeBootstrapBox, _arg2:uint):Boolean{
            var _local3:AdobeFragmentRunTable = _arg1.fragmentRunTables[0];
            var _local4:FragmentDurationPair = _local3.fragmentDurationPairs[0];
            var _local5:AdobeSegmentRunTable = _arg1.segmentRunTables[0];
            return ((((_local5 == null)) || ((((_local5.totalFragments + _local4.firstFragment) - 1) < _arg2))));
        }
        private function isStopped(_arg1:AdobeBootstrapBox):Boolean{
            var _local3:AdobeFragmentRunTable;
            var _local2:Boolean;
            if (this._f4fIndexInfo.dvrInfo != null){
                _local2 = this._f4fIndexInfo.dvrInfo.offline;
            } else {
                if (((!((_arg1 == null))) && (_arg1.live))){
                    _local3 = this.getFragmentRunTable(_arg1);
                    if (_local3 != null){
                        _local2 = _local3.tableComplete();
                    };
                };
            };
            return (_local2);
        }
        private function getFragmentUrl(_arg1:int, _arg2:FragmentAccessInformation):String{
            var _local3:AdobeBootstrapBox = this._bootstrapBoxes[_arg1];
            var _local4:AdobeFragmentRunTable = this.getFragmentRunTable(_local3);
            var _local5:FragmentDurationPair = _local4.fragmentDurationPairs[0];
            var _local6:uint = _local3.findSegmentId(((_arg2.fragId - _local5.firstFragment) + 1));
            return (this.constructFragmentRequest(this._serverBaseURL, this._streamNames[_arg1], _local6, _arg2.fragId));
        }
        protected function constructFragmentRequest(_arg1:String, _arg2:String, _arg3:uint, _arg4:uint):String{
            var _local5 = "";
            if (((!((_arg2 == null))) && (!((_arg2.indexOf("http") == 0))))){
                _local5 = (_arg1 + "/");
            };
            _local5 = (_local5 + _arg2);
            var _local6:URL = new URL(_local5);
            new URL(_local5).path = (_local6.path + ((("Seg" + _arg3) + "-Frag") + _arg4));
            _local5 = ((_local6.protocol + "://") + _local6.host);
            if (((!((_local6.port == null))) && ((_local6.port.length > 0)))){
                _local5 = (_local5 + (":" + _local6.port));
            };
            _local5 = (_local5 + ("/" + _local6.path));
            if (((!((_local6.query == null))) && ((_local6.query.length > 0)))){
                _local5 = (_local5 + ("?" + _local6.query));
            };
            if (((!((_local6.fragment == null))) && ((_local6.fragment.length > 0)))){
                _local5 = (_local5 + ("#" + _local6.fragment));
            };
            return (_local5);
        }
        private function getFragmentRunTable(_arg1:AdobeBootstrapBox):AdobeFragmentRunTable{
            if (_arg1 == null){
                return (null);
            };
            return (_arg1.fragmentRunTables[0]);
        }
        private function adjustDelay():void{
            if (this._delay < 1){
                this._delay = (this._delay * 2);
                if (this._delay > 1){
                    this._delay = 1;
                };
            };
        }
        private function refreshBootstrapBox(_arg1:uint):void{
            var _local7:Date;
            var _local2:String = this._bootstrapBoxesURLs[_arg1];
            if (_local2 == null){
                return;
            };
            var _local3:Object;
            if (this._pendingIndexUrls.hasOwnProperty(_local2)){
                _local3 = this._pendingIndexUrls[_local2];
            } else {
                _local3 = new Object();
                _local3["active"] = false;
                _local3["date"] = null;
                this._pendingIndexUrls[_local2] = _local3;
            };
            var _local4:Boolean = _local3.active;
            var _local5:Date = new Date();
            var _local6:Number = 0;
            if (((!(_local4)) && ((OSMFSettings.hdsMinimumBootstrapRefreshInterval > 0)))){
                _local7 = _local3["date"];
                _local6 = Number.MAX_VALUE;
                if (_local7 != null){
                    _local6 = (_local5.valueOf() - _local7.valueOf());
                };
                _local4 = (_local6 < OSMFSettings.hdsMinimumBootstrapRefreshInterval);
            };
            if (!_local4){
                this._pendingIndexUrls[_local2].date = _local5;
                this._pendingIndexUrls[_local2].active = true;
                this._pendingIndexUpdates++;
                this._indexUpdating = true;
                this.dispatchIndexLoadRequest(_arg1);
            };
        }
        private function updateBootstrapBox(_arg1:int, _arg2:AdobeBootstrapBox, _arg3:Boolean):void{
            if (this.shouldAcceptBootstrapBox(_arg1, _arg2, _arg3)){
                this._bootstrapBoxes[_arg1] = _arg2;
                this._delay = 0.05;
                if (_arg1 == this._currentQuality){
                    this.dispatchDVRStreamInfo(_arg2);
                };
            };
        }
        private function shouldAcceptBootstrapBox(_arg1:int, _arg2:AdobeBootstrapBox, _arg3:Boolean):Boolean{
            var _local7:AdobeFragmentRunTable;
            var _local8:AdobeSegmentRunTable;
            var _local9:uint;
            var _local10:uint;
            var _local4:AdobeBootstrapBox = this._bootstrapBoxes[_arg1];
            if ((((((_arg2 == null)) || ((_arg2.fragmentRunTables.length == 0)))) || ((_arg2.segmentRunTables.length == 0)))){
                return (false);
            };
            var _local5:AdobeFragmentRunTable = _arg2.fragmentRunTables[0];
            var _local6:AdobeSegmentRunTable = _arg2.segmentRunTables[0];
            if ((((_local5 == null)) || ((_local6 == null)))){
                return (false);
            };
            if (_local5.firstFragmentId == 0){
                return (false);
            };
            if (_local4 == null){
                return (true);
            };
            if (_local4.live != _arg2.live){
                return (false);
            };
            if (!_local4.live){
                if (_arg2.version != _local4.version){
                    return ((_arg2.version > _local4.version));
                };
                return ((_arg2.currentMediaTime > _local4.currentMediaTime));
            };
            if (!_arg3){
                return (false);
            };
            _local7 = _local4.fragmentRunTables[0];
            _local8 = _local4.segmentRunTables[0];
            if (_arg2.currentMediaTime != _local4.currentMediaTime){
                return ((_arg2.currentMediaTime > _local4.currentMediaTime));
            };
            if (_local5.firstFragmentId != _local7.firstFragmentId){
                return ((_local5.firstFragmentId < _local7.firstFragmentId));
            };
            _local9 = _local5.countGapFragments();
            _local10 = _local7.countGapFragments();
            if (_local9 != _local10){
                return ((_local9 < _local10));
            };
            if (((_arg2.contentComplete()) && (!(_local4.contentComplete())))){
                return (true);
            };
            return (false);
        }
        private function processBootstrapData(_arg1, _arg2:Object):AdobeBootstrapBox{
            var boxes:* = null;
            var data:* = _arg1;
            var indexContext:* = _arg2;
            var parser:* = new BoxParser();
            data.position = 0;
            parser.init(data);
            try {
                boxes = parser.getBoxes();
            } catch(e:Error) {
                boxes = null;
            };
            if ((((boxes == null)) || ((boxes.length < 1)))){
                return (null);
            };
            var bootstrapBox:* = (boxes[0] as AdobeBootstrapBox);
            if (bootstrapBox == null){
                return (null);
            };
            if ((((this._serverBaseURL == null)) || ((this._serverBaseURL.length <= 0)))){
                if ((((bootstrapBox.serverBaseURLs == null)) || ((bootstrapBox.serverBaseURLs.length <= 0)))){
                    return (null);
                };
                this._serverBaseURL = bootstrapBox.serverBaseURLs[0];
            };
            return (bootstrapBox);
        }
        private function updateQuality(_arg1:int):void{
            var _local2:ByteArray;
            var _local3:ByteArray;
            if (_arg1 != this._currentQuality){
                _local2 = this._currentAdditionalHeader;
                _local3 = this._streamInfos[_arg1].additionalHeader;
                this._currentQuality = _arg1;
                this._currentAdditionalHeader = _local3;
                if (((!((_local3 == null))) && (!((_local3 == _local2))))){
                    this.dispatchAdditionalHeader(_local3);
                };
            };
        }
        private function updateMetadata(_arg1:int):void{
            var _local2:AdobeBootstrapBox;
            if (_arg1 != this._currentQuality){
                _local2 = this._bootstrapBoxes[_arg1];
                if (_local2 != null){
                    this.notifyTotalDuration((_local2.totalDuration / _local2.timeScale), _arg1);
                };
            };
        }
        private function dispatchAdditionalHeader(_arg1:ByteArray):void{
            var _local2:FLVTagScriptDataObject = new FLVTagScriptDataObject();
            _local2.data = _arg1;
            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.SCRIPT_DATA, false, false, 0, _local2, FLVTagScriptDataMode.FIRST));
        }
        private function dispatchDVRStreamInfo(_arg1:AdobeBootstrapBox):void{
            var _local4:Number;
            var _local5:Number;
            var _local6:Number;
            var _local7:Number;
            var _local2:AdobeFragmentRunTable = this.getFragmentRunTable(_arg1);
            var _local3:DVRInfo = this._f4fIndexInfo.dvrInfo;
            if (_local3 != null){
                _local3.isRecording = !(_local2.tableComplete());
                _local4 = (_arg1.totalDuration / _arg1.timeScale);
                _local5 = (_arg1.currentMediaTime / _arg1.timeScale);
                if (isNaN(_local3.startTime)){
                    if (!_local3.isRecording){
                        _local3.startTime = 0;
                    } else {
                        _local6 = (((((_local3.beginOffset < 0)) || (isNaN(_local3.beginOffset)))) ? 0 : _local3.beginOffset);
                        _local7 = (((((_local3.endOffset < 0)) || (isNaN(_local3.endOffset)))) ? 0 : _local3.endOffset);
                        _local3.startTime = DVRUtils.calculateOffset(_local6, _local7, _local4);
                    };
                    _local3.startTime = (_local3.startTime + (_local2.fragmentDurationPairs[0].durationAccrued / _arg1.timeScale));
                    if (_local3.startTime > _local5){
                        _local3.startTime = _local5;
                    };
                };
                _local3.curLength = (_local5 - _local3.startTime);
                if (((!((_local3.windowDuration == -1))) && ((_local3.curLength > _local3.windowDuration)))){
                    _local3.startTime = (_local3.startTime + (_local3.curLength - _local3.windowDuration));
                    _local3.curLength = _local3.windowDuration;
                };
                dispatchEvent(new DVRStreamInfoEvent(DVRStreamInfoEvent.DVRSTREAMINFO, false, false, _local3));
            };
        }
        private function dispatchIndexLoadRequest(_arg1:int):void{
            dispatchEvent(new HTTPStreamingIndexHandlerEvent(HTTPStreamingIndexHandlerEvent.REQUEST_LOAD_INDEX, false, false, false, NaN, null, null, new URLRequest(this._bootstrapBoxesURLs[_arg1]), _arg1, true));
        }
        private function notifyRatesReady():void{
            dispatchEvent(new HTTPStreamingIndexHandlerEvent(HTTPStreamingIndexHandlerEvent.RATES_READY, false, false, false, NaN, this._streamNames, this._streamQualityRates));
        }
        private function notifyIndexReady(_arg1:int):void{
            var _local2:AdobeBootstrapBox = this._bootstrapBoxes[_arg1];
            var _local3:AdobeFragmentRunTable = this.getFragmentRunTable(_local2);
            if (!this._bestEffortInited){
                this._bestEffortEnabled = ((!((this._f4fIndexInfo.bestEffortFetchInfo == null))) && (_local2.live));
                this._bestEffortInited = true;
            };
            this.dispatchDVRStreamInfo(_local2);
            if (!this._invokedFromDvrGetStreamInfo){
                if (((((_local2.live) && ((this._f4fIndexInfo.dvrInfo == null)))) && (isNaN(this._pureLiveOffset)))){
                    this._pureLiveOffset = (_local2.currentMediaTime - (OSMFSettings.hdsPureLiveOffset * _local2.timeScale));
                    if (this._pureLiveOffset < 0){
                        this._pureLiveOffset = NaN;
                    } else {
                        this._pureLiveOffset = (this._pureLiveOffset / _local2.timeScale);
                    };
                };
                if (((((_local2.live) && (!((this._f4fIndexInfo.dvrInfo == null))))) && (!((this._f4fIndexInfo.dvrInfo.windowDuration == -1))))){
                    this.initializeBootstrapUpdateTimer();
                };
                if (_local3.tableComplete()){
                    this.destroyBootstrapUpdateTimer();
                };
                dispatchEvent(new HTTPStreamingIndexHandlerEvent(HTTPStreamingIndexHandlerEvent.INDEX_READY, false, false, _local2.live, this._pureLiveOffset));
            };
            this._invokedFromDvrGetStreamInfo = false;
        }
        private function notifyTotalDuration(_arg1:Number, _arg2:int):void{
            var _local3:Object = this._streamInfos[_arg2].streamMetadata;
            if (_local3 == null){
                _local3 = new Object();
            };
            _local3.duration = _arg1;
            var _local4:FLVTagScriptDataObject = new FLVTagScriptDataObject();
            _local4.objects = ["onMetaData", _local3];
            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.SCRIPT_DATA, false, false, 0, _local4, FLVTagScriptDataMode.IMMEDIATE));
        }
        private function notifyFragmentDuration(_arg1:Number):void{
            this.bootstrapUpdateInterval = (_arg1 * 1000);
            if (this.bootstrapUpdateInterval < OSMFSettings.hdsMinimumBootstrapRefreshInterval){
                this.bootstrapUpdateInterval = OSMFSettings.hdsMinimumBootstrapRefreshInterval;
            };
            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.FRAGMENT_DURATION, false, false, _arg1, null, null));
        }
        private function initializeBootstrapUpdateTimer():void{
            if (this.bootstrapUpdateTimer == null){
                this.bootstrapUpdateTimer = new Timer(this.bootstrapUpdateInterval);
                this.bootstrapUpdateTimer.addEventListener(TimerEvent.TIMER, this.onBootstrapUpdateTimer);
                this.bootstrapUpdateTimer.start();
            };
        }
        private function destroyBootstrapUpdateTimer():void{
            if (this.bootstrapUpdateTimer != null){
                this.bootstrapUpdateTimer.removeEventListener(TimerEvent.TIMER, this.onBootstrapUpdateTimer);
                this.bootstrapUpdateTimer = null;
            };
        }
        private function onBootstrapBox(_arg1:HTTPStreamingFileHandlerEvent):void{
            this.updateBootstrapBox(this._currentQuality, _arg1.bootstrapBox, false);
            this.notifyFragmentDurationForBestEffort(_arg1.bootstrapBox);
        }
        private function onBootstrapUpdateTimer(_arg1:TimerEvent):void{
            if (this._currentQuality != -1){
                this.refreshBootstrapBox(this._currentQuality);
                this.bootstrapUpdateTimer.delay = this.bootstrapUpdateInterval;
            };
        }
        private function getFirstRequestForBestEffortSeek(_arg1:Number, _arg2:int, _arg3:AdobeBootstrapBox):HTTPStreamRequest{
            this.bestEffortLog(("Initiating best effort seek " + _arg1));
            this._bestEffortState = BEST_EFFORT_STATE_SEEK_BACKWARD;
            this._bestEffortSeekTime = _arg1;
            this._bestEffortFailedFetches = 0;
            this._bestEffortLastGoodFragmentDownloadTime = null;
            return (this.getNextRequestForBestEffortSeek(_arg2, _arg3));
        }
        private function getNextRequestForBestEffortSeek(_arg1:int, _arg2:AdobeBootstrapBox):HTTPStreamRequest{
            var _local3:AdobeFragmentRunTable = this.getFragmentRunTable(_arg2);
            if (_local3 == null){
                this.bestEffortLog("Best effort done because the bootstrap box was invalid");
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            this.stopListeningToBestEffortDownload();
            this._currentFAI = null;
            var _local4:uint = this.doBestEffortSeek(_arg2, _local3);
            if (_local4 != 0){
                this.bestEffortLog(("Best effort seek fetch for fragment " + _local4));
                this._bestEffortF4FHandler.beginProcessFile(true, this._bestEffortSeekTime);
                this._bestEffortSeekBuffer.length = 0;
                this._bestEffortSeekBuffer.position = 0;
                return (this.initiateBestEffortRequest(_local4, _arg1));
            };
            this._bestEffortState = BEST_EFFORT_STATE_OFF;
            this._currentFAI = _local3.getFragmentWithTimeGreq(this._bestEffortSeekTime);
            if (this._currentFAI == null){
                this.bestEffortLog("Best effort done because there were no bootstrap entries");
                this._bestEffortState = BEST_EFFORT_STATE_OFF;
                this._bestEffortLivenessRestartPoint = (Math.max(this.guessFragmentIdForTime(this._bestEffortSeekTime), 1) - 1);
                this._currentFAI = new FragmentAccessInformation();
                this._currentFAI.fragId = this._bestEffortLivenessRestartPoint;
                return (this.getNextFile(_arg1));
            };
            this.bestEffortLog(("Normal seek request for fragment " + this._currentFAI.fragId));
            return (this.initiateNormalDownload(_arg2, _arg1));
        }
        private function guessFragmentIdForTime(_arg1:Number):uint{
            return ((uint(Math.floor((_arg1 / this._f4fIndexInfo.bestEffortFetchInfo.fragmentDuration))) + 1));
        }
        private function doBestEffortSeek(_arg1:AdobeBootstrapBox, _arg2:AdobeFragmentRunTable):uint{
            var _local5:Number;
            var _local6:uint;
            if (this._bestEffortSeekTime >= _arg1.currentMediaTime){
                this.bestEffortLog("Seek time greter than current media time.");
                return (0);
            };
            if (!_arg2.isTimeInGap(this._bestEffortSeekTime, this._f4fIndexInfo.bestEffortFetchInfo.fragmentDuration)){
                this.bestEffortLog("Found seek time in FRT");
                return (0);
            };
            var _local3:FragmentAccessInformation = _arg2.getFragmentWithIdGreq(0);
            if (_local3 != null){
                _local5 = (_local3.fragmentEndTime - _local3.fragDuration);
                if (this._bestEffortSeekTime < _local5){
                    this.bestEffortLog("Seek time before first bootstrap entry time.");
                    return (0);
                };
            };
            if (this._bestEffortState == BEST_EFFORT_STATE_SEEK_BACKWARD){
                _local6 = this.doBestEffortSeekBackward(_arg2);
                if (_local6 != 0){
                    return (_local6);
                };
                this._bestEffortState = BEST_EFFORT_STATE_SEEK_FORWARD;
                this._bestEffortFailedFetches = 0;
            };
            var _local4:uint = this.doBestEffortSeekForward(_arg2);
            if (_local4 != 0){
                return (_local4);
            };
            return (0);
        }
        private function doBestEffortSeekBackward(_arg1:AdobeFragmentRunTable):uint{
            if (this._bestEffortFailedFetches >= this._f4fIndexInfo.bestEffortFetchInfo.maxBackwardFetches){
                this.bestEffortLog("Best effort seek backward failing due to too many failures");
                return (0);
            };
            var _local2:uint = this.guessFragmentIdForTime(this._bestEffortSeekTime);
            if (_local2 <= (this._bestEffortFailedFetches + 1)){
                this.bestEffortLog("Best effort seek backward hit fragment 0");
                return (0);
            };
            var _local3:uint = (_local2 - (this._bestEffortFailedFetches + 1));
            if (!_arg1.isFragmentInGap(_local3)){
                this.bestEffortLog(("Best effort seek backward hit an existing fragment " + _local3));
                return (0);
            };
            this.bestEffortLog(("Best effort seek backward fetch " + _local3));
            return (_local3);
        }
        private function doBestEffortSeekForward(_arg1:AdobeFragmentRunTable):uint{
            if (this._bestEffortFailedFetches >= this._f4fIndexInfo.bestEffortFetchInfo.maxForwardFetches){
                this.bestEffortLog("Best effort seek failing due to too many failures");
                return (0);
            };
            var _local2:uint = (this.guessFragmentIdForTime(this._bestEffortSeekTime) + this._bestEffortFailedFetches);
            if (!_arg1.isFragmentInGap(_local2)){
                this.bestEffortLog(("Best effort seek forward hit an existing fragment " + _local2));
                return (0);
            };
            this.bestEffortLog(("Best effort seek forward fetch " + _local2));
            return (_local2);
        }
        private function getNextRequestForBestEffortPlay(_arg1:int, _arg2:AdobeBootstrapBox):HTTPStreamRequest{
            var _local8:String;
            var _local9:Date;
            var _local10:Number;
            var _local11:FragmentAccessInformation;
            var _local3:AdobeFragmentRunTable = this.getFragmentRunTable(_arg2);
            if ((((((((((this._currentFAI == null)) || ((_local3 == null)))) || ((_arg2 == null)))) || ((_arg2.segmentRunTables.length < 1)))) || ((_arg2.segmentRunTables[0].segmentFragmentPairs.length < 1)))){
                this.bestEffortLog("Best effort in a weird state.");
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            var _local4:AdobeSegmentRunTable = _arg2.segmentRunTables[0];
            var _local5:uint = (this._currentFAI.fragId + 1);
            var _local6:uint = _local3.firstFragmentId;
            if (_local6 == 0){
                this.bestEffortLog("Best effort in a weird state.");
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            var _local7:uint = (_local6 + _local4.totalFragments);
            if (_local5 >= _local7){
                if (_arg2.contentComplete()){
                    _local8 = BEST_EFFORT_PLAY_SITUAUTION_DONE;
                } else {
                    _local8 = BEST_EFFORT_PLAY_SITUAUTION_LIVENESS;
                };
            } else {
                if (_local3.isFragmentInGap(_local5)){
                    _local8 = BEST_EFFORT_PLAY_SITUAUTION_DROPOUT;
                } else {
                    _local8 = BEST_EFFORT_PLAY_SITUAUTION_NORMAL;
                };
            };
            if ((((_local8 == BEST_EFFORT_PLAY_SITUAUTION_DROPOUT)) || ((_local8 == BEST_EFFORT_PLAY_SITUAUTION_LIVENESS)))){
                this.bestEffortLog(("Best effort in " + _local8));
                if ((((_local8 == BEST_EFFORT_PLAY_SITUAUTION_LIVENESS)) && (!((this._bestEffortLastGoodFragmentDownloadTime == null))))){
                    _local9 = new Date();
                    _local10 = (this._bestEffortLastGoodFragmentDownloadTime.valueOf() + Math.max(this._f4fIndexInfo.bestEffortFetchInfo.fragmentDuration, 1000));
                    if (_local9.valueOf() < _local10){
                        return (this.initiateBootstrapRefresh(_arg1));
                    };
                };
                if (this._bestEffortState == BEST_EFFORT_STATE_OFF){
                    this.bestEffortLog("Best effort play start");
                    this._bestEffortState = BEST_EFFORT_STATE_PLAY;
                    this._bestEffortFailedFetches = 0;
                };
                if (this._bestEffortFailedFetches < this._f4fIndexInfo.bestEffortFetchInfo.maxForwardFetches){
                    return (this.initiateBestEffortRequest(_local5, _arg1));
                };
                this.bestEffortLog("Best effort play failing due to too many failures");
            };
            if (_local8 == BEST_EFFORT_PLAY_SITUAUTION_LIVENESS){
                this.bestEffortLog("Best effort in liveness");
                this._bestEffortState = BEST_EFFORT_STATE_OFF;
                this._currentFAI.fragId = this._bestEffortLivenessRestartPoint;
                return (this.initiateLivenessFailure(_arg1));
            };
            if (_local8 == BEST_EFFORT_PLAY_SITUAUTION_DONE){
                this.bestEffortLog("Best effort done");
                return (new HTTPStreamRequest(HTTPStreamRequestKind.DONE));
            };
            _local11 = this._currentFAI;
            this._currentFAI = _local3.getFragmentWithIdGreq(_local5);
            if (this._currentFAI == null){
                this._currentFAI = _local11;
                this.bestEffortLog("Best effort done because there were no bootstrap entries");
                return (this.initiateBootstrapRefresh(_arg1));
            };
            this._bestEffortState = BEST_EFFORT_STATE_OFF;
            this.bestEffortLog(("Normal play request for fragment " + this._currentFAI.fragId));
            return (this.initiateNormalDownload(_arg2, _arg1));
        }
        private function initiateBestEffortRequest(_arg1:uint, _arg2:int):HTTPStreamRequest{
            this.stopListeningToBestEffortDownload();
            this._currentFAI = new FragmentAccessInformation();
            this._currentFAI.fragId = _arg1;
            this._currentFAI.fragDuration = 0;
            this._currentFAI.fragmentEndTime = 0;
            this.playInProgress = true;
            this.updateQuality(_arg2);
            this.bootstrapUpdateInterval = OSMFSettings.hdsMinimumBootstrapRefreshInterval;
            var _local3:uint = uint(Math.ceil((Number(_arg1) / (this._f4fIndexInfo.bestEffortFetchInfo.segmentDuration / this._f4fIndexInfo.bestEffortFetchInfo.fragmentDuration))));
            var _local4:String = this.constructFragmentRequest(this._serverBaseURL, this._streamNames[_arg2], _local3, _arg1);
            this.bestEffortLog(((((("Best effort fetch for fragment " + _arg1) + " with url ") + _local4) + ". State is ") + this._bestEffortState));
            this._bestEffortDownloadReply = null;
            this._bestEffortNeedsToFireFragmentDuration = false;
            this._bestEffortDownloaderMonitor = new EventDispatcher();
            this._bestEffortDownloaderMonitor.addEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onBestEffortDownloadComplete);
            this._bestEffortDownloaderMonitor.addEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onBestEffortDownloadError);
            var _local5:HTTPStreamRequest = new HTTPStreamRequest(HTTPStreamRequestKind.BEST_EFFORT_DOWNLOAD, _local4, -1, this._bestEffortDownloaderMonitor);
            this.adjustDelay();
            this.refreshBootstrapBox(_arg2);
            return (_local5);
        }
        private function stopListeningToBestEffortDownload():void{
            if (this._bestEffortDownloaderMonitor != null){
                this._bestEffortDownloaderMonitor.removeEventListener(HTTPStreamingEvent.DOWNLOAD_COMPLETE, this.onBestEffortDownloadComplete);
                this._bestEffortDownloaderMonitor.removeEventListener(HTTPStreamingEvent.DOWNLOAD_ERROR, this.onBestEffortDownloadError);
                this._bestEffortDownloaderMonitor = null;
            };
        }
        private function bufferAndParseDownloadedBestEffortBytes(_arg1:String, _arg2:HTTPStreamDownloader):void{
            var downloaderAvailableBytes:* = 0;
            var downloadInput:* = null;
            var url:* = _arg1;
            var downloader:* = _arg2;
            if (this._bestEffortDownloadReply != null){
                return;
            };
            this._bestEffortNotifyBootstrapBoxInfo = {
                downloader:downloader,
                url:url
            };
            try {
                downloaderAvailableBytes = downloader.totalAvailableBytes;
                if (downloaderAvailableBytes > 0){
                    downloadInput = downloader.getBytes(downloaderAvailableBytes);
                    if (downloadInput != null){
                        downloadInput.readBytes(this._bestEffortSeekBuffer, this._bestEffortSeekBuffer.length, downloaderAvailableBytes);
                    };
                    while ((((((this._bestEffortF4FHandler.inputBytesNeeded > 0)) && ((this._bestEffortF4FHandler.inputBytesNeeded <= this._bestEffortSeekBuffer.bytesAvailable)))) && ((this._bestEffortDownloadReply == null)))) {
                        this._bestEffortF4FHandler.processFileSegment(this._bestEffortSeekBuffer);
                    };
                    if (this._bestEffortDownloadReply == HTTPStreamingEvent.DOWNLOAD_CONTINUE){
                        downloader.clearSavedBytes();
                        this._bestEffortSeekBuffer.position = 0;
                        downloader.appendToSavedBytes(this._bestEffortSeekBuffer, this._bestEffortSeekBuffer.length);
                        this._bestEffortSeekBuffer.length = 0;
                    };
                };
            } finally {
                this._bestEffortNotifyBootstrapBoxInfo = null;
            };
        }
        private function onBestEffortF4FHandlerNotifyBootstrapBox(_arg1:HTTPStreamingFileHandlerEvent):void{
            var _local2:String = (this._bestEffortNotifyBootstrapBoxInfo.url as String);
            var _local3:HTTPStreamDownloader = (this._bestEffortNotifyBootstrapBoxInfo.downloader as HTTPStreamDownloader);
            if (this._bestEffortDownloadReply != null){
                this.bestEffortLog("Best effort found a bootstrap box in the downloaded fragment, but we already replied.");
                return;
            };
            var _local4:AdobeBootstrapBox = _arg1.bootstrapBox;
            var _local5:AdobeFragmentRunTable = this.getFragmentRunTable(_local4);
            if (_local5 == null){
                this.bestEffortLog("Best effort download contained an invalid bootstrap box.");
                this.skipBestEffortFetch(_local2, _local3);
                return;
            };
            if (_local5.fragmentDurationPairs.length != 1){
                this.bestEffortLog("Best effort download has an FRT with more than 1 entry.");
                this.skipBestEffortFetch(_local2, _local3);
                return;
            };
            var _local6:FragmentDurationPair = _local5.fragmentDurationPairs[0];
            if (_local6.duration == 0){
                this.bestEffortLog("Best effort download FDP was a discontinuity.");
                this.skipBestEffortFetch(_local2, _local3);
                return;
            };
            var _local7:Number = (_local6.durationAccrued + _local6.duration);
            if (this._bestEffortSeekTime < _local7){
                this.bestEffortLog("Best effort found the desired time within the downloaded fragment.");
                this.continueBestEffortFetch(_local2, _local3);
            } else {
                this.bestEffortLog("Best effort didn't find the desired time within the downloaded fragment.");
                this.skipBestEffortFetch(_local2, _local3);
                this._bestEffortState = BEST_EFFORT_STATE_SEEK_FORWARD;
                this._bestEffortFailedFetches = 0;
            };
        }
        private function onBestEffortDownloadComplete(_arg1:HTTPStreamingEvent):void{
            if ((((this._bestEffortDownloaderMonitor == null)) || (!((this._bestEffortDownloaderMonitor == (_arg1.target as IEventDispatcher)))))){
                return;
            };
            this.bestEffortLog("Best effort download complete");
            this.stopListeningToBestEffortDownload();
            var _local2:HTTPStreamingEvent = new HTTPStreamingEvent(_arg1.type, _arg1.bubbles, _arg1.cancelable, _arg1.fragmentDuration, _arg1.scriptDataObject, _arg1.scriptDataMode, _arg1.url, _arg1.bytesDownloaded, HTTPStreamingEventReason.BEST_EFFORT, _arg1.downloader);
            dispatchEvent(_local2);
            if (this._bestEffortDownloadReply != null){
                return;
            };
            switch (this._bestEffortState){
                case BEST_EFFORT_STATE_PLAY:
                case BEST_EFFORT_STATE_SEEK_FORWARD:
                    this.continueBestEffortFetch(_arg1.url, _arg1.downloader);
                    break;
                case BEST_EFFORT_STATE_SEEK_BACKWARD:
                    this.bufferAndParseDownloadedBestEffortBytes(_arg1.url, _arg1.downloader);
                    if (this._bestEffortDownloadReply == null){
                        this.skipBestEffortFetch(_arg1.url, _arg1.downloader);
                    };
                    break;
                default:
                    this.bestEffortLog((("Best effort download complete received while in unexpected state (" + this._bestEffortState) + ")"));
            };
        }
        private function onBestEffortDownloadError(_arg1:HTTPStreamingEvent):void{
            if ((((this._bestEffortDownloaderMonitor == null)) || (!((this._bestEffortDownloaderMonitor == (_arg1.target as IEventDispatcher)))))){
                return;
            };
            this.stopListeningToBestEffortDownload();
            if (this._bestEffortDownloadReply != null){
                this.bestEffortLog("Best effort download error after we already decided to skip or continue.");
                dispatchEvent(_arg1);
            } else {
                if (_arg1.reason == HTTPStreamingEventReason.TIMEOUT){
                    this.bestEffortLog("Best effort download timed out");
                    dispatchEvent(_arg1);
                } else {
                    this.bestEffortLog("Best effort download error.");
                    this._bestEffortFailedFetches++;
                    this.skipBestEffortFetch(_arg1.url, _arg1.downloader);
                };
            };
        }
        private function skipBestEffortFetch(_arg1:String, _arg2:HTTPStreamDownloader):void{
            if (this._bestEffortDownloadReply != null){
                this.bestEffortLog(("Best effort wanted to skip fragment, but we're already replied with " + this._bestEffortDownloadReply));
                return;
            };
            this.bestEffortLog("Best effort skipping fragment.");
            var _local3:HTTPStreamingEvent = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_SKIP, false, false, 0, null, FLVTagScriptDataMode.NORMAL, _arg1, 0, HTTPStreamingEventReason.BEST_EFFORT, _arg2);
            dispatchEvent(_local3);
            this._bestEffortDownloadReply = HTTPStreamingEvent.DOWNLOAD_SKIP;
            this._bestEffortNeedsToFireFragmentDuration = false;
        }
        private function continueBestEffortFetch(_arg1:String, _arg2:HTTPStreamDownloader):void{
            if (this._bestEffortDownloadReply != null){
                this.bestEffortLog(("Best effort wanted to continue, but we're already replied with " + this._bestEffortDownloadReply));
                return;
            };
            this.bestEffortLog("Best effort received a desirable fragment.");
            var _local3:HTTPStreamingEvent = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_CONTINUE, false, false, 0, null, FLVTagScriptDataMode.NORMAL, _arg1, 0, HTTPStreamingEventReason.BEST_EFFORT, _arg2);
            this._bestEffortLivenessRestartPoint = this._currentFAI.fragId;
            this._bestEffortLastGoodFragmentDownloadTime = new Date();
            dispatchEvent(_local3);
            this._bestEffortDownloadReply = HTTPStreamingEvent.DOWNLOAD_CONTINUE;
            this._bestEffortNeedsToFireFragmentDuration = true;
            this._bestEffortState = BEST_EFFORT_STATE_OFF;
        }
        private function errorBestEffortFetch(_arg1:String, _arg2:HTTPStreamDownloader):void{
            this.bestEffortLog("Best effort fetch error.");
            var _local3:HTTPStreamingEvent = new HTTPStreamingEvent(HTTPStreamingEvent.DOWNLOAD_ERROR, false, false, 0, null, FLVTagScriptDataMode.NORMAL, _arg1, 0, HTTPStreamingEventReason.BEST_EFFORT, _arg2);
            dispatchEvent(_local3);
            this._bestEffortDownloadReply = HTTPStreamingEvent.DOWNLOAD_ERROR;
            this._bestEffortNeedsToFireFragmentDuration = false;
        }
        private function notifyFragmentDurationForBestEffort(_arg1:AdobeBootstrapBox):void{
            if (((!(this._bestEffortNeedsToFireFragmentDuration)) || ((_arg1 == null)))){
                return;
            };
            this._bestEffortNeedsToFireFragmentDuration = false;
            var _local2:AdobeFragmentRunTable = this.getFragmentRunTable(_arg1);
            if (_local2 == null){
                return;
            };
            var _local3:Number = _local2.getFragmentDuration(this._currentFAI.fragId);
            if (_local3 == 0){
                return;
            };
            this.bestEffortLog("Best effort fetch firing the fragment duration.");
            dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.FRAGMENT_DURATION, false, false, (_local3 / _arg1.timeScale), null, null));
        }
        private function bestEffortLog(_arg1:String):void{
        }
        override public function get isBestEffortFetchEnabled():Boolean{
            return (this._bestEffortEnabled);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import org.osmf.media.*;
    import org.osmf.net.httpstreaming.*;

    public class HTTPStreamingF4FFactory extends HTTPStreamingFactory {

        override public function createFileHandler(_arg1:MediaResourceBase):HTTPStreamingFileHandlerBase{
            return (new HTTPStreamingF4FFileHandler());
        }
        override public function createIndexHandler(_arg1:MediaResourceBase, _arg2:HTTPStreamingFileHandlerBase):HTTPStreamingIndexHandlerBase{
            return (new HTTPStreamingF4FIndexHandler(_arg2));
        }
        override public function createIndexInfo(_arg1:MediaResourceBase):HTTPStreamingIndexInfoBase{
            return (HTTPStreamingUtils.createF4FIndexInfo((_arg1 as URLResource)));
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class FullBox extends Box {

        private var _version:uint;
        private var _flags:uint;

        public function get version():uint{
            return (this._version);
        }
        public function set version(_arg1:uint):void{
            this._version = _arg1;
        }
        public function get flags():uint{
            return (this._flags);
        }
        public function set flags(_arg1:uint):void{
            this._flags = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import __AS3__.vec.*;
    import org.osmf.net.httpstreaming.f4f.*;

    class AdobeFragmentRandomAccessBox extends FullBox {

        private var _timeScale:uint;
        private var _localRandomAccessEntries:Vector.<LocalRandomAccessEntry>;
        private var _globalRandomAccessEntries:Vector.<GlobalRandomAccessEntry>;

        public function get timeScale():uint{
            return (this._timeScale);
        }
        public function set timeScale(_arg1:uint):void{
            this._timeScale = _arg1;
        }
        public function get localRandomAccessEntries():Vector.<LocalRandomAccessEntry>{
            return (this._localRandomAccessEntries);
        }
        public function set localRandomAccessEntries(_arg1:Vector.<LocalRandomAccessEntry>):void{
            this._localRandomAccessEntries = _arg1;
        }
        public function get globalRandomAccessEntries():Vector.<GlobalRandomAccessEntry>{
            return (this._globalRandomAccessEntries);
        }
        public function set globalRandomAccessEntries(_arg1:Vector.<GlobalRandomAccessEntry>):void{
            this._globalRandomAccessEntries = _arg1;
        }
        public function findNearestKeyFrameOffset(_arg1:Number):LocalRandomAccessEntry{
            var _local3:LocalRandomAccessEntry;
            var _local2:int = (this._localRandomAccessEntries.length - 1);
            while (_local2 >= 0) {
                _local3 = this._localRandomAccessEntries[_local2];
                if (_local3.time <= _arg1){
                    return (_local3);
                };
                _local2--;
            };
            return (null);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import __AS3__.vec.*;
    import org.osmf.net.httpstreaming.*;
    import org.osmf.elements.f4mClasses.*;
    import org.osmf.net.httpstreaming.dvr.*;

    public class HTTPStreamingF4FIndexInfo extends HTTPStreamingIndexInfoBase {

        private var _serverBaseURL:String;
        private var _dvrInfo:DVRInfo;
        private var _befInfo:BestEffortFetchInfo;
        private var _streamInfos:Vector.<HTTPStreamingF4FStreamInfo>;

        public function HTTPStreamingF4FIndexInfo(_arg1:String=null, _arg2:Vector.<HTTPStreamingF4FStreamInfo>=null, _arg3:DVRInfo=null, _arg4:BestEffortFetchInfo=null){
            this._serverBaseURL = _arg1;
            this._streamInfos = _arg2;
            this._dvrInfo = _arg3;
            this._befInfo = _arg4;
        }
        public function get serverBaseURL():String{
            return (this._serverBaseURL);
        }
        public function get streamInfos():Vector.<HTTPStreamingF4FStreamInfo>{
            return (this._streamInfos);
        }
        public function get dvrInfo():DVRInfo{
            return (this._dvrInfo);
        }
        public function get bestEffortFetchInfo():BestEffortFetchInfo{
            return (this._befInfo);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import org.osmf.events.*;
    import org.osmf.net.httpstreaming.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class HTTPStreamingF4FFileHandler extends HTTPStreamingFileHandlerBase {

        private var _afra:AdobeFragmentRandomAccessBox;
        private var _ba:ByteArray;
        private var _boxInfoPending:Boolean;
        private var _bytesNeeded:uint;
        private var _bytesReadSinceAfraStart:uint;
        private var _countingReadBytes:Boolean;
        private var _mdatBytesPending:uint;
        private var _nextBox:BoxInfo;
        private var _parser:BoxParser;
        private var _seekToTime:Number;
        private var _mdatBytesOffset:Number;
        private var _processRequestWasSeek:Boolean = false;

        public function HTTPStreamingF4FFileHandler(){
            this._parser = new BoxParser();
            super();
        }
        override public function beginProcessFile(_arg1:Boolean, _arg2:Number):void{
            this._processRequestWasSeek = _arg1;
            this._seekToTime = ((_arg1) ? _arg2 : 0);
            this._bytesNeeded = (((F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH) + F4FConstants.FIELD_LARGE_SIZE_LENGTH) + F4FConstants.FIELD_EXTENDED_TYPE_LENGTH);
            this._bytesReadSinceAfraStart = 0;
            this._countingReadBytes = false;
            this._boxInfoPending = true;
            this._nextBox = null;
        }
        override public function get inputBytesNeeded():Number{
            return (this._bytesNeeded);
        }
        override public function processFileSegment(_arg1:IDataInput):ByteArray{
            var _local4:uint;
            var _local5:AdobeBootstrapBox;
            if (_arg1.bytesAvailable < this._bytesNeeded){
                return (null);
            };
            var _local2:ByteArray;
            var _local3:Number = (F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH);
            if (this._boxInfoPending){
                this._ba = new ByteArray();
                _arg1.readBytes(this._ba, 0, _local3);
                if (this._countingReadBytes){
                    this._bytesReadSinceAfraStart = (this._bytesReadSinceAfraStart + _local3);
                };
                this._parser.init(this._ba);
                this._nextBox = this._parser.getNextBoxInfo();
                if (this._nextBox.size == F4FConstants.FLAG_USE_LARGE_SIZE){
                    _local3 = (_local3 + F4FConstants.FIELD_LARGE_SIZE_LENGTH);
                    this._ba.position = 0;
                    _arg1.readBytes(this._ba, 0, F4FConstants.FIELD_LARGE_SIZE_LENGTH);
                    if (this._countingReadBytes){
                        this._bytesReadSinceAfraStart = (this._bytesReadSinceAfraStart + F4FConstants.FIELD_LARGE_SIZE_LENGTH);
                    };
                    this._nextBox.size = this._parser.readLongUIntToNumber();
                };
                this._boxInfoPending = false;
                if (this._nextBox.type == F4FConstants.BOX_TYPE_MDAT){
                    this._bytesNeeded = 0;
                    this._mdatBytesPending = (this._nextBox.size - _local3);
                } else {
                    this._bytesNeeded = (this._nextBox.size - _local3);
                    this._mdatBytesPending = 0;
                    if (this._nextBox.type == F4FConstants.BOX_TYPE_AFRA){
                        this._bytesReadSinceAfraStart = _local3;
                        this._countingReadBytes = true;
                    };
                };
            } else {
                if (this._bytesNeeded > 0){
                    _local4 = this._ba.position;
                    _arg1.readBytes(this._ba, this._ba.length, (this._nextBox.size - _local3));
                    if (this._countingReadBytes){
                        this._bytesReadSinceAfraStart = (this._bytesReadSinceAfraStart + (this._nextBox.size - _local3));
                    };
                    this._ba.position = _local4;
                    if (this._nextBox.type == F4FConstants.BOX_TYPE_ABST){
                        _local5 = this._parser.readAdobeBootstrapBox(this._nextBox);
                        if (_local5 != null){
                            dispatchEvent(new HTTPStreamingFileHandlerEvent(HTTPStreamingFileHandlerEvent.NOTIFY_BOOTSTRAP_BOX, false, false, 0, null, null, _local5));
                        };
                    } else {
                        if (this._nextBox.type == F4FConstants.BOX_TYPE_AFRA){
                            this._afra = this._parser.readFragmentRandomAccessBox(this._nextBox);
                            this.processSeekToTime();
                        } else {
                            if (this._nextBox.type == F4FConstants.BOX_TYPE_MOOF){
                            };
                        };
                    };
                    this._bytesNeeded = (((F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH) + F4FConstants.FIELD_LARGE_SIZE_LENGTH) + F4FConstants.FIELD_EXTENDED_TYPE_LENGTH);
                    this._boxInfoPending = true;
                    this._nextBox = null;
                } else {
                    _local2 = this.getMDATBytes(_arg1, false);
                };
            };
            return (_local2);
        }
        override public function endProcessFile(_arg1:IDataInput):ByteArray{
            if (this._bytesNeeded > 0){
                dispatchEvent(new HTTPStreamingEvent(HTTPStreamingEvent.FILE_ERROR, false, false, 0, null, null));
            };
            return (this.getMDATBytes(_arg1, true));
        }
        override public function flushFileSegment(_arg1:IDataInput):ByteArray{
            return (null);
        }
        private function getMDATBytes(_arg1:IDataInput, _arg2:Boolean):ByteArray{
            var _local3:ByteArray;
            var _local4:uint;
            if (_arg1 == null){
                return (null);
            };
            this.skipSeekBytes(_arg1);
            if (this._mdatBytesPending > 0){
                _local4 = (((this._mdatBytesPending < _arg1.bytesAvailable)) ? this._mdatBytesPending : _arg1.bytesAvailable);
                if (((!(_arg2)) && ((_local4 > OSMFSettings.hdsBytesReadingLimit)))){
                    _local4 = OSMFSettings.hdsBytesReadingLimit;
                };
                _local3 = new ByteArray();
                this._mdatBytesPending = (this._mdatBytesPending - _local4);
                _arg1.readBytes(_local3, 0, _local4);
            };
            return (_local3);
        }
        private function skipSeekBytes(_arg1:IDataInput):void{
            var _local2:uint;
            var _local3:ByteArray;
            if (this._bytesReadSinceAfraStart < this._mdatBytesOffset){
                _local2 = (this._mdatBytesOffset - this._bytesReadSinceAfraStart);
                if (_arg1.bytesAvailable < _local2){
                    _local2 = _arg1.bytesAvailable;
                };
                _local3 = new ByteArray();
                _arg1.readBytes(_local3, 0, _local2);
                this._bytesReadSinceAfraStart = (this._bytesReadSinceAfraStart + _local2);
                this._mdatBytesPending = (this._mdatBytesPending - _local2);
            };
        }
        private function processSeekToTime():void{
            var _local1:Number = 0;
            var _local2:LocalRandomAccessEntry;
            if (this._seekToTime <= 0){
                this._mdatBytesOffset = 0;
            } else {
                _local2 = this.getMDATBytesOffset(this._seekToTime);
                if (_local2 != null){
                    this._mdatBytesOffset = _local2.offset;
                    _local1 = _local2.time;
                } else {
                    this._mdatBytesOffset = 0;
                };
            };
        }
        private function getMDATBytesOffset(_arg1:Number):LocalRandomAccessEntry{
            return (((isNaN(_arg1)) ? null : this._afra.findNearestKeyFrameOffset((_arg1 * this._afra.timeScale))));
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class FragmentAccessInformation {

        public var fragId:uint;
        public var fragmentEndTime:Number;
        public var fragDuration:uint;

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class Box {

        private var _size:Number;
        private var _type:String;
        private var _boxLength:uint;

        public function get size():Number{
            return (this._size);
        }
        public function set size(_arg1:Number):void{
            this._size = _arg1;
        }
        public function get type():String{
            return (this._type);
        }
        public function set type(_arg1:String):void{
            this._type = _arg1;
        }
        public function get boxLength():uint{
            return (this._boxLength);
        }
        public function set boxLength(_arg1:uint):void{
            this._boxLength = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class SegmentFragmentPair {

        private var _firstSegment:uint;
        private var _fragmentsPerSegment:uint;
        private var _fragmentsAccrued:uint;

        public function SegmentFragmentPair(_arg1:uint, _arg2:uint){
            this._firstSegment = _arg1;
            this._fragmentsPerSegment = _arg2;
        }
        public function get firstSegment():uint{
            return (this._firstSegment);
        }
        public function get fragmentsPerSegment():uint{
            return (this._fragmentsPerSegment);
        }
        public function set fragmentsAccrued(_arg1:uint):void{
            this._fragmentsAccrued = _arg1;
        }
        public function get fragmentsAccrued():uint{
            return (this._fragmentsAccrued);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import __AS3__.vec.*;
    import org.osmf.net.httpstreaming.f4f.*;

    class AdobeSegmentRunTable extends FullBox {

        private var _qualitySegmentURLModifiers:Vector.<String>;
        private var _segmentFragmentPairs:Vector.<SegmentFragmentPair>;

        public function AdobeSegmentRunTable(){
            this._segmentFragmentPairs = new Vector.<SegmentFragmentPair>();
        }
        public function get qualitySegmentURLModifiers():Vector.<String>{
            return (this._qualitySegmentURLModifiers);
        }
        public function set qualitySegmentURLModifiers(_arg1:Vector.<String>):void{
            this._qualitySegmentURLModifiers = _arg1;
        }
        public function get segmentFragmentPairs():Vector.<SegmentFragmentPair>{
            return (this._segmentFragmentPairs);
        }
        public function addSegmentFragmentPair(_arg1:SegmentFragmentPair):void{
            var _local2:SegmentFragmentPair = (((this._segmentFragmentPairs.length <= 0)) ? null : this._segmentFragmentPairs[(this._segmentFragmentPairs.length - 1)]);
            var _local3:uint;
            if (_local2 != null){
                _local3 = (_local2.fragmentsAccrued + ((_arg1.firstSegment - _local2.firstSegment) * _local2.fragmentsPerSegment));
            };
            _arg1.fragmentsAccrued = _local3;
            this._segmentFragmentPairs.push(_arg1);
        }
        public function findSegmentIdByFragmentId(_arg1:uint):uint{
            var _local2:SegmentFragmentPair;
            if (_arg1 < 1){
                return (0);
            };
            var _local3:uint = 1;
            while (_local3 < this._segmentFragmentPairs.length) {
                _local2 = this._segmentFragmentPairs[_local3];
                if (_local2.fragmentsAccrued >= _arg1){
                    return (this.calculateSegmentId(this._segmentFragmentPairs[(_local3 - 1)], _arg1));
                };
                _local3++;
            };
            return (this.calculateSegmentId(this._segmentFragmentPairs[(this._segmentFragmentPairs.length - 1)], _arg1));
        }
        public function get totalFragments():uint{
            return ((this._segmentFragmentPairs[(this._segmentFragmentPairs.length - 1)].fragmentsPerSegment + this._segmentFragmentPairs[(this._segmentFragmentPairs.length - 1)].fragmentsAccrued));
        }
        private function calculateSegmentId(_arg1:SegmentFragmentPair, _arg2:uint):uint{
            return ((_arg1.firstSegment + int((((_arg2 - _arg1.fragmentsAccrued) - 1) / _arg1.fragmentsPerSegment))));
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class F4FConstants {

        static const BOX_TYPE_UUID:String = "uuid";
        static const BOX_TYPE_ABST:String = "abst";
        static const BOX_TYPE_ASRT:String = "asrt";
        static const BOX_TYPE_AFRT:String = "afrt";
        static const BOX_TYPE_AFRA:String = "afra";
        static const BOX_TYPE_MDAT:String = "mdat";
        static const BOX_TYPE_MOOF:String = "moof";
        static const EXTENDED_TYPE:String = "uuid";
        static const FIELD_SIZE_LENGTH:uint = 4;
        static const FIELD_TYPE_LENGTH:uint = 4;
        static const FIELD_LARGE_SIZE_LENGTH:uint = 8;
        static const FIELD_EXTENDED_TYPE_LENGTH:uint = 16;
        static const FLAG_USE_LARGE_SIZE:uint = 1;

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class GlobalRandomAccessEntry {

        private var _time:Number;
        private var _segment:uint;
        private var _fragment:uint;
        private var _afraOffset:Number;
        private var _offsetFromAfra:Number;

        public function get time():Number{
            return (this._time);
        }
        public function set time(_arg1:Number):void{
            this._time = _arg1;
        }
        public function get segment():uint{
            return (this._segment);
        }
        public function set segment(_arg1:uint):void{
            this._segment = _arg1;
        }
        public function get fragment():uint{
            return (this._fragment);
        }
        public function set fragment(_arg1:uint):void{
            this._fragment = _arg1;
        }
        public function get afraOffset():Number{
            return (this._afraOffset);
        }
        public function set afraOffset(_arg1:Number):void{
            this._afraOffset = _arg1;
        }
        public function get offsetFromAfra():Number{
            return (this._offsetFromAfra);
        }
        public function set offsetFromAfra(_arg1:Number):void{
            this._offsetFromAfra = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import __AS3__.vec.*;
    import org.osmf.net.httpstreaming.f4f.*;

    class AdobeFragmentRunTable extends FullBox {

        private var _timeScale:uint;
        private var _qualitySegmentURLModifiers:Vector.<String>;
        private var _fragmentDurationPairs:Vector.<FragmentDurationPair>;

        public function AdobeFragmentRunTable(){
            this._fragmentDurationPairs = new Vector.<FragmentDurationPair>();
        }
        public function get timeScale():uint{
            return (this._timeScale);
        }
        public function set timeScale(_arg1:uint):void{
            this._timeScale = _arg1;
        }
        public function get qualitySegmentURLModifiers():Vector.<String>{
            return (this._qualitySegmentURLModifiers);
        }
        public function set qualitySegmentURLModifiers(_arg1:Vector.<String>):void{
            this._qualitySegmentURLModifiers = _arg1;
        }
        public function get fragmentDurationPairs():Vector.<FragmentDurationPair>{
            return (this._fragmentDurationPairs);
        }
        public function addFragmentDurationPair(_arg1:FragmentDurationPair):void{
            this._fragmentDurationPairs.push(_arg1);
        }
        public function findFragmentIdByTime(_arg1:Number, _arg2:Number, _arg3:Boolean=false):FragmentAccessInformation{
            if (this._fragmentDurationPairs.length <= 0){
                return (null);
            };
            var _local4:FragmentDurationPair;
            var _local5:uint = 1;
            while (_local5 < this._fragmentDurationPairs.length) {
                _local4 = this._fragmentDurationPairs[_local5];
                if (_local4.durationAccrued >= _arg1){
                    return (this.validateFragment(this.calculateFragmentId(this._fragmentDurationPairs[(_local5 - 1)], _arg1), _arg2, _arg3));
                };
                _local5++;
            };
            return (this.validateFragment(this.calculateFragmentId(this._fragmentDurationPairs[(this._fragmentDurationPairs.length - 1)], _arg1), _arg2, _arg3));
        }
        public function validateFragment(_arg1:uint, _arg2:Number, _arg3:Boolean=false):FragmentAccessInformation{
            var _local7:FragmentDurationPair;
            var _local8:FragmentDurationPair;
            var _local9:Number;
            var _local10:Number;
            var _local11:Number;
            var _local12:FragmentDurationPair;
            var _local4:uint = (this._fragmentDurationPairs.length - 1);
            var _local5:FragmentAccessInformation;
            var _local6:uint;
            while (_local6 < _local4) {
                _local7 = this._fragmentDurationPairs[_local6];
                _local8 = this._fragmentDurationPairs[(_local6 + 1)];
                if ((((_local7.firstFragment <= _arg1)) && ((_arg1 < _local8.firstFragment)))){
                    if (_local7.duration <= 0){
                        _local5 = this.getNextValidFragment((_local6 + 1), _arg2);
                    } else {
                        _local5 = new FragmentAccessInformation();
                        _local5.fragId = _arg1;
                        _local5.fragDuration = _local7.duration;
                        _local5.fragmentEndTime = (_local7.durationAccrued + (_local7.duration * ((_arg1 - _local7.firstFragment) + 1)));
                    };
                    break;
                };
                if ((((_local7.firstFragment <= _arg1)) && (this.endOfStreamEntry(_local8)))){
                    if (_local7.duration > 0){
                        _local9 = (_arg2 - _local7.durationAccrued);
                        _local10 = (((_arg1 - _local7.firstFragment) + 1) * _local7.duration);
                        _local11 = ((_arg1 - _local7.firstFragment) * _local7.duration);
                        if (_local9 > _local11){
                            if (((!(_arg3)) || ((((_local11 + _local7.duration) + _local7.durationAccrued) <= _arg2)))){
                                _local5 = new FragmentAccessInformation();
                                _local5.fragId = _arg1;
                                _local5.fragDuration = _local7.duration;
                                if (_local9 >= _local10){
                                    _local5.fragmentEndTime = (_local7.durationAccrued + _local10);
                                } else {
                                    _local5.fragmentEndTime = (_local7.durationAccrued + _local9);
                                };
                                break;
                            };
                        };
                    };
                };
                _local6++;
            };
            if (_local5 == null){
                _local12 = this._fragmentDurationPairs[_local4];
                if ((((_local12.duration > 0)) && ((_arg1 >= _local12.firstFragment)))){
                    _local9 = (_arg2 - _local12.durationAccrued);
                    _local10 = (((_arg1 - _local12.firstFragment) + 1) * _local12.duration);
                    _local11 = ((_arg1 - _local12.firstFragment) * _local12.duration);
                    if (_local9 > _local11){
                        if (((!(_arg3)) || ((((_local11 + _local12.duration) + _local12.durationAccrued) <= _arg2)))){
                            _local5 = new FragmentAccessInformation();
                            _local5.fragId = _arg1;
                            _local5.fragDuration = _local12.duration;
                            if (_local9 >= _local10){
                                _local5.fragmentEndTime = (_local12.durationAccrued + _local10);
                            } else {
                                _local5.fragmentEndTime = (_local12.durationAccrued + _local9);
                            };
                        };
                    };
                };
            };
            return (_local5);
        }
        private function getNextValidFragment(_arg1:uint, _arg2:Number):FragmentAccessInformation{
            var _local5:FragmentDurationPair;
            var _local3:FragmentAccessInformation;
            var _local4:uint = _arg1;
            while (_local4 < this._fragmentDurationPairs.length) {
                _local5 = this._fragmentDurationPairs[_local4];
                if (_local5.duration > 0){
                    _local3 = new FragmentAccessInformation();
                    _local3.fragId = _local5.firstFragment;
                    _local3.fragDuration = _local5.duration;
                    _local3.fragmentEndTime = (_local5.durationAccrued + _local5.duration);
                    break;
                };
                _local4++;
            };
            return (_local3);
        }
        private function endOfStreamEntry(_arg1:FragmentDurationPair):Boolean{
            return ((((_arg1.duration == 0)) && ((_arg1.discontinuityIndicator == 0))));
        }
        public function fragmentsLeft(_arg1:uint, _arg2:Number):uint{
            if ((((this._fragmentDurationPairs == null)) || ((this._fragmentDurationPairs.length == 0)))){
                return (0);
            };
            var _local3:FragmentDurationPair = (this._fragmentDurationPairs[(this.fragmentDurationPairs.length - 1)] as FragmentDurationPair);
            var _local4:uint = (((((_arg2 - _local3.durationAccrued) / _local3.duration) + _local3.firstFragment) - _arg1) - 1);
            return (_local4);
        }
        public function tableComplete():Boolean{
            if ((((this._fragmentDurationPairs == null)) || ((this._fragmentDurationPairs.length <= 0)))){
                return (false);
            };
            var _local1:FragmentDurationPair = (this._fragmentDurationPairs[(this.fragmentDurationPairs.length - 1)] as FragmentDurationPair);
            return ((((_local1.duration == 0)) && ((_local1.discontinuityIndicator == 0))));
        }
        public function adjustEndEntryDurationAccrued(_arg1:Number):void{
            var _local2:FragmentDurationPair = this._fragmentDurationPairs[(this._fragmentDurationPairs.length - 1)];
            if (_local2.duration == 0){
                _local2.durationAccrued = _arg1;
            };
        }
        public function getFragmentDuration(_arg1:uint):Number{
            var _local2:FragmentDurationPair;
            var _local3:uint;
            while ((((_local3 < this._fragmentDurationPairs.length)) && ((this._fragmentDurationPairs[_local3].firstFragment <= _arg1)))) {
                _local3++;
            };
            if (_local3){
                return (this._fragmentDurationPairs[(_local3 - 1)].duration);
            };
            return (0);
        }
        private function findNextValidFragmentDurationPair(_arg1:uint):FragmentDurationPair{
            var _local3:FragmentDurationPair;
            var _local2:uint = _arg1;
            while (_local2 < this._fragmentDurationPairs.length) {
                _local3 = this._fragmentDurationPairs[_local2];
                if (_local3.duration > 0){
                    return (_local3);
                };
                _local2++;
            };
            return (null);
        }
        private function findPrevValidFragmentDurationPair(_arg1:uint):FragmentDurationPair{
            var _local3:FragmentDurationPair;
            var _local2:uint = _arg1;
            if (_local2 > this._fragmentDurationPairs.length){
                _local2 = this._fragmentDurationPairs.length;
            };
            while (_local2 > 0) {
                _local3 = this._fragmentDurationPairs[(_local2 - 1)];
                if (_local3.duration > 0){
                    return (_local3);
                };
                _local2--;
            };
            return (null);
        }
        private function calculateFragmentId(_arg1:FragmentDurationPair, _arg2:Number):uint{
            if (_arg1.duration <= 0){
                return (_arg1.firstFragment);
            };
            var _local3:Number = (_arg2 - _arg1.durationAccrued);
            return ((_arg1.firstFragment + uint((_local3 / _arg1.duration))));
        }
        public function get firstFragmentId():uint{
            var _local1:FragmentDurationPair = this.findNextValidFragmentDurationPair(0);
            if (_local1 == null){
                return (0);
            };
            return (_local1.firstFragment);
        }
        public function isFragmentInGap(_arg1:uint):Boolean{
            var inGap:* = false;
            var fragmentId:* = _arg1;
            inGap = false;
            this.forEachGap(function (_arg1:Object):Boolean{
                var _local2:FragmentDurationPair = (_arg1.fdp as FragmentDurationPair);
                var _local3:FragmentDurationPair = (_arg1.nextFdp as FragmentDurationPair);
                var _local4:Number = _local2.firstFragment;
                var _local5:Number = _local3.firstFragment;
                if ((((_local4 <= fragmentId)) && ((fragmentId < _local5)))){
                    inGap = true;
                };
                return (!(inGap));
            });
            return (inGap);
        }
        public function isTimeInGap(_arg1:Number, _arg2:uint):Boolean{
            var inGap:* = false;
            var time:* = _arg1;
            var fragmentInterval:* = _arg2;
            inGap = false;
            this.forEachGap(function (_arg1:Object):Boolean{
                var _local2:FragmentDurationPair = (_arg1.fdp as FragmentDurationPair);
                var _local3:FragmentDurationPair = (_arg1.prevFdp as FragmentDurationPair);
                var _local4:FragmentDurationPair = (_arg1.nextFdp as FragmentDurationPair);
                var _local5:Number = (_local3.durationAccrued + (_local3.duration * (_local2.firstFragment - _local3.firstFragment)));
                var _local6:Number = _local4.durationAccrued;
                var _local7:Number = ((Math.max(_local2.firstFragment, 1) - 1) * fragmentInterval);
                var _local8:Number = ((Math.max(_local4.firstFragment, (_local2.firstFragment + 1), 1) - 1) * fragmentInterval);
                var _local9:Number = Math.min(_local5, _local7);
                var _local10:Number = Math.max(_local6, _local8);
                if ((((_local9 <= time)) && ((time < _local10)))){
                    inGap = true;
                };
                return (!(inGap));
            });
            return (inGap);
        }
        public function countGapFragments():uint{
            var count:* = 0;
            count = 0;
            this.forEachGap(function (_arg1:Object):void{
                var _local2:FragmentDurationPair = (_arg1.fdp as FragmentDurationPair);
                var _local3:FragmentDurationPair = (_arg1.nextFdp as FragmentDurationPair);
                var _local4:Number = _local2.firstFragment;
                var _local5:Number = uint(Math.max(_local3.firstFragment, _local4));
                count = (count + (_local5 - _local4));
            });
            return (count);
        }
        private function forEachGap(_arg1:Function):void{
            var _local3:FragmentDurationPair;
            var _local4:FragmentDurationPair;
            var _local5:FragmentDurationPair;
            var _local6:Boolean;
            if (this._fragmentDurationPairs.length <= 0){
                return;
            };
            var _local2:uint;
            while (_local2 < this._fragmentDurationPairs.length) {
                _local3 = this._fragmentDurationPairs[_local2];
                if (((!((_local3.duration == 0))) || (!((_local3.discontinuityIndicator == 2))))){
                } else {
                    _local4 = this.findPrevValidFragmentDurationPair(_local2);
                    if ((((_local4 == null)) || ((_local4.firstFragment > _local3.firstFragment)))){
                    } else {
                        _local5 = this.findNextValidFragmentDurationPair((_local2 + 1));
                        if ((((_local5 == null)) || ((_local3.firstFragment > _local5.firstFragment)))){
                        } else {
                            _local6 = _arg1({
                                fdp:_local3,
                                prevFdp:_local4,
                                nextFdp:_local5
                            });
                            if (!_local6){
                                return;
                            };
                        };
                    };
                };
                _local2++;
            };
        }
        public function getFragmentWithIdGreq(_arg1:uint):FragmentAccessInformation{
            var fragmentId:* = _arg1;
            var desiredFdp:* = null;
            var desiredFragmentId:* = 0;
            this.forEachInterval(function (_arg1:Object):Boolean{
                var _local2:FragmentDurationPair = (_arg1.fdp as FragmentDurationPair);
                var _local3:Boolean = (_arg1.isLast as Boolean);
                var _local4:uint = (_arg1.startFragmentId as uint);
                var _local5:uint = (_arg1.endFragmentId as uint);
                if (fragmentId < _local4){
                    desiredFdp = _local2;
                    desiredFragmentId = _local4;
                    return (false);
                };
                if (_local3){
                    desiredFdp = _local2;
                    desiredFragmentId = fragmentId;
                    return (false);
                };
                if (fragmentId < _local5){
                    desiredFdp = _local2;
                    desiredFragmentId = fragmentId;
                    return (false);
                };
                return (true);
            });
            if (desiredFdp == null){
                return (null);
            };
            if (desiredFragmentId < desiredFdp.firstFragment){
                desiredFragmentId = desiredFdp.firstFragment;
            };
            var fai:* = new FragmentAccessInformation();
            fai.fragId = desiredFragmentId;
            fai.fragDuration = desiredFdp.duration;
            fai.fragmentEndTime = (desiredFdp.durationAccrued + (((desiredFragmentId - desiredFdp.firstFragment) + 1) * desiredFdp.duration));
            return (fai);
        }
        public function getFragmentWithTimeGreq(_arg1:Number):FragmentAccessInformation{
            var fragmentTime:* = _arg1;
            var desiredFdp:* = null;
            var desiredFragmentStartTime:* = 0;
            this.forEachInterval(function (_arg1:Object):Boolean{
                var _local2:FragmentDurationPair = (_arg1.fdp as FragmentDurationPair);
                var _local3:Boolean = (_arg1.isLast as Boolean);
                var _local4:Number = (_arg1.startTime as Number);
                var _local5:Number = (_arg1.endTime as Number);
                if (fragmentTime < _local4){
                    desiredFdp = _local2;
                    desiredFragmentStartTime = _local4;
                    return (false);
                };
                if (_local3){
                    desiredFdp = _local2;
                    desiredFragmentStartTime = fragmentTime;
                    return (false);
                };
                if (fragmentTime < _local5){
                    desiredFdp = _local2;
                    desiredFragmentStartTime = fragmentTime;
                    return (false);
                };
                return (true);
            });
            if (desiredFdp == null){
                return (null);
            };
            var desiredFragmentId:* = this.calculateFragmentId(desiredFdp, desiredFragmentStartTime);
            var fai:* = new FragmentAccessInformation();
            fai.fragId = desiredFragmentId;
            fai.fragDuration = desiredFdp.duration;
            fai.fragmentEndTime = (desiredFdp.durationAccrued + (((desiredFragmentId - desiredFdp.firstFragment) + 1) * desiredFdp.duration));
            return (fai);
        }
        private function forEachInterval(_arg1:Function):void{
            var _local3:FragmentDurationPair;
            var _local4:uint;
            var _local5:Number;
            var _local6:Boolean;
            var _local7:uint;
            var _local8:uint;
            var _local9:Number;
            var _local10:Boolean;
            var _local2:uint;
            for (;_local2 < this._fragmentDurationPairs.length;_local2++) {
                _local3 = this._fragmentDurationPairs[_local2];
                if (_local3.duration == 0){
                } else {
                    _local4 = _local3.firstFragment;
                    _local5 = _local3.durationAccrued;
                    _local6 = true;
                    _local7 = (_local2 + 1);
                    while (_local7 < this._fragmentDurationPairs.length) {
                        if (((((((!((this._fragmentDurationPairs[_local7].duration == 0))) || ((this._fragmentDurationPairs[_local7].discontinuityIndicator == 1)))) || ((this._fragmentDurationPairs[_local7].discontinuityIndicator == 2)))) || ((this._fragmentDurationPairs[_local7].discontinuityIndicator == 3)))){
                            _local6 = false;
                            break;
                        };
                        _local7++;
                    };
                    if (_local6){
                        _local8 = 0;
                        _local9 = Number.NaN;
                    } else {
                        _local8 = this._fragmentDurationPairs[_local7].firstFragment;
                        if (_local4 > _local8){
                            continue;
                        };
                        _local9 = (_local5 + ((_local8 - _local4) * _local3.duration));
                    };
                    _local10 = _arg1({
                        fdp:_local3,
                        isLast:_local6,
                        startFragmentId:_local4,
                        endFragmentId:_local8,
                        startTime:_local5,
                        endTime:_local9
                    });
                    if (((!(_local10)) || (_local6))){
                        return;
                    };
                };
            };
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class BoxInfo {

        private var _size:Number;
        private var _type:String;

        public function BoxInfo(_arg1:Number, _arg2:String){
            this._size = _arg1;
            this._type = _arg2;
        }
        public function get size():Number{
            return (this._size);
        }
        public function set size(_arg1:Number):void{
            this._size = _arg1;
        }
        public function get type():String{
            return (this._type);
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {

    class LocalRandomAccessEntry {

        private var _time:Number;
        private var _offset:Number;

        public function get time():Number{
            return (this._time);
        }
        public function set time(_arg1:Number):void{
            this._time = _arg1;
        }
        public function get offset():Number{
            return (this._offset);
        }
        public function set offset(_arg1:Number):void{
            this._offset = _arg1;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming.f4f {
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.utils.*;
    import org.osmf.net.httpstreaming.f4f.*;
    import flash.errors.*;

    class BoxParser extends EventDispatcher {

        private static const FULL_BOX_FIELD_FLAGS_LENGTH:uint = 3;
        private static const AFRA_MASK_LONG_ID:uint = 128;
        private static const AFRA_MASK_LONG_OFFSET:uint = 64;
        private static const AFRA_MASK_GLOBAL_ENTRIES:uint = 32;

        private var _ba:ByteArray;

        public function BoxParser(){
            this._ba = null;
        }
        public function init(_arg1:ByteArray):void{
            this._ba = _arg1;
            this._ba.position = 0;
        }
        public function getNextBoxInfo():BoxInfo{
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < (F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH))))){
                return (null);
            };
            var _local1:Number = this._ba.readUnsignedInt();
            var _local2:String = this._ba.readUTFBytes(F4FConstants.FIELD_TYPE_LENGTH);
            return (new BoxInfo(_local1, _local2));
        }
        public function getBoxes():Vector.<Box>{
            var _local3:AdobeBootstrapBox;
            var _local4:AdobeFragmentRandomAccessBox;
            var _local5:MediaDataBox;
            var _local1:Vector.<Box> = new Vector.<Box>();
            var _local2:BoxInfo = this.getNextBoxInfo();
            while (_local2 != null) {
                if (_local2.type == F4FConstants.BOX_TYPE_ABST){
                    _local3 = new AdobeBootstrapBox();
                    this.parseAdobeBootstrapBox(_local2, _local3);
                    _local1.push(_local3);
                } else {
                    if (_local2.type == F4FConstants.BOX_TYPE_AFRA){
                        _local4 = new AdobeFragmentRandomAccessBox();
                        this.parseAdobeFragmentRandomAccessBox(_local2, _local4);
                        _local1.push(_local4);
                    } else {
                        if (_local2.type == F4FConstants.BOX_TYPE_MDAT){
                            _local5 = new MediaDataBox();
                            this.parseMediaDataBox(_local2, _local5);
                            _local1.push(_local5);
                        } else {
                            this._ba.position = ((this._ba.position + _local2.size) - (F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH));
                        };
                    };
                };
                _local2 = this.getNextBoxInfo();
                if (((!((_local2 == null))) && ((_local2.size <= 0)))){
                    break;
                };
            };
            return (_local1);
        }
        public function readFragmentRandomAccessBox(_arg1:BoxInfo):AdobeFragmentRandomAccessBox{
            var _local2:AdobeFragmentRandomAccessBox = new AdobeFragmentRandomAccessBox();
            this.parseAdobeFragmentRandomAccessBox(_arg1, _local2);
            return (_local2);
        }
        public function readAdobeBootstrapBox(_arg1:BoxInfo):AdobeBootstrapBox{
            var _local2:AdobeBootstrapBox = new AdobeBootstrapBox();
            this.parseAdobeBootstrapBox(_arg1, _local2);
            return (_local2);
        }
        function readLongUIntToNumber():Number{
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < 8)))){
                throw (new IllegalOperationError("not enough length for readLongUIntToNumer"));
            };
            var _local1:Number = this._ba.readUnsignedInt();
            _local1 = (_local1 * 4294967296);
            _local1 = (_local1 + this._ba.readUnsignedInt());
            return (_local1);
        }
        private function readUnsignedInt():uint{
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < 4)))){
                throw (new IllegalOperationError("not enough length for readUnsignedInt"));
            };
            return (this._ba.readUnsignedInt());
        }
        private function readBytes(_arg1:ByteArray, _arg2:uint=0, _arg3:uint=0):void{
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < _arg3)))){
                throw (new IllegalOperationError(("not enough length for readBytes: " + _arg3)));
            };
            return (this._ba.readBytes(_arg1, _arg2, _arg3));
        }
        private function readUnsignedByte():uint{
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < 1)))){
                throw (new IllegalOperationError("not enough length for readUnsingedByte"));
            };
            return (this._ba.readUnsignedByte());
        }
        private function readBytesToUint(_arg1:uint):uint{
            var _local4:uint;
            if ((((this._ba == null)) || ((this._ba.bytesAvailable < _arg1)))){
                throw (new IllegalOperationError("not enough length for readUnsingedByte"));
            };
            if (_arg1 > 4){
                throw (new IllegalOperationError("number of bytes to read must be equal or less than 4"));
            };
            var _local2:uint;
            var _local3:uint;
            while (_local3 < _arg1) {
                _local2 = (_local2 << 8);
                _local4 = this._ba.readUnsignedByte();
                _local2 = (_local2 + _local4);
                _local3++;
            };
            return (_local2);
        }
        private function readString():String{
            var _local3:uint;
            var _local1:uint = this._ba.position;
            while (this._ba.position < this._ba.length) {
                _local3 = this._ba.readByte();
                if (_local3 == 0){
                    break;
                };
            };
            var _local2:uint = (this._ba.position - _local1);
            this._ba.position = _local1;
            return (this._ba.readUTFBytes(_local2));
        }
        private function parseBox(_arg1:BoxInfo, _arg2:Box):void{
            var _local5:ByteArray;
            var _local3:Number = _arg1.size;
            var _local4:uint = (F4FConstants.FIELD_SIZE_LENGTH + F4FConstants.FIELD_TYPE_LENGTH);
            if (_arg1.size == F4FConstants.FLAG_USE_LARGE_SIZE){
                _local3 = this.readLongUIntToNumber();
                _local4 = (_local4 + F4FConstants.FIELD_LARGE_SIZE_LENGTH);
            };
            if (_arg1.type == F4FConstants.EXTENDED_TYPE){
                _local5 = new ByteArray();
                this.readBytes(_local5, 0, F4FConstants.FIELD_EXTENDED_TYPE_LENGTH);
                _local4 = (_local4 + F4FConstants.FIELD_EXTENDED_TYPE_LENGTH);
            };
            _arg2.size = _local3;
            _arg2.type = _arg1.type;
            _arg2.boxLength = _local4;
        }
        private function parseFullBox(_arg1:BoxInfo, _arg2:FullBox):void{
            this.parseBox(_arg1, _arg2);
            _arg2.version = this.readUnsignedByte();
            _arg2.flags = this.readBytesToUint(FULL_BOX_FIELD_FLAGS_LENGTH);
        }
        private function parseAdobeBootstrapBox(_arg1:BoxInfo, _arg2:AdobeBootstrapBox):void{
            var _local13:AdobeSegmentRunTable;
            var _local14:AdobeFragmentRunTable;
            this.parseFullBox(_arg1, _arg2);
            _arg2.bootstrapVersion = this.readUnsignedInt();
            var _local3:uint = this.readUnsignedByte();
            _arg2.profile = (_local3 >> 6);
            _arg2.live = ((_local3 & 32) == 32);
            _arg2.update = ((_local3 & 1) == 1);
            _arg2.timeScale = this.readUnsignedInt();
            _arg2.currentMediaTime = this.readLongUIntToNumber();
            _arg2.smpteTimeCodeOffset = this.readLongUIntToNumber();
            _arg2.movieIdentifier = this.readString();
            var _local4:uint = this.readUnsignedByte();
            var _local5:Vector.<String> = new Vector.<String>();
            var _local6:int;
            while (_local6 < _local4) {
                _local5.push(this.readString());
                _local6++;
            };
            _arg2.serverBaseURLs = _local5;
            var _local7:uint = this.readUnsignedByte();
            var _local8:Vector.<String> = new Vector.<String>();
            _local6 = 0;
            while (_local6 < _local7) {
                _local8.push(this.readString());
                _local6++;
            };
            _arg2.qualitySegmentURLModifiers = _local8;
            _arg2.drmData = this.readString();
            _arg2.metadata = this.readString();
            var _local9:uint = this.readUnsignedByte();
            var _local10:Vector.<AdobeSegmentRunTable> = new Vector.<AdobeSegmentRunTable>();
            _local6 = 0;
            while (_local6 < _local9) {
                _arg1 = this.getNextBoxInfo();
                if (_arg1.type == F4FConstants.BOX_TYPE_ASRT){
                    _local13 = new AdobeSegmentRunTable();
                    this.parseAdobeSegmentRunTable(_arg1, _local13);
                    _local10.push(_local13);
                } else {
                    throw (new IllegalOperationError(("Unexpected data structure: " + _arg1.type)));
                };
                _local6++;
            };
            _arg2.segmentRunTables = _local10;
            var _local11:uint = this.readUnsignedByte();
            var _local12:Vector.<AdobeFragmentRunTable> = new Vector.<AdobeFragmentRunTable>();
            _local6 = 0;
            while (_local6 < _local11) {
                _arg1 = this.getNextBoxInfo();
                if (_arg1.type == F4FConstants.BOX_TYPE_AFRT){
                    _local14 = new AdobeFragmentRunTable();
                    this.parseAdobeFragmentRunTable(_arg1, _local14);
                    _local12.push(_local14);
                } else {
                    throw (new IllegalOperationError(("Unexpected data structure: " + _arg1.type)));
                };
                _local6++;
            };
            _arg2.fragmentRunTables = _local12;
        }
        private function parseAdobeSegmentRunTable(_arg1:BoxInfo, _arg2:AdobeSegmentRunTable):void{
            this.parseFullBox(_arg1, _arg2);
            var _local3:uint = this.readUnsignedByte();
            var _local4:Vector.<String> = new Vector.<String>();
            var _local5:uint;
            while (_local5 < _local3) {
                _local4.push(this.readString());
                _local5++;
            };
            _arg2.qualitySegmentURLModifiers = _local4;
            var _local6:uint = this.readUnsignedInt();
            _local5 = 0;
            while (_local5 < _local6) {
                _arg2.addSegmentFragmentPair(new SegmentFragmentPair(this.readUnsignedInt(), this.readUnsignedInt()));
                _local5++;
            };
        }
        private function parseAdobeFragmentRunTable(_arg1:BoxInfo, _arg2:AdobeFragmentRunTable):void{
            var _local7:FragmentDurationPair;
            this.parseFullBox(_arg1, _arg2);
            _arg2.timeScale = this.readUnsignedInt();
            var _local3:uint = this.readUnsignedByte();
            var _local4:Vector.<String> = new Vector.<String>();
            var _local5:uint;
            while (_local5 < _local3) {
                _local4.push(this.readString());
                _local5++;
            };
            _arg2.qualitySegmentURLModifiers = _local4;
            var _local6:uint = this.readUnsignedInt();
            _local5 = 0;
            while (_local5 < _local6) {
                _local7 = new FragmentDurationPair();
                this.parseFragmentDurationPair(_local7);
                _arg2.addFragmentDurationPair(_local7);
                _local5++;
            };
        }
        private function parseFragmentDurationPair(_arg1:FragmentDurationPair):void{
            _arg1.firstFragment = this.readUnsignedInt();
            _arg1.durationAccrued = this.readLongUIntToNumber();
            _arg1.duration = this.readUnsignedInt();
            if (_arg1.duration == 0){
                _arg1.discontinuityIndicator = this.readUnsignedByte();
            };
        }
        private function parseAdobeFragmentRandomAccessBox(_arg1:BoxInfo, _arg2:AdobeFragmentRandomAccessBox):void{
            var _local11:LocalRandomAccessEntry;
            var _local12:GlobalRandomAccessEntry;
            this.parseFullBox(_arg1, _arg2);
            var _local3:uint = this.readBytesToUint(1);
            var _local4 = ((_local3 & AFRA_MASK_LONG_ID) > 0);
            var _local5 = ((_local3 & AFRA_MASK_LONG_OFFSET) > 0);
            var _local6 = ((_local3 & AFRA_MASK_GLOBAL_ENTRIES) > 0);
            _arg2.timeScale = this.readUnsignedInt();
            var _local7:uint = this.readUnsignedInt();
            var _local8:Vector.<LocalRandomAccessEntry> = new Vector.<LocalRandomAccessEntry>();
            var _local9:uint;
            while (_local9 < _local7) {
                _local11 = new LocalRandomAccessEntry();
                this.parseLocalRandomAccessEntry(_local11, _local5);
                _local8.push(_local11);
                _local9++;
            };
            _arg2.localRandomAccessEntries = _local8;
            var _local10:Vector.<GlobalRandomAccessEntry> = new Vector.<GlobalRandomAccessEntry>();
            if (_local6){
                _local7 = this.readUnsignedInt();
                _local9 = 0;
                while (_local9 < _local7) {
                    _local12 = new GlobalRandomAccessEntry();
                    this.parseGlobalRandomAccessEntry(_local12, _local4, _local5);
                    _local10.push(_local12);
                    _local9++;
                };
            };
            _arg2.globalRandomAccessEntries = _local10;
        }
        private function parseLocalRandomAccessEntry(_arg1:LocalRandomAccessEntry, _arg2:Boolean):void{
            _arg1.time = this.readLongUIntToNumber();
            if (_arg2){
                _arg1.offset = this.readLongUIntToNumber();
            } else {
                _arg1.offset = this.readUnsignedInt();
            };
        }
        private function parseGlobalRandomAccessEntry(_arg1:GlobalRandomAccessEntry, _arg2:Boolean, _arg3:Boolean):void{
            _arg1.time = this.readLongUIntToNumber();
            if (_arg2){
                _arg1.segment = this.readUnsignedInt();
                _arg1.fragment = this.readUnsignedInt();
            } else {
                _arg1.segment = this.readBytesToUint(2);
                _arg1.fragment = this.readBytesToUint(2);
            };
            if (_arg3){
                _arg1.afraOffset = this.readLongUIntToNumber();
                _arg1.offsetFromAfra = this.readLongUIntToNumber();
            } else {
                _arg1.afraOffset = this.readUnsignedInt();
                _arg1.offsetFromAfra = this.readUnsignedInt();
            };
        }
        private function parseMediaDataBox(_arg1:BoxInfo, _arg2:MediaDataBox):void{
            this.parseBox(_arg1, _arg2);
            var _local3:ByteArray = new ByteArray();
            this.readBytes(_local3, 0, (_arg2.size - _arg2.boxLength));
            _arg2.data = _local3;
        }

    }
}//package org.osmf.net.httpstreaming.f4f 
﻿package org.osmf.net.httpstreaming {

    public class HTTPStreamRequestKind {

        public static const RETRY:String = "retry";
        public static const DOWNLOAD:String = "download";
        public static const BEST_EFFORT_DOWNLOAD:String = "bestEffortDownload";
        public static const LIVE_STALL:String = "liveStall";
        public static const DONE:String = "done";

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming.flv {

    public class FLVTagScriptDataMode {

        public static const NORMAL:String = "normal";
        public static const FIRST:String = "first";
        public static const IMMEDIATE:String = "immediate";

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.utils.*;

    public class FLVHeader {

        public static const MIN_FILE_HEADER_BYTE_COUNT:int = 9;

        private var _hasVideoTags:Boolean = true;
        private var _hasAudioTags:Boolean = true;
        private var offset:uint;

        public function FLVHeader(_arg1:IDataInput=null){
            if (_arg1 != null){
                this.readHeader(_arg1);
                this.readRest(_arg1);
            };
        }
        public function get hasAudioTags():Boolean{
            return (this._hasAudioTags);
        }
        public function set hasAudioTags(_arg1:Boolean):void{
            this._hasAudioTags = _arg1;
        }
        public function get hasVideoTags():Boolean{
            return (this._hasVideoTags);
        }
        public function set hasVideoTags(_arg1:Boolean):void{
            this._hasVideoTags = _arg1;
        }
        public function write(_arg1:IDataOutput):void{
            _arg1.writeByte(70);
            _arg1.writeByte(76);
            _arg1.writeByte(86);
            _arg1.writeByte(1);
            var _local2:uint;
            if (this._hasAudioTags){
                _local2 = (_local2 | 4);
            };
            if (this._hasVideoTags){
                _local2 = (_local2 | 1);
            };
            _arg1.writeByte(_local2);
            var _local3:uint = MIN_FILE_HEADER_BYTE_COUNT;
            _arg1.writeUnsignedInt(_local3);
            var _local4:uint;
            _arg1.writeUnsignedInt(_local4);
        }
        function readHeader(_arg1:IDataInput):void{
            if (_arg1.bytesAvailable < MIN_FILE_HEADER_BYTE_COUNT){
                throw (new Error("FLVHeader() input too short"));
            };
            if (_arg1.readByte() != 70){
                throw (new Error("FLVHeader readHeader() Signature[0] not 'F'"));
            };
            if (_arg1.readByte() != 76){
                throw (new Error("FLVHeader readHeader() Signature[1] not 'L'"));
            };
            if (_arg1.readByte() != 86){
                throw (new Error("FLVHeader readHeader() Signature[2] not 'V'"));
            };
            if (_arg1.readByte() != 1){
                throw (new Error("FLVHeader readHeader() Version not 0x01"));
            };
            var _local2:int = _arg1.readByte();
            this._hasAudioTags = (((_local2 & 4)) ? true : false);
            this._hasVideoTags = (((_local2 & 1)) ? true : false);
            this.offset = _arg1.readUnsignedInt();
            if (this.offset < MIN_FILE_HEADER_BYTE_COUNT){
                throw (new Error("FLVHeader() offset smaller than minimum"));
            };
        }
        function readRest(_arg1:IDataInput):void{
            var _local2:ByteArray;
            if (this.offset > MIN_FILE_HEADER_BYTE_COUNT){
                if ((this.offset - MIN_FILE_HEADER_BYTE_COUNT) < (_arg1.bytesAvailable - FLVTag.PREV_TAG_BYTE_COUNT)){
                    throw (new Error("FLVHeader() input too short for nonstandard offset"));
                };
                _local2 = new ByteArray();
                _arg1.readBytes(_local2, 0, (this.offset - MIN_FILE_HEADER_BYTE_COUNT));
            };
            if (_arg1.bytesAvailable < FLVTag.PREV_TAG_BYTE_COUNT){
                throw (new Error("FLVHeader() input too short for previousTagSize0"));
            };
            _arg1.readUnsignedInt();
        }
        function get restBytesNeeded():int{
            return ((FLVTag.PREV_TAG_BYTE_COUNT + (this.offset - MIN_FILE_HEADER_BYTE_COUNT)));
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {

    class FLVParserState {

        static const FILE_HEADER:String = "fileHeader";
        static const FILE_HEADER_REST:String = "fileHeaderRest";
        static const TYPE:String = "type";
        static const HEADER:String = "header";
        static const DATA:String = "data";
        static const PREV_TAG:String = "prevTag";

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.net.*;

    public class FLVTagScriptDataObject extends FLVTag {

        public function FLVTagScriptDataObject(_arg1:int=18){
            super(_arg1);
        }
        public function get objects():Array{
            var _local1:Array = new Array();
            bytes.position = TAG_HEADER_BYTE_COUNT;
            while (bytes.bytesAvailable) {
                _local1.push(bytes.readObject());
            };
            return (_local1);
        }
        public function set objects(_arg1:Array):void{
            var _local2:Object;
            bytes.objectEncoding = ObjectEncoding.AMF0;
            bytes.length = TAG_HEADER_BYTE_COUNT;
            bytes.position = TAG_HEADER_BYTE_COUNT;
            for each (_local2 in _arg1) {
                bytes.writeObject(_local2);
            };
            dataSize = (bytes.length - TAG_HEADER_BYTE_COUNT);
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.utils.*;

    public class FLVTag {

        public static const TAG_TYPE_AUDIO:int = 8;
        public static const TAG_TYPE_VIDEO:int = 9;
        public static const TAG_TYPE_SCRIPTDATAOBJECT:int = 18;
        public static const TAG_FLAG_ENCRYPTED:int = 32;
        public static const TAG_TYPE_ENCRYPTED_AUDIO:int = 40;
        public static const TAG_TYPE_ENCRYPTED_VIDEO:int = 41;
        public static const TAG_TYPE_ENCRYPTED_SCRIPTDATAOBJECT:int = 50;
        public static const TAG_HEADER_BYTE_COUNT:int = 11;
        public static const PREV_TAG_BYTE_COUNT:int = 4;

        protected var bytes:ByteArray = null;

        public function FLVTag(_arg1:int){
            this.bytes = new ByteArray();
            this.bytes.length = TAG_HEADER_BYTE_COUNT;
            this.bytes[0] = _arg1;
        }
        public function read(_arg1:IDataInput):void{
            this.readType(_arg1);
            this.readRemainingHeader(_arg1);
            this.readData(_arg1);
            this.readPrevTag(_arg1);
        }
        public function readType(_arg1:IDataInput):void{
            if (_arg1.bytesAvailable < 1){
                throw (new Error("FLVTag.readType() input too short"));
            };
            _arg1.readBytes(this.bytes, 0, 1);
        }
        public function readRemaining(_arg1:IDataInput):void{
            this.readRemainingHeader(_arg1);
            this.readData(_arg1);
            this.readPrevTag(_arg1);
        }
        public function readRemainingHeader(_arg1:IDataInput):void{
            if (_arg1.bytesAvailable < 10){
                throw (new Error("FLVTag.readHeader() input too short"));
            };
            _arg1.readBytes(this.bytes, 1, (TAG_HEADER_BYTE_COUNT - 1));
        }
        public function readData(_arg1:IDataInput):void{
            if (this.dataSize > 0){
                if (_arg1.bytesAvailable < this.dataSize){
                    throw (new Error("FLVTag().readData input shorter than dataSize"));
                };
                _arg1.readBytes(this.bytes, TAG_HEADER_BYTE_COUNT, this.dataSize);
            };
        }
        public function readPrevTag(_arg1:IDataInput):void{
            if (_arg1.bytesAvailable < 4){
                throw (new Error("FLVTag.readPrevTag() input too short"));
            };
            _arg1.readUnsignedInt();
        }
        public function write(_arg1:IDataOutput):void{
            _arg1.writeBytes(this.bytes, 0, (TAG_HEADER_BYTE_COUNT + this.dataSize));
            _arg1.writeUnsignedInt((TAG_HEADER_BYTE_COUNT + this.dataSize));
        }
        public function get tagType():uint{
            return (this.bytes[0]);
        }
        public function set tagType(_arg1:uint):void{
            this.bytes[0] = _arg1;
        }
        public function get isEncrpted():Boolean{
            return ((((this.bytes[0] & TAG_FLAG_ENCRYPTED)) ? true : false));
        }
        public function get dataSize():uint{
            return ((((this.bytes[1] << 16) | (this.bytes[2] << 8)) | this.bytes[3]));
        }
        public function set dataSize(_arg1:uint):void{
            this.bytes[1] = ((_arg1 >> 16) & 0xFF);
            this.bytes[2] = ((_arg1 >> 8) & 0xFF);
            this.bytes[3] = (_arg1 & 0xFF);
            this.bytes.length = (TAG_HEADER_BYTE_COUNT + _arg1);
        }
        public function get timestamp():uint{
            return (((((this.bytes[7] << 24) | (this.bytes[4] << 16)) | (this.bytes[5] << 8)) | this.bytes[6]));
        }
        public function set timestamp(_arg1:uint):void{
            this.bytes[7] = ((_arg1 >> 24) & 0xFF);
            this.bytes[4] = ((_arg1 >> 16) & 0xFF);
            this.bytes[5] = ((_arg1 >> 8) & 0xFF);
            this.bytes[6] = (_arg1 & 0xFF);
        }
        public function get data():ByteArray{
            var _local1:ByteArray = new ByteArray();
            _local1.writeBytes(this.bytes, TAG_HEADER_BYTE_COUNT, this.dataSize);
            return (_local1);
        }
        public function set data(_arg1:ByteArray):void{
            this.bytes.length = (TAG_HEADER_BYTE_COUNT + _arg1.length);
            this.bytes.position = TAG_HEADER_BYTE_COUNT;
            this.bytes.writeBytes(_arg1, 0, _arg1.length);
            this.dataSize = _arg1.length;
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.utils.*;

    public class FLVTagVideo extends FLVTag {

        public static const FRAME_TYPE_KEYFRAME:int = 1;
        public static const FRAME_TYPE_INTER:int = 2;
        public static const FRAME_TYPE_DISPOSABLE_INTER:int = 3;
        public static const FRAME_TYPE_GENERATED_KEYFRAME:int = 4;
        public static const FRAME_TYPE_INFO:int = 5;
        public static const CODEC_ID_JPEG:int = 1;
        public static const CODEC_ID_SORENSON:int = 2;
        public static const CODEC_ID_SCREEN:int = 3;
        public static const CODEC_ID_VP6:int = 4;
        public static const CODEC_ID_VP6_ALPHA:int = 5;
        public static const CODEC_ID_SCREEN_V2:int = 6;
        public static const CODEC_ID_AVC:int = 7;
        public static const AVC_PACKET_TYPE_SEQUENCE_HEADER:int = 0;
        public static const AVC_PACKET_TYPE_NALU:int = 1;
        public static const AVC_PACKET_TYPE_END_OF_SEQUENCE:int = 2;
        public static const INFO_PACKET_SEEK_START:int = 0;
        public static const INFO_PACKET_SEEK_END:int = 1;

        public function FLVTagVideo(_arg1:int=9){
            super(_arg1);
        }
        public function get frameType():int{
            return (((bytes[(TAG_HEADER_BYTE_COUNT + 0)] >> 4) & 15));
        }
        public function set frameType(_arg1:int):void{
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 15);
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | ((_arg1 & 15) << 4));
        }
        public function get codecID():int{
            return ((bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 15));
        }
        public function set codecID(_arg1:int):void{
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 240);
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | (_arg1 & 15));
        }
        public function get infoPacketValue():int{
            if (this.frameType != FRAME_TYPE_INFO){
                throw (new Error("get infoPacketValue() not permitted unless frameType is FRAME_TYPE_INFO"));
            };
            return (bytes[(TAG_HEADER_BYTE_COUNT + 1)]);
        }
        public function set infoPacketValue(_arg1:int):void{
            if (this.frameType != FRAME_TYPE_INFO){
                throw (new Error("get infoPacketValue() not permitted unless frameType is FRAME_TYPE_INFO"));
            };
            bytes[(TAG_HEADER_BYTE_COUNT + 1)] = _arg1;
            bytes.length = (TAG_HEADER_BYTE_COUNT + 2);
            dataSize = 2;
        }
        public function get avcPacketType():int{
            if (this.codecID != CODEC_ID_AVC){
                throw (new Error("get avcPacketType() not permitted unless codecID is CODEC_ID_AVC"));
            };
            return (bytes[(TAG_HEADER_BYTE_COUNT + 1)]);
        }
        public function set avcPacketType(_arg1:int):void{
            if (this.codecID != CODEC_ID_AVC){
                throw (new Error("set avcPacketType() not permitted unless codecID is CODEC_ID_AVC"));
            };
            bytes[(TAG_HEADER_BYTE_COUNT + 1)] = _arg1;
            if (this.avcPacketType != AVC_PACKET_TYPE_NALU){
                bytes[(TAG_HEADER_BYTE_COUNT + 2)] = 0;
                bytes[(TAG_HEADER_BYTE_COUNT + 3)] = 0;
                bytes[(TAG_HEADER_BYTE_COUNT + 4)] = 0;
                bytes.length = (TAG_HEADER_BYTE_COUNT + 5);
                dataSize = 5;
            };
        }
        public function get avcCompositionTimeOffset():int{
            if (((!((this.codecID == CODEC_ID_AVC))) || (!((this.avcPacketType == AVC_PACKET_TYPE_NALU))))){
                throw (new Error("get avcCompositionTimeOffset() not permitted unless codecID is CODEC_ID_AVC and avcPacketType is AVC NALU"));
            };
            var _local1 = (bytes[(TAG_HEADER_BYTE_COUNT + 2)] << 16);
            _local1 = (_local1 | (bytes[(TAG_HEADER_BYTE_COUNT + 3)] << 8));
            _local1 = (_local1 | bytes[(TAG_HEADER_BYTE_COUNT + 4)]);
            if ((_local1 & 0x800000)){
                _local1 = (_local1 | 0xFF000000);
            };
            return (_local1);
        }
        public function set avcCompositionTimeOffset(_arg1:int):void{
            if (((!((this.codecID == CODEC_ID_AVC))) || (!((this.avcPacketType == AVC_PACKET_TYPE_NALU))))){
                throw (new Error("set avcCompositionTimeOffset() not permitted unless codecID is CODEC_ID_AVC and avcPacketType is AVC NALU"));
            };
            bytes[(TAG_HEADER_BYTE_COUNT + 2)] = ((_arg1 >> 16) & 0xFF);
            bytes[(TAG_HEADER_BYTE_COUNT + 3)] = ((_arg1 >> 8) & 0xFF);
            bytes[(TAG_HEADER_BYTE_COUNT + 4)] = (_arg1 & 0xFF);
        }
        override public function get data():ByteArray{
            var _local1:ByteArray = new ByteArray();
            if (this.codecID == CODEC_ID_AVC){
                _local1.writeBytes(bytes, (TAG_HEADER_BYTE_COUNT + 5), (dataSize - 5));
            } else {
                _local1.writeBytes(bytes, (TAG_HEADER_BYTE_COUNT + 1), (dataSize - 1));
            };
            return (_local1);
        }
        override public function set data(_arg1:ByteArray):void{
            if (this.codecID == CODEC_ID_AVC){
                bytes.length = ((TAG_HEADER_BYTE_COUNT + _arg1.length) + 5);
                bytes.position = (TAG_HEADER_BYTE_COUNT + 5);
                bytes.writeBytes(_arg1, 0, _arg1.length);
                dataSize = (_arg1.length + 5);
            } else {
                bytes.length = ((TAG_HEADER_BYTE_COUNT + _arg1.length) + 1);
                bytes.position = (TAG_HEADER_BYTE_COUNT + 1);
                bytes.writeBytes(_arg1, 0, _arg1.length);
                dataSize = (_arg1.length + 1);
            };
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.utils.*;

    public class FLVTagAudio extends FLVTag {

        public static const SOUND_FORMAT_LINEAR:int = 0;
        public static const SOUND_FORMAT_ADPCM:int = 1;
        public static const SOUND_FORMAT_MP3:int = 2;
        public static const SOUND_FORMAT_LINEAR_LE:int = 3;
        public static const SOUND_FORMAT_NELLYMOSER_16K:int = 4;
        public static const SOUND_FORMAT_NELLYMOSER_8K:int = 5;
        public static const SOUND_FORMAT_NELLYMOSER:int = 6;
        public static const SOUND_FORMAT_G711A:int = 7;
        public static const SOUND_FORMAT_G711U:int = 8;
        public static const SOUND_FORMAT_AAC:int = 10;
        public static const SOUND_FORMAT_SPEEX:int = 11;
        public static const SOUND_FORMAT_MP3_8K:int = 14;
        public static const SOUND_FORMAT_DEVICE_SPECIFIC:int = 15;
        public static const SOUND_RATE_5K:Number = 5512.5;
        public static const SOUND_RATE_11K:Number = 11025;
        public static const SOUND_RATE_22K:Number = 22050;
        public static const SOUND_RATE_44K:Number = 44100;
        public static const SOUND_SIZE_8BITS:int = 8;
        public static const SOUND_SIZE_16BITS:int = 16;
        public static const SOUND_CHANNELS_MONO:int = 1;
        public static const SOUND_CHANNELS_STEREO:int = 2;

        public function FLVTagAudio(_arg1:int=8){
            super(_arg1);
        }
        public function get soundFormatByte():int{
            return (bytes[(TAG_HEADER_BYTE_COUNT + 0)]);
        }
        public function set soundFormatByte(_arg1:int):void{
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = _arg1;
        }
        public function get soundFormat():int{
            return (((bytes[(TAG_HEADER_BYTE_COUNT + 0)] >> 4) & 15));
        }
        public function set soundFormat(_arg1:int):void{
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 15);
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | ((_arg1 << 4) & 240));
            if (_arg1 == SOUND_FORMAT_AAC){
                this.soundRate = SOUND_RATE_44K;
                this.soundChannels = SOUND_CHANNELS_STEREO;
                this.isAACSequenceHeader = false;
            };
        }
        public function get soundRate():Number{
            switch (((bytes[(TAG_HEADER_BYTE_COUNT + 0)] >> 2) & 3)){
                case 0:
                    return (SOUND_RATE_5K);
                case 1:
                    return (SOUND_RATE_11K);
                case 2:
                    return (SOUND_RATE_22K);
                case 3:
                    return (SOUND_RATE_44K);
            };
            throw (new Error("get soundRate() a two-bit number wasn't 0, 1, 2, or 3. impossible."));
        }
        public function set soundRate(_arg1:Number):void{
            var _local2:int;
            switch (_arg1){
                case SOUND_RATE_5K:
                    _local2 = 0;
                    break;
                case SOUND_RATE_11K:
                    _local2 = 1;
                    break;
                case SOUND_RATE_22K:
                    _local2 = 2;
                    break;
                case SOUND_RATE_44K:
                    _local2 = 3;
                    break;
                default:
                    throw (new Error("set soundRate valid values 5512.5, 11025, 22050, 44100"));
            };
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 243);
            bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | (_local2 << 2));
        }
        public function get soundSize():int{
            if (((bytes[(TAG_HEADER_BYTE_COUNT + 0)] >> 1) & 1)){
                return (SOUND_SIZE_16BITS);
            };
            return (SOUND_SIZE_8BITS);
        }
        public function set soundSize(_arg1:int):void{
            switch (_arg1){
                case SOUND_SIZE_8BITS:
                    bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 253);
                    break;
                case SOUND_SIZE_16BITS:
                    bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | 2);
                    break;
                default:
                    throw (new Error("set soundSize valid values 8, 16"));
            };
        }
        public function get soundChannels():int{
            if ((bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 1)){
                return (SOUND_CHANNELS_STEREO);
            };
            return (SOUND_CHANNELS_MONO);
        }
        public function set soundChannels(_arg1:int):void{
            switch (_arg1){
                case SOUND_CHANNELS_MONO:
                    bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] & 254);
                    break;
                case SOUND_CHANNELS_STEREO:
                    bytes[(TAG_HEADER_BYTE_COUNT + 0)] = (bytes[(TAG_HEADER_BYTE_COUNT + 0)] | 1);
                    break;
                default:
                    throw (new Error("set soundChannels valid values 1, 2"));
            };
        }
        public function get isAACSequenceHeader():Boolean{
            if (this.soundFormat != SOUND_FORMAT_AAC){
                throw (new Error("get isAACSequenceHeader not valid if soundFormat != SOUND_FORMAT_AAC"));
            };
            if (bytes[(TAG_HEADER_BYTE_COUNT + 1)] == 0){
                return (true);
            };
            return (false);
        }
        public function set isAACSequenceHeader(_arg1:Boolean):void{
            if (this.soundFormat != SOUND_FORMAT_AAC){
                throw (new Error("set isAACSequenceHeader not valid if soundFormat != SOUND_FORMAT_AAC"));
            };
            if (_arg1){
                bytes[(TAG_HEADER_BYTE_COUNT + 1)] = 0;
            } else {
                bytes[(TAG_HEADER_BYTE_COUNT + 1)] = 1;
            };
        }
        public function get isCodecConfiguration():Boolean{
            switch (this.soundFormat){
                case FLVTagAudio.SOUND_FORMAT_AAC:
                    if (this.isAACSequenceHeader){
                        return (true);
                    };
                    break;
            };
            return (false);
        }
        override public function get data():ByteArray{
            var _local1:ByteArray = new ByteArray();
            if (this.soundFormat == SOUND_FORMAT_AAC){
                _local1.writeBytes(bytes, (TAG_HEADER_BYTE_COUNT + 2), (dataSize - 2));
            } else {
                _local1.writeBytes(bytes, (TAG_HEADER_BYTE_COUNT + 1), (dataSize - 1));
            };
            return (_local1);
        }
        override public function set data(_arg1:ByteArray):void{
            if (this.soundFormat == SOUND_FORMAT_AAC){
                bytes.length = ((TAG_HEADER_BYTE_COUNT + _arg1.length) + 2);
                bytes.position = (TAG_HEADER_BYTE_COUNT + 2);
                bytes.writeBytes(_arg1, 0, _arg1.length);
                dataSize = (_arg1.length + 2);
            } else {
                bytes.length = ((TAG_HEADER_BYTE_COUNT + _arg1.length) + 1);
                bytes.position = (TAG_HEADER_BYTE_COUNT + 1);
                bytes.writeBytes(_arg1, 0, _arg1.length);
                dataSize = (_arg1.length + 1);
            };
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming.flv {
    import flash.utils.*;

    public class FLVParser {

        private var state:String;
        private var savedBytes:ByteArray;
        private var currentTag:FLVTag = null;
        private var flvHeader:FLVHeader;

        public function FLVParser(_arg1:Boolean){
            this.savedBytes = new ByteArray();
            if (_arg1){
                this.state = FLVParserState.FILE_HEADER;
            } else {
                this.state = FLVParserState.TYPE;
            };
        }
        public function flush(_arg1:IDataOutput):void{
            _arg1.writeBytes(this.savedBytes);
        }
        public function parse(_arg1:IDataInput, _arg2:Boolean, _arg3:Function):void{
            var _local5:IDataInput;
            var _local7:int;
            var _local4:Boolean;
            var _local6:Date = new Date();
            while (_local4) {
                switch (this.state){
                    case FLVParserState.FILE_HEADER:
                        _local5 = this.byteSource(_arg1, FLVHeader.MIN_FILE_HEADER_BYTE_COUNT);
                        if (_local5 != null){
                            this.flvHeader = new FLVHeader();
                            this.flvHeader.readHeader(_local5);
                            this.state = FLVParserState.FILE_HEADER_REST;
                        } else {
                            _local4 = false;
                        };
                        break;
                    case FLVParserState.FILE_HEADER_REST:
                        _local5 = this.byteSource(_arg1, this.flvHeader.restBytesNeeded);
                        if (_local5 != null){
                            this.flvHeader.readRest(_local5);
                            this.state = FLVParserState.TYPE;
                        } else {
                            _local4 = false;
                        };
                        break;
                    case FLVParserState.TYPE:
                        _local5 = this.byteSource(_arg1, 1);
                        if (_local5 != null){
                            _local7 = _local5.readByte();
                            switch (_local7){
                                case FLVTag.TAG_TYPE_AUDIO:
                                case FLVTag.TAG_TYPE_ENCRYPTED_AUDIO:
                                    this.currentTag = new FLVTagAudio(_local7);
                                    break;
                                case FLVTag.TAG_TYPE_VIDEO:
                                case FLVTag.TAG_TYPE_ENCRYPTED_VIDEO:
                                    this.currentTag = new FLVTagVideo(_local7);
                                    break;
                                case FLVTag.TAG_TYPE_SCRIPTDATAOBJECT:
                                case FLVTag.TAG_TYPE_ENCRYPTED_SCRIPTDATAOBJECT:
                                    this.currentTag = new FLVTagScriptDataObject(_local7);
                                    break;
                                default:
                                    this.currentTag = new FLVTag(_local7);
                            };
                            this.state = FLVParserState.HEADER;
                        } else {
                            _local4 = false;
                        };
                        break;
                    case FLVParserState.HEADER:
                        _local5 = this.byteSource(_arg1, (FLVTag.TAG_HEADER_BYTE_COUNT - 1));
                        if (_local5 != null){
                            this.currentTag.readRemainingHeader(_local5);
                            if (this.currentTag.dataSize){
                                this.state = FLVParserState.DATA;
                            } else {
                                this.state = FLVParserState.PREV_TAG;
                            };
                        } else {
                            _local4 = false;
                        };
                        break;
                    case FLVParserState.DATA:
                        _local5 = this.byteSource(_arg1, this.currentTag.dataSize);
                        if (_local5 != null){
                            this.currentTag.readData(_local5);
                            this.state = FLVParserState.PREV_TAG;
                        } else {
                            _local4 = false;
                        };
                        break;
                    case FLVParserState.PREV_TAG:
                        _local5 = this.byteSource(_arg1, FLVTag.PREV_TAG_BYTE_COUNT);
                        if (_local5 != null){
                            this.currentTag.readPrevTag(_local5);
                            this.state = FLVParserState.TYPE;
                            _local4 = _arg3(this.currentTag);
                        } else {
                            _local4 = false;
                        };
                        break;
                    default:
                        throw (new Error("FLVParser state machine in unknown state"));
                };
            };
            if (_arg2){
                _arg1.readBytes(this.savedBytes, this.savedBytes.length);
            };
        }
        private function byteSource(_arg1:IDataInput, _arg2:int):IDataInput{
            var _local3:int;
            if ((this.savedBytes.bytesAvailable + _arg1.bytesAvailable) < _arg2){
                return (null);
            };
            if (this.savedBytes.bytesAvailable){
                _local3 = (_arg2 - this.savedBytes.bytesAvailable);
                if (_local3 > 0){
                    _arg1.readBytes(this.savedBytes, this.savedBytes.length, _local3);
                };
                return (this.savedBytes);
            };
            this.savedBytes.length = 0;
            return (_arg1);
        }

    }
}//package org.osmf.net.httpstreaming.flv 
﻿package org.osmf.net.httpstreaming {
    import org.osmf.media.*;
    import flash.errors.*;

    public class HTTPStreamingFactory {

        public function createFileHandler(_arg1:MediaResourceBase):HTTPStreamingFileHandlerBase{
            throw (new IllegalOperationError("The createFileHandler() method must be overriden by derived class."));
        }
        public function createIndexHandler(_arg1:MediaResourceBase, _arg2:HTTPStreamingFileHandlerBase):HTTPStreamingIndexHandlerBase{
            throw (new IllegalOperationError("The createIndexHandler() method must be overriden by derived class."));
        }
        public function createIndexInfo(_arg1:MediaResourceBase):HTTPStreamingIndexInfoBase{
            throw (new IllegalOperationError("The createIndexInfo() methods must be overriden by derived class."));
        }

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.httpstreaming {
    import flash.utils.*;

    public interface IHTTPStreamSource {

        function get isReady():Boolean;
        function get endOfStream():Boolean;
        function get isLiveStalled():Boolean;
        function get hasErrors():Boolean;
        function seek(_arg1:Number):void;
        function getBytes():ByteArray;
        function get fragmentDuration():Number;
        function get isBestEffortFetchEnabled():Boolean;

    }
}//package org.osmf.net.httpstreaming 
﻿package org.osmf.net.qos {
    import org.osmf.events.*;
    import __AS3__.vec.*;
    import flash.net.*;

    public class QoSInfoHistory {

        public static const DEFAULT_HISTORY_LENGTH:Number = 10;

        private var history:Vector.<QoSInfo>;
        private var _maxHistoryLength:uint = 0;

        public function QoSInfoHistory(_arg1:NetStream, _arg2:uint=10){
            this.history = new Vector.<QoSInfo>();
            this.maxHistoryLength = _arg2;
            _arg1.addEventListener(QoSInfoEvent.QOS_UPDATE, this.onQoSUpdate);
        }
        public function get length():uint{
            return (this.history.length);
        }
        public function getHistory(_arg1:uint=0):Vector.<QoSInfo>{
            if (_arg1 == 0){
                return (this.history.slice());
            };
            return (this.history.slice(0, _arg1));
        }
        public function getLatestQoSInfo():QoSInfo{
            if (this.history.length > 0){
                return (this.history[0]);
            };
            return (null);
        }
        public function get maxHistoryLength():uint{
            return (this._maxHistoryLength);
        }
        public function set maxHistoryLength(_arg1:uint):void{
            if (_arg1 == 0){
                throw (new ArgumentError("maxHistoryLength needs to be greater than 0."));
            };
            this._maxHistoryLength = _arg1;
            this.trimHistory();
        }
        public function flush():void{
            this.history = new Vector.<QoSInfo>();
        }
        function addQoSInfo(_arg1:QoSInfo):void{
            this.history.splice(0, 0, _arg1);
            this.trimHistory();
        }
        private function onQoSUpdate(_arg1:QoSInfoEvent):void{
            this.addQoSInfo(_arg1.qosInfo);
        }
        private function trimHistory():void{
            if (this.history.length > this._maxHistoryLength){
                this.history.length = this._maxHistoryLength;
            };
        }

    }
}//package org.osmf.net.qos 
﻿package org.osmf.net.qos {

    public class QualityLevel {

        private var _index:uint;
        private var _bitrate:Number;
        private var _streamName:String;

        public function QualityLevel(_arg1:uint, _arg2:Number, _arg3:String=null){
            this._index = _arg1;
            this._bitrate = _arg2;
            this._streamName = _arg3;
        }
        public function get index():uint{
            return (this._index);
        }
        public function get bitrate():Number{
            return (this._bitrate);
        }
        public function get streamName():String{
            return (this._streamName);
        }

    }
}//package org.osmf.net.qos 
﻿package org.osmf.net.qos {

    public class PlaybackDetails {

        private var _index:uint;
        private var _duration:Number;
        private var _droppedFrames:Number;

        public function PlaybackDetails(_arg1:uint, _arg2:Number, _arg3:Number){
            this._index = _arg1;
            this._duration = _arg2;
            this._droppedFrames = _arg3;
        }
        public function get index():uint{
            return (this._index);
        }
        public function get duration():Number{
            return (this._duration);
        }
        public function set duration(_arg1:Number):void{
            this._duration = _arg1;
        }
        public function get droppedFrames():Number{
            return (this._droppedFrames);
        }
        public function set droppedFrames(_arg1:Number):void{
            this._droppedFrames = _arg1;
        }

    }
}//package org.osmf.net.qos 
﻿package org.osmf.net.qos {
    import __AS3__.vec.*;
    import flash.net.*;

    public class QoSInfo {

        private var _currentIndex:int = -1;
        private var _actualIndex:int = -1;
        private var _lastDownloadedFragmentDetails:FragmentDetails = null;
        private var _timestamp:Number = NaN;
        private var _playheadTime:Number = NaN;
        private var _availableQualityLevels:Vector.<QualityLevel> = null;
        private var _maxFPS:Number = NaN;
        private var _nsInfo:NetStreamInfo = null;
        private var _playbackDetailsRecord:Vector.<PlaybackDetails> = null;
        private var _bufferTime:Number = NaN;
        private var _bufferLength:Number = NaN;
        private var _emptyBufferOccurred:Boolean = false;

        public function QoSInfo(_arg1:Number=NaN, _arg2:Number=NaN, _arg3:Vector.<QualityLevel>=null, _arg4:int=-1, _arg5:int=-1, _arg6:FragmentDetails=null, _arg7:Number=NaN, _arg8:Vector.<PlaybackDetails>=null, _arg9:NetStreamInfo=null, _arg10:Number=NaN, _arg11:Number=NaN, _arg12:Boolean=false){
            this._timestamp = _arg1;
            this._playheadTime = _arg2;
            this._availableQualityLevels = _arg3;
            this._currentIndex = _arg4;
            this._actualIndex = _arg5;
            this._lastDownloadedFragmentDetails = _arg6;
            this._maxFPS = _arg7;
            this._playbackDetailsRecord = _arg8;
            this._nsInfo = _arg9;
            this._bufferLength = _arg10;
            this._bufferTime = _arg11;
            this._emptyBufferOccurred = _arg12;
        }
        public function get timestamp():Number{
            return (this._timestamp);
        }
        public function get playheadTime():Number{
            return (this._playheadTime);
        }
        public function get availableQualityLevels():Vector.<QualityLevel>{
            return (this._availableQualityLevels);
        }
        public function get currentIndex():int{
            return (this._currentIndex);
        }
        public function get actualIndex():int{
            return (this._actualIndex);
        }
        public function get lastDownloadedFragmentDetails():FragmentDetails{
            return (this._lastDownloadedFragmentDetails);
        }
        public function get maxFPS():Number{
            return (this._maxFPS);
        }
        public function get nsInfo():NetStreamInfo{
            return (this._nsInfo);
        }
        public function get playbackDetailsRecord():Vector.<PlaybackDetails>{
            return (this._playbackDetailsRecord);
        }
        public function get bufferLength():Number{
            return (this._bufferLength);
        }
        public function get bufferTime():Number{
            return (this._bufferTime);
        }
        public function get emptyBufferOccurred():Boolean{
            return (this._emptyBufferOccurred);
        }

    }
}//package org.osmf.net.qos 
﻿package org.osmf.net.qos {

    public class FragmentDetails {

        private var _index:uint;
        private var _size:Number;
        private var _playDuration:Number;
        private var _downloadDuration:Number;
        private var _fragmentIdentifier:String;

        public function FragmentDetails(_arg1:Number, _arg2:Number, _arg3:Number, _arg4:uint, _arg5:String=null){
            this._size = _arg1;
            this._playDuration = _arg2;
            this._downloadDuration = _arg3;
            this._index = _arg4;
            this._fragmentIdentifier = _arg5;
        }
        public function get size():Number{
            return (this._size);
        }
        public function get playDuration():Number{
            return (this._playDuration);
        }
        public function get downloadDuration():Number{
            return (this._downloadDuration);
        }
        public function get index():uint{
            return (this._index);
        }
        public function get fragmentIdentifier():String{
            return (this._fragmentIdentifier);
        }

    }
}//package org.osmf.net.qos 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import flash.net.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class NetLoader extends LoaderBase {

        private static const PROTOCOL_RTMP:String = "rtmp";
        private static const PROTOCOL_RTMPS:String = "rtmps";
        private static const PROTOCOL_RTMPT:String = "rtmpt";
        private static const PROTOCOL_RTMPE:String = "rtmpe";
        private static const PROTOCOL_RTMPTE:String = "rtmpte";
        private static const PROTOCOL_RTMFP:String = "rtmfp";
        private static const PROTOCOL_HTTP:String = "http";
        private static const PROTOCOL_HTTPS:String = "https";
        private static const PROTOCOL_FILE:String = "file";
        private static const PROTOCOL_EMPTY:String = "";
        private static const MEDIA_TYPES_SUPPORTED:Vector.<String> = Vector.<String>([MediaType.VIDEO]);
        private static const MIME_TYPES_SUPPORTED:Vector.<String> = Vector.<String>(["video/x-flv", "video/x-f4v", "video/mp4", "video/mp4v-es", "video/x-m4v", "video/3gpp", "video/3gpp2", "video/quicktime"]);
        private static const STREAM_RECONNECT_TIMEOUT:Number = 120000;
        private static const STREAM_RECONNECT_TIMER_INTERVAL:int = 1000;

        private var netConnectionFactory:NetConnectionFactoryBase;
        private var pendingLoads:Dictionary;
        private var oldConnectionURLs:Dictionary;
        private var _reconnectStreams:Boolean = true;
        private var _reconnectTimeout:Number;

        public function NetLoader(_arg1:NetConnectionFactoryBase=null){
            this.pendingLoads = new Dictionary();
            this.oldConnectionURLs = new Dictionary();
            super();
            this._reconnectTimeout = STREAM_RECONNECT_TIMEOUT;
            this.netConnectionFactory = ((_arg1) || (new NetConnectionFactory()));
            this.netConnectionFactory.addEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, this.onCreationComplete);
            this.netConnectionFactory.addEventListener(NetConnectionFactoryEvent.CREATION_ERROR, this.onCreationError);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local2:int = MediaTypeUtil.checkMetadataMatchWithResource(_arg1, MEDIA_TYPES_SUPPORTED, MIME_TYPES_SUPPORTED);
            if (_local2 != MediaTypeUtil.METADATA_MATCH_UNKNOWN){
                return ((_local2 == MediaTypeUtil.METADATA_MATCH_FOUND));
            };
            var _local3:URLResource = (_arg1 as URLResource);
            var _local4:RegExp = new RegExp(".flv$|.f4v$|.m3u8$|.mov$|.mp4$|.mp4v$|.m4v$|.3gp$|.3gpp2$|.3g2$", "i");
            var _local5:URL = ((_local3)!=null) ? new URL(_local3.url) : null;
            if ((((((_local5 == null)) || ((_local5.rawUrl == null)))) || ((_local5.rawUrl.length <= 0)))){
                return (false);
            };
            if (_local5.protocol == ""){
                return (_local4.test(_local5.path));
            };
            if (NetStreamUtils.isRTMPStream(_local5.rawUrl)){
                return (true);
            };
            if (_local5.protocol.search(/file$|http$|https$/i) != -1){
                return ((((((((_local5.path == null)) || ((_local5.path.length <= 0)))) || ((_local5.extension.length == 0)))) || (_local4.test(_local5.path))));
            };
            return (false);
        }
        protected function createNetStream(_arg1:NetConnection, _arg2:URLResource):NetStream{
            var _local3:NetStream = new NetStream(_arg1);
            var _local4:StreamingURLResource = (_arg2 as StreamingURLResource);
            if (((((!((_local4 == null))) && ((_local4.streamType == StreamType.LIVE)))) && ((_local3.bufferTime == 0)))){
                _local3.bufferTime = 0.1;
            };
            return (_local3);
        }
        protected function createNetStreamSwitchManager(_arg1:NetConnection, _arg2:NetStream, _arg3:DynamicStreamingResource):NetStreamSwitchManagerBase{
            return (null);
        }
        protected function processFinishLoading(_arg1:NetStreamLoadTrait):void{
            updateLoadTrait(_arg1, LoadState.READY);
        }
        override protected function executeLoad(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.LOADING);
            var _local2:URL = new URL((_arg1.resource as URLResource).url);
            switch (_local2.protocol){
                case PROTOCOL_RTMP:
                case PROTOCOL_RTMPS:
                case PROTOCOL_RTMPT:
                case PROTOCOL_RTMPE:
                case PROTOCOL_RTMPTE:
                case PROTOCOL_RTMFP:
                    this.startLoadingRTMP(_arg1);
                    break;
                case PROTOCOL_HTTP:
                case PROTOCOL_HTTPS:
                case PROTOCOL_FILE:
                case PROTOCOL_EMPTY:
                    this.startLoadingHTTP(_arg1);
                    break;
                default:
                    updateLoadTrait(_arg1, LoadState.LOAD_ERROR);
                    _arg1.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, new MediaError(MediaErrorCodes.URL_SCHEME_INVALID)));
            };
        }
        override protected function executeUnload(_arg1:LoadTrait):void{
            updateLoadTrait(_arg1, LoadState.UNLOADING);
            var _local2:NetStreamLoadTrait = (_arg1 as NetStreamLoadTrait);
            if (_local2 != null){
                if (_local2.netStream != null){
                    _local2.netStream.close();
                };
                if (_local2.netConnectionFactory != null){
                    _local2.netConnectionFactory.closeNetConnection(_local2.connection);
                } else {
                    if (_local2.connection != null){
                        _local2.connection.close();
                    };
                };
            };
            if (this.oldConnectionURLs != null){
                delete this.oldConnectionURLs[_arg1.resource];
            };
            updateLoadTrait(_arg1, LoadState.UNINITIALIZED);
        }
        private function finishLoading(_arg1:NetConnection, _arg2:LoadTrait, _arg3:NetConnectionFactoryBase=null):void{
            var _local5:NetStream;
            var _local6:DynamicStreamingResource;
            var _local4:NetStreamLoadTrait = (_arg2 as NetStreamLoadTrait);
            if (_local4 != null){
                _local4.connection = _arg1;
                _local5 = this.createNetStream(_arg1, (_local4.resource as URLResource));
                _local5.client = new NetClient();
                _local4.netStream = _local5;
                _local6 = (_arg2.resource as DynamicStreamingResource);
                if (_local6 != null){
                    _local4.switchManager = this.createNetStreamSwitchManager(_arg1, _local5, _local6);
                };
                _local4.netConnectionFactory = _arg3;
                if (((((this._reconnectStreams) && ((_local4.resource is URLResource)))) && (this.supportsStreamReconnect((_local4.resource as URLResource))))){
                    this.setupStreamReconnect(_local4);
                };
                this.processFinishLoading((_arg2 as NetStreamLoadTrait));
            };
        }
        private function supportsStreamReconnect(_arg1:URLResource):Boolean{
            var _local3:String;
            var _local4:Array;
            var _local5:int;
            var _local6:int;
            var _local7:int;
            var _local2:Boolean;
            if (NetStreamUtils.isRTMPStream(_arg1.url)){
                _local3 = (_arg1.getMetadataValue(MetadataNamespaces.FMS_SERVER_VERSION_METADATA) as String);
                if (((!((_local3 == null))) && ((_local3.length > 0)))){
                    _local4 = _local3.split(",");
                    if (_local4.length >= 3){
                        _local5 = _local4[0];
                        _local6 = _local4[1];
                        _local7 = _local4[2];
                        if ((((((_local5 < 3)) || ((((_local5 == 3)) && ((_local6 < 5)))))) || ((((((_local5 == 3)) && ((_local6 == 5)))) && ((_local7 < 3)))))){
                            _local2 = false;
                        };
                    };
                };
            } else {
                _local2 = false;
            };
            return (_local2);
        }
        private function startLoadingRTMP(_arg1:LoadTrait):void{
            this.addPendingLoad(_arg1);
            this.netConnectionFactory.create((_arg1.resource as URLResource));
        }
        private function onCreationComplete(_arg1:NetConnectionFactoryEvent):void{
            this.processCreationComplete(_arg1.netConnection, this.findAndRemovePendingLoad(_arg1.resource), (_arg1.currentTarget as NetConnectionFactoryBase));
        }
        protected function processCreationComplete(_arg1:NetConnection, _arg2:LoadTrait, _arg3:NetConnectionFactoryBase=null):void{
            this.finishLoading(_arg1, _arg2, _arg3);
        }
        private function onCreationError(_arg1:NetConnectionFactoryEvent):void{
            var _local2:LoadTrait = this.findAndRemovePendingLoad(_arg1.resource);
            if (_local2 != null){
                _local2.dispatchEvent(new MediaErrorEvent(MediaErrorEvent.MEDIA_ERROR, false, false, _arg1.mediaError));
                updateLoadTrait(_local2, LoadState.LOAD_ERROR);
            };
        }
        private function startLoadingHTTP(_arg1:LoadTrait):void{
            var _local2:NetConnection = new NetConnection();
            _local2.client = new NetClient();
            _local2.connect(null);
            this.finishLoading(_local2, _arg1);
        }
        private function addPendingLoad(_arg1:LoadTrait):void{
            if (this.pendingLoads[_arg1.resource] == null){
                this.pendingLoads[_arg1.resource] = [_arg1];
            } else {
                this.pendingLoads[_arg1.resource].push(_arg1);
            };
        }
        private function findAndRemovePendingLoad(_arg1:URLResource):LoadTrait{
            var _local4:int;
            var _local2:LoadTrait;
            var _local3:Array = this.pendingLoads[_arg1];
            if (_local3 != null){
                if (_local3.length == 1){
                    _local2 = (_local3[0] as LoadTrait);
                    delete this.pendingLoads[_arg1];
                } else {
                    _local4 = 0;
                    while (_local4 < _local3.length) {
                        _local2 = _local3[_local4];
                        if (_local2.resource == _arg1){
                            _local3.splice(_local4, 1);
                            break;
                        };
                        _local4++;
                    };
                };
            };
            return (_local2);
        }
        public function get reconnectTimeout():Number{
            return (this._reconnectTimeout);
        }
        public function set reconnectTimeout(_arg1:Number):void{
            if (_arg1 < 0){
                throw (new ArgumentError(OSMFStrings.getString(OSMFStrings.INVALID_PARAM)));
            };
            this._reconnectTimeout = _arg1;
        }
        protected function setReconnectStreams(_arg1:Boolean):void{
            this._reconnectStreams = _arg1;
        }
        public function get reconnectStreams():Boolean{
            return (this._reconnectStreams);
        }
        protected function createReconnectNetConnection():NetConnection{
            return (new NetConnection());
        }
        protected function reconnect(_arg1:NetConnection, _arg2:URLResource):void{
            var _local3:String = (this.oldConnectionURLs[_arg2] as String);
            if (((((!((_local3 == null))) && ((_local3.length > 0)))) && (!((_arg1 == null))))){
                _arg1.connect(_local3);
            };
        }
        protected function reconnectStream(_arg1:NetStreamLoadTrait):void{
            var _local2:NetStreamPlayOptions = new NetStreamPlayOptions();
            _arg1.netStream.attach(_arg1.connection);
            _local2.transition = NetStreamPlayTransitions.RESUME;
            var _local3:URLResource = (_arg1.resource as URLResource);
            var _local4:Boolean = (((_local3 as StreamingURLResource))!=null) ? (_local3 as StreamingURLResource).urlIncludesFMSApplicationInstance : false;
            var _local5:String = NetStreamUtils.getStreamNameFromURL(_local3.url, _local4);
            _local2.streamName = _local5;
            _arg1.netStream.play2(_local2);
        }
        private function setupStreamReconnect(_arg1:NetStreamLoadTrait):void{
            var netConnection:* = null;
            var reconnectTimer:* = null;
            var timeoutTimer:* = null;
            var streamIsPaused:* = false;
            var bufferIsEmpty:* = false;
            var reconnectHasTimedOut:* = false;
            var fmsIdleTimeoutReached:* = false;
            var onNetStatus:* = null;
            var onTimeoutTimer:* = null;
            var onReconnectTimer:* = null;
            var loadTrait:* = _arg1;
            var setupReconnectTimer:* = function (_arg1:Boolean=true):void{
                if (_arg1){
                    reconnectTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onReconnectTimer);
                } else {
                    reconnectTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onReconnectTimer);
                    reconnectTimer = null;
                };
            };
            var setupTimeoutTimer:* = function (_arg1:Boolean=true):void{
                if (_arg1){
                    if (_reconnectTimeout > 0){
                        timeoutTimer = new Timer(_reconnectTimeout, 1);
                        timeoutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, onTimeoutTimer);
                    };
                } else {
                    if (timeoutTimer != null){
                        timeoutTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, onTimeoutTimer);
                        timeoutTimer = null;
                    };
                };
            };
            var setupNetConnectionListeners:* = function (_arg1:Boolean=true):void{
                if (_arg1){
                    netConnection.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                } else {
                    netConnection.removeEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                };
            };
            var setupNetStreamListeners:* = function (_arg1:Boolean=true):void{
                if (loadTrait.netStream != null){
                    if (_arg1){
                        loadTrait.netStream.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                    } else {
                        loadTrait.netStream.removeEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                    };
                };
            };
            onNetStatus = function (_arg1:NetStatusEvent):void{
                var _local2:NetConnection;
                switch (_arg1.info.code){
                    case NetConnectionCodes.CONNECT_SUCCESS:
                        _local2 = loadTrait.connection;
                        loadTrait.connection = netConnection;
                        oldConnectionURLs[loadTrait.resource] = netConnection.uri;
                        if (timeoutTimer != null){
                            timeoutTimer.stop();
                        };
                        reconnectStream(loadTrait);
                        if (loadTrait.netConnectionFactory != null){
                            loadTrait.netConnectionFactory.closeNetConnection(_local2);
                        } else {
                            _local2.close();
                        };
                        break;
                    case NetConnectionCodes.CONNECT_IDLE_TIME_OUT:
                        fmsIdleTimeoutReached = true;
                        break;
                    case NetConnectionCodes.CONNECT_CLOSED:
                    case NetConnectionCodes.CONNECT_FAILED:
                        if ((((((loadTrait.loadState == LoadState.READY)) && (!(reconnectHasTimedOut)))) && (!(fmsIdleTimeoutReached)))){
                            reconnectTimer.start();
                            if (((((bufferIsEmpty) || ((loadTrait.netStream.bufferLength == 0)))) || (streamIsPaused))){
                                if (timeoutTimer != null){
                                    timeoutTimer.start();
                                } else {
                                    reconnectHasTimedOut = true;
                                    setupReconnectTimer(false);
                                    setupNetConnectionListeners(false);
                                    setupNetStreamListeners(false);
                                    setupTimeoutTimer(false);
                                };
                            };
                        } else {
                            setupReconnectTimer(false);
                            setupNetConnectionListeners(false);
                            setupNetStreamListeners(false);
                            setupTimeoutTimer(false);
                        };
                        break;
                    case NetStreamCodes.NETSTREAM_PAUSE_NOTIFY:
                        streamIsPaused = true;
                        break;
                    case NetStreamCodes.NETSTREAM_UNPAUSE_NOTIFY:
                        streamIsPaused = false;
                        break;
                    case NetStreamCodes.NETSTREAM_BUFFER_EMPTY:
                        if (!netConnection.connected){
                            if (timeoutTimer != null){
                                timeoutTimer.start();
                            } else {
                                reconnectHasTimedOut = true;
                            };
                        } else {
                            bufferIsEmpty = true;
                        };
                        break;
                    case NetStreamCodes.NETSTREAM_BUFFER_FULL:
                        bufferIsEmpty = false;
                        break;
                };
            };
            onTimeoutTimer = function (_arg1:TimerEvent):void{
                reconnectHasTimedOut = true;
            };
            onReconnectTimer = function (_arg1:TimerEvent):void{
                if (reconnectHasTimedOut){
                    return;
                };
                if (netConnection === loadTrait.connection){
                    setupNetConnectionListeners(false);
                    netConnection = createReconnectNetConnection();
                    netConnection.client = new NetClient();
                    setupNetConnectionListeners();
                };
                reconnect(netConnection, (loadTrait.resource as URLResource));
            };
            netConnection = loadTrait.connection;
            reconnectTimer = new Timer(STREAM_RECONNECT_TIMER_INTERVAL, 1);
            this.oldConnectionURLs[loadTrait.resource] = netConnection.uri;
            streamIsPaused = false;
            bufferIsEmpty = false;
            reconnectHasTimedOut = false;
            fmsIdleTimeoutReached = false;
            setupNetConnectionListeners();
            setupNetStreamListeners();
            setupReconnectTimer();
            setupTimeoutTimer();
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import flash.events.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import org.osmf.metadata.*;
    import flash.net.*;
    import flash.utils.*;
    import flash.errors.*;

    class NetNegotiator extends EventDispatcher {

        private var resource:URLResource;
        private var netConnectionURLs:Vector.<String>;
        private var netConnections:Vector.<NetConnection>;
        private var netConnectionArguments:Vector.<Object>;
        private var failedConnectionCount:int;
        private var timeOutTimer:Timer;
        private var connectionTimer:Timer;
        private var attemptIndex:int;
        private var mediaError:MediaError;
        private var connectionAttemptInterval:Number;
        private var _timeout:Number;

        public function NetNegotiator(_arg1:Number, _arg2:Number=10000):void{
            this.connectionAttemptInterval = _arg1;
            this._timeout = _arg2;
        }
        public function get timeout():Number{
            return (this._timeout);
        }
        public function set timeout(_arg1:Number):void{
            this._timeout = _arg1;
        }
        public function createNetConnection(_arg1:URLResource, _arg2:Vector.<String>, _arg3:Vector.<NetConnection>):void{
            this.resource = _arg1;
            this.netConnectionURLs = _arg2;
            this.netConnections = _arg3;
            var _local4:StreamingURLResource = (_arg1 as StreamingURLResource);
            if (((((!((_local4 == null))) && (!((_local4.connectionArguments == null))))) && ((_local4.connectionArguments.length > 0)))){
                this.netConnectionArguments = _local4.connectionArguments;
            };
            this.initializeConnectionAttempts();
            this.tryToConnect(null);
        }
        private function initializeConnectionAttempts():void{
            this.timeOutTimer = new Timer(this._timeout, 1);
            this.timeOutTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.masterTimeout);
            this.timeOutTimer.start();
            this.connectionTimer = new Timer(this.connectionAttemptInterval);
            this.connectionTimer.addEventListener(TimerEvent.TIMER, this.tryToConnect);
            this.connectionTimer.start();
            this.failedConnectionCount = 0;
            this.attemptIndex = 0;
        }
        private function tryToConnect(_arg1:TimerEvent):void{
            var rs:* = null;
            var host:* = null;
            var args:* = null;
            var arg:* = null;
            var evt:* = _arg1;
            this.netConnections[this.attemptIndex].addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, 0, true);
            this.netConnections[this.attemptIndex].addEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onNetSecurityError, false, 0, true);
            this.netConnections[this.attemptIndex].addEventListener(AsyncErrorEvent.ASYNC_ERROR, this.onAsyncError, false, 0, true);
            this.netConnections[this.attemptIndex].client = new NetClient();
            try {
                rs = (this.resource as MulticastResource);
                if (((((!((rs == null))) && (!((rs.groupspec == null))))) && ((rs.groupspec.length > 0)))){
                    NetConnection(this.netConnections[this.attemptIndex]).connect(rs.url);
                } else {
                    host = this.netConnectionURLs[this.attemptIndex];
                    args = [host];
                    if (this.netConnectionArguments != null){
                        for each (arg in this.netConnectionArguments) {
                            args.push(arg);
                        };
                    };
                    NetConnection(this.netConnections[this.attemptIndex]).connect.apply(this.netConnections[this.attemptIndex], args);
                };
                this.attemptIndex++;
                if (this.attemptIndex >= this.netConnectionURLs.length){
                    this.connectionTimer.stop();
                };
            } catch(ioError:IOError) {
                handleFailedConnectionSession(new MediaError(MediaErrorCodes.IO_ERROR, ioError.message), netConnectionURLs[attemptIndex]);
            } catch(argumentError:ArgumentError) {
                handleFailedConnectionSession(new MediaError(MediaErrorCodes.ARGUMENT_ERROR, argumentError.message), netConnectionURLs[attemptIndex]);
            } catch(securityError:SecurityError) {
                handleFailedConnectionSession(new MediaError(MediaErrorCodes.SECURITY_ERROR, securityError.message), netConnectionURLs[attemptIndex]);
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            var index:* = 0;
            var tempTimer:* = null;
            var onTempTimer:* = null;
            var event:* = _arg1;
            switch (event.info.code){
                case NetConnectionCodes.CONNECT_INVALIDAPP:
                    this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.NETCONNECTION_APPLICATION_INVALID, event.info.description), NetConnection(event.target).uri);
                    break;
                case NetConnectionCodes.CONNECT_REJECTED:
                    if (((event.info.hasOwnProperty("ex")) && ((event.info.ex.code == 302)))){
                        onTempTimer = function (_arg1:TimerEvent):void{
                            tempTimer.removeEventListener(TimerEvent.TIMER, onTempTimer);
                            tempTimer.stop();
                            tryToConnect(null);
                        };
                        index = this.netConnections.indexOf((event.target as NetConnection));
                        this.netConnectionURLs[index] = event.info.ex.redirect;
                        this.attemptIndex = index;
                        tempTimer = new Timer(100, 1);
                        tempTimer.addEventListener(TimerEvent.TIMER, onTempTimer);
                        tempTimer.start();
                    } else {
                        this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.NETCONNECTION_REJECTED, event.info.description), NetConnection(event.target).uri);
                    };
                    break;
                case NetConnectionCodes.CONNECT_FAILED:
                    this.failedConnectionCount++;
                    if (this.failedConnectionCount >= this.netConnectionURLs.length){
                        this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.NETCONNECTION_FAILED), NetConnection(event.target).uri);
                    };
                    break;
                case NetConnectionCodes.CONNECT_SUCCESS:
                    if (((event.info.hasOwnProperty("data")) && (event.info.data.hasOwnProperty("version")))){
                        this.resource.addMetadataValue(MetadataNamespaces.FMS_SERVER_VERSION_METADATA, event.info.data.version);
                    };
                    this.shutDownUnsuccessfulConnections();
                    dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_COMPLETE, false, false, (event.currentTarget as NetConnection), this.resource));
                    break;
                case "NetStream.Publish.Start":
                    break;
            };
        }
        private function shutDownUnsuccessfulConnections():void{
            var _local2:NetConnection;
            this.timeOutTimer.stop();
            this.connectionTimer.stop();
            var _local1:int;
            while (_local1 < this.netConnections.length) {
                _local2 = this.netConnections[_local1];
                if (!_local2.connected){
                    _local2.removeEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
                    _local2.removeEventListener(SecurityErrorEvent.SECURITY_ERROR, this.onNetSecurityError);
                    _local2.removeEventListener(AsyncErrorEvent.ASYNC_ERROR, this.onAsyncError);
                    _local2.close();
                    this.netConnections.splice(_local1, 1);
                } else {
                    _local1++;
                };
            };
        }
        private function handleFailedConnectionSession(_arg1:MediaError, _arg2:String):void{
            this.shutDownUnsuccessfulConnections();
            dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_ERROR, false, false, null, this.resource, _arg1));
        }
        private function onNetSecurityError(_arg1:SecurityErrorEvent):void{
            this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.SECURITY_ERROR, _arg1.text), NetConnection(_arg1.target).uri);
        }
        private function onAsyncError(_arg1:AsyncErrorEvent):void{
            this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.ASYNC_ERROR, _arg1.text), NetConnection(_arg1.target).uri);
        }
        private function masterTimeout(_arg1:TimerEvent):void{
            this.handleFailedConnectionSession(new MediaError(MediaErrorCodes.NETCONNECTION_TIMEOUT, ("" + this._timeout)), "");
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.net.*;
    import flash.media.*;

    public class NetStreamAudioTrait extends AudioTrait {

        private var netStream:NetStream;

        public function NetStreamAudioTrait(_arg1:NetStream){
            this.netStream = _arg1;
        }
        override protected function volumeChangeStart(_arg1:Number):void{
            var _local2:SoundTransform = this.netStream.soundTransform;
            _local2.volume = ((muted) ? 0 : _arg1);
            this.netStream.soundTransform = _local2;
        }
        override protected function mutedChangeStart(_arg1:Boolean):void{
            var _local2:SoundTransform = this.netStream.soundTransform;
            _local2.volume = ((_arg1) ? 0 : volume);
            this.netStream.soundTransform = _local2;
        }
        override protected function panChangeStart(_arg1:Number):void{
            var _local2:SoundTransform = this.netStream.soundTransform;
            _local2.pan = _arg1;
            this.netStream.soundTransform = _local2;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import flash.utils.*;
    import org.osmf.media.videoClasses.*;

    public class NetStreamSeekTrait extends SeekTrait {

        private var videoSurface:VideoSurface = null;
        private var loadTrait:LoadTrait;
        private var audioDelay:Number = 0;
        private var seekBugTimer:Timer;
        private var netStream:NetStream;
        private var expectedTime:Number;
        private var previousTime:Number;
        private var suppressSeekNotifyEvent:Boolean = false;

        public function NetStreamSeekTrait(_arg1:TimeTrait, _arg2:LoadTrait, _arg3:NetStream, _arg4:VideoSurface=null){
            super(_arg1);
            this.netStream = _arg3;
            this.videoSurface = _arg4;
            this.loadTrait = _arg2;
            if (_arg3 != null){
                if (_arg3.client != null){
                    NetClient(_arg3.client).addHandler(NetStreamCodes.ON_META_DATA, this.onMetaData);
                };
                _arg3.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            };
            this.seekBugTimer = new Timer(10, 100);
            this.seekBugTimer.addEventListener(TimerEvent.TIMER, this.onSeekBugTimer, false, 0, true);
            this.seekBugTimer.addEventListener(TimerEvent.TIMER_COMPLETE, this.onSeekBugTimerDone, false, 0, true);
        }
        override public function canSeekTo(_arg1:Number):Boolean{
            var _local3:Number;
            var _local2:Boolean = super.canSeekTo(_arg1);
            if (((((((_local2) && (!(isNaN(this.loadTrait.bytesTotal))))) && ((this.loadTrait.bytesTotal > 0)))) && (this.useSeekLimitation))){
                _local3 = (timeTrait.duration * Number((this.loadTrait.bytesLoaded / this.loadTrait.bytesTotal)));
                _local2 = (_arg1 <= _local3);
            };
            return (_local2);
        }
        override protected function seekingChangeStart(_arg1:Boolean, _arg2:Number):void{
            if (_arg1){
                this.suppressSeekNotifyEvent = false;
                this.previousTime = (this.netStream.time - this.audioDelay);
                this.expectedTime = _arg2;
                this.netStream.seek((_arg2 + this.audioDelay));
                if (this.previousTime == this.expectedTime){
                    this.seekBugTimer.start();
                    this.suppressSeekNotifyEvent = true;
                };
            };
        }
        override protected function seekingChangeEnd(_arg1:Number):void{
            var _local2:NetStreamTimeTrait;
            super.seekingChangeEnd(_arg1);
            if ((((seeking == true)) && (!((this.videoSurface == null))))){
                _local2 = (timeTrait as NetStreamTimeTrait);
                if (((!((_local2 == null))) && (((_local2.currentTime + _local2.audioDelay) >= _local2.duration)))){
                    this.videoSurface.clear();
                };
            };
        }
        private function onMetaData(_arg1:Object):void{
            this.audioDelay = ((_arg1.hasOwnProperty("audiodelay")) ? _arg1.audiodelay : 0);
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_SEEK_NOTIFY:
                    this.runSeekBugTimer();
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_INVALIDTIME:
                case NetStreamCodes.NETSTREAM_SEEK_FAILED:
                    setSeeking(false, this.previousTime);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_START:
                case NetStreamCodes.NETSTREAM_PLAY_RESET:
                case NetStreamCodes.NETSTREAM_PAUSE_NOTIFY:
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                case NetStreamCodes.NETSTREAM_UNPAUSE_NOTIFY:
                    if (((seeking) && ((this.seekBugTimer.running == false)))){
                        this.runSeekBugTimer();
                    };
                    break;
            };
        }
        private function runSeekBugTimer():void{
            if (this.suppressSeekNotifyEvent == false){
                this.seekBugTimer.start();
            } else {
                this.suppressSeekNotifyEvent = false;
            };
        }
        private function onSeekBugTimer(_arg1:TimerEvent):void{
            if (((!((this.previousTime == (this.netStream.time - this.audioDelay)))) || ((this.previousTime == this.expectedTime)))){
                this.onSeekBugTimerDone(null);
            };
        }
        private function onSeekBugTimerDone(_arg1:TimerEvent):void{
            this.seekBugTimer.reset();
            setSeeking(false, this.expectedTime);
        }
        private function get useSeekLimitation():Boolean{
            return (!((((((this.loadTrait.bytesLoaded == 0)) && (!((this.videoSurface == null))))) && ((this.videoSurface.info.renderStatus == "accelerated")))));
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;
    import org.osmf.utils.*;

    public class NetStreamDynamicStreamTrait extends DynamicStreamTrait {

        private var netStream:NetStream;
        private var switchManager:NetStreamSwitchManagerBase;
        private var inSetSwitching:Boolean;
        private var dsResource:DynamicStreamingResource;
        private var indexToSwitchTo:int;
        private var index:int;

        public function NetStreamDynamicStreamTrait(_arg1:NetStream, _arg2:NetStreamSwitchManagerBase, _arg3:DynamicStreamingResource){
            super(_arg2.autoSwitch, _arg2.currentIndex, _arg3.streamItems.length);
            this.netStream = _arg1;
            this.switchManager = _arg2;
            this.dsResource = _arg3;
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus, false, int.MAX_VALUE);
            NetClient(_arg1.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus);
        }
        override public function dispose():void{
            this.netStream = null;
            this.switchManager = null;
        }
        override public function getBitrateForIndex(_arg1:int):Number{
            if ((((_arg1 > (numDynamicStreams - 1))) || ((_arg1 < 0)))){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            return (this.dsResource.streamItems[_arg1].bitrate);
        }
        override protected function switchingChangeStart(_arg1:Boolean, _arg2:int):void{
            if (((_arg1) && (!(this.inSetSwitching)))){
                this.indexToSwitchTo = _arg2;
            };
        }
        override protected function switchingChangeEnd(_arg1:int):void{
            var _local2:int;
            if (((!(switching)) || (this.inSetSwitching))){
                super.switchingChangeEnd(_arg1);
            } else {
                _local2 = -1;
                if (this.switchManager.hasOwnProperty("actualIndex")){
                    _local2 = this.switchManager["actualIndex"];
                };
                if (this.indexToSwitchTo != _local2){
                    this.switchManager.switchTo(this.indexToSwitchTo);
                } else {
                    setSwitching(false, this.indexToSwitchTo);
                };
            };
        }
        override protected function autoSwitchChangeStart(_arg1:Boolean):void{
            this.switchManager.autoSwitch = _arg1;
        }
        override protected function maxAllowedIndexChangeStart(_arg1:int):void{
            this.switchManager.maxAllowedIndex = _arg1;
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            var _local2:int;
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_START:
                    if (_arg1.info.details){
                        this.index = this.dsResource.indexFromName(_arg1.info.details);
                        if (this.index != this.currentIndex){
                            this.inSetSwitching = true;
                            setSwitching(true, this.index);
                            this.inSetSwitching = false;
                        };
                        setSwitching(false, this.index);
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION:
                    this.index = this.dsResource.indexFromName(_arg1.info.details);
                    if (this.index >= 0){
                        _local2 = -1;
                        if (this.switchManager.hasOwnProperty("actualIndex")){
                            _local2 = this.switchManager["actualIndex"];
                        };
                        if (this.index != _local2){
                            this.inSetSwitching = true;
                            setSwitching(true, this.index);
                            this.inSetSwitching = false;
                        };
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                    setSwitching(false, currentIndex);
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE:
                    if (((!(_arg1.hasOwnProperty("details"))) || ((this.dsResource.indexFromName(_arg1.details) >= 0)))){
                        setSwitching(false, this.switchManager.currentIndex);
                    };
                    break;
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.net.*;

    public class MulticastNetLoader extends NetLoader {

        public function MulticastNetLoader(_arg1:NetConnectionFactoryBase=null){
            var _local2:NetConnectionFactory;
            if (_arg1 == null){
                _local2 = new NetConnectionFactory();
                _local2.timeout = 60000;
            };
            super(((_arg1)!=null) ? _arg1 : _local2);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local2:MulticastResource = (_arg1 as MulticastResource);
            return (((((((((!((_local2 == null))) && (!((_local2.groupspec == null))))) && ((_local2.groupspec.length > 0)))) && (!((_local2.streamName == null))))) && ((_local2.streamName.length > 0))));
        }
        override protected function createNetStream(_arg1:NetConnection, _arg2:URLResource):NetStream{
            var _local3:MulticastResource = (_arg2 as MulticastResource);
            var _local4:NetStream = new NetStream(_arg1, _local3.groupspec);
            return (_local4);
        }
        private function doProcessCreationComplete(_arg1:NetConnection, _arg2:LoadTrait, _arg3:NetConnectionFactoryBase=null):void{
            super.processCreationComplete(_arg1, _arg2, _arg3);
        }
        override protected function processCreationComplete(_arg1:NetConnection, _arg2:LoadTrait, _arg3:NetConnectionFactoryBase=null):void{
            var netLoadTrait:* = null;
            var netGroup:* = null;
            var onNetStatus:* = null;
            var connection:* = _arg1;
            var loadTrait:* = _arg2;
            var factory = _arg3;
            onNetStatus = function (_arg1:NetStatusEvent):void{
                switch (_arg1.info.code){
                    case "NetGroup.Connect.Success":
                        connection.removeEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                        netLoadTrait.netGroup = netGroup;
                        doProcessCreationComplete(connection, loadTrait, factory);
                        break;
                    case "NetGroup.Connect.Failed":
                    case "NetGroup.Connect.Rejected":
                        connection.removeEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
                        updateLoadTrait(loadTrait, LoadState.LOAD_ERROR);
                        break;
                };
            };
            netLoadTrait = (loadTrait as NetStreamLoadTrait);
            var multicastResource:* = (netLoadTrait.resource as MulticastResource);
            connection.addEventListener(NetStatusEvent.NET_STATUS, onNetStatus);
            netGroup = new NetGroup(connection, multicastResource.groupspec);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public final class StreamingItemType {

        public static const VIDEO:String = "video";
        public static const AUDIO:String = "audio";

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import flash.utils.*;
    import org.osmf.utils.*;

    public class NetConnectionFactory extends NetConnectionFactoryBase {

        private static const DEFAULT_TIMEOUT:Number = 10000;
        private static const DEFAULT_PORTS:String = "1935,443,80";
        private static const DEFAULT_PROTOCOLS_FOR_RTMP:String = "rtmp,rtmpt,rtmps";
        private static const DEFAULT_PROTOCOLS_FOR_RTMPE:String = "rtmpe,rtmpte";
        private static const DEFAULT_CONNECTION_ATTEMPT_INTERVAL:Number = 200;
        private static const PROTOCOL_RTMP:String = "rtmp";
        private static const PROTOCOL_RTMPS:String = "rtmps";
        private static const PROTOCOL_RTMPT:String = "rtmpt";
        private static const PROTOCOL_RTMPE:String = "rtmpe";
        private static const PROTOCOL_RTMPTE:String = "rtmpte";
        private static const PROTOCOL_HTTP:String = "http";
        private static const PROTOCOL_HTTPS:String = "https";
        private static const PROTOCOL_FILE:String = "file";
        private static const PROTOCOL_EMPTY:String = "";
        private static const MP3_EXTENSION:String = ".mp3";

        private var shareNetConnections:Boolean;
        private var negotiator:NetNegotiator;
        private var connectionDictionary:Dictionary;
        private var keyDictionary:Dictionary;
        private var pendingDictionary:Dictionary;
        private var _connectionAttemptInterval:Number = 200;
        private var _timeout:Number = 10000;

        public function NetConnectionFactory(_arg1:Boolean=true){
            this.shareNetConnections = _arg1;
        }
        public function get timeout():Number{
            return (this._timeout);
        }
        public function set timeout(_arg1:Number):void{
            this._timeout = _arg1;
        }
        public function get connectionAttemptInterval():Number{
            return (this._connectionAttemptInterval);
        }
        public function set connectionAttemptInterval(_arg1:Number):void{
            this._connectionAttemptInterval = _arg1;
        }
        override public function create(_arg1:URLResource):void{
            var key:* = null;
            var pendingConnections:* = null;
            var urlIncludesFMSApplicationInstance:* = false;
            var netConnectionURLs:* = null;
            var netConnections:* = null;
            var j:* = 0;
            var negotiator:* = null;
            var onConnected:* = null;
            var onConnectionFailed:* = null;
            var resource:* = _arg1;
            key = this.createNetConnectionKey(resource);
            if (this.connectionDictionary == null){
                this.connectionDictionary = new Dictionary();
                this.keyDictionary = new Dictionary();
                this.pendingDictionary = new Dictionary();
            };
            var sharedConnection:* = (this.connectionDictionary[key] as SharedConnection);
            var connectionsUnderway:* = (this.pendingDictionary[key] as Vector.<URLResource>);
            if (((!((sharedConnection == null))) && (this.shareNetConnections))){
                sharedConnection.count++;
                dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_COMPLETE, false, false, sharedConnection.netConnection, resource));
            } else {
                if (connectionsUnderway != null){
                    connectionsUnderway.push(resource);
                } else {
                    onConnected = function (_arg1:NetConnectionFactoryEvent):void{
                        var _local5:NetConnectionFactoryEvent;
                        var _local6:URLResource;
                        var _local7:SharedConnection;
                        var _local8:SharedConnection;
                        negotiator.removeEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, onConnected);
                        negotiator.removeEventListener(NetConnectionFactoryEvent.CREATION_ERROR, onConnectionFailed);
                        var _local2:Vector.<NetConnectionFactoryEvent> = new Vector.<NetConnectionFactoryEvent>();
                        var _local3:Vector.<URLResource> = pendingDictionary[key];
                        var _local4:Number = 0;
                        while (_local4 < _local3.length) {
                            _local6 = (_local3[_local4] as URLResource);
                            if (shareNetConnections){
                                _local7 = (connectionDictionary[key] as SharedConnection);
                                if (_local7 != null){
                                    _local7.count++;
                                } else {
                                    _local8 = new SharedConnection();
                                    _local8.count = 1;
                                    _local8.netConnection = _arg1.netConnection;
                                    connectionDictionary[key] = _local8;
                                    keyDictionary[_local8.netConnection] = key;
                                };
                            };
                            _local2.push(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_COMPLETE, false, false, _arg1.netConnection, _local6));
                            _local4++;
                        };
                        delete pendingDictionary[key];
                        for each (_local5 in _local2) {
                            dispatchEvent(_local5);
                        };
                    };
                    onConnectionFailed = function (_arg1:NetConnectionFactoryEvent):void{
                        var _local3:URLResource;
                        negotiator.removeEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, onConnected);
                        negotiator.removeEventListener(NetConnectionFactoryEvent.CREATION_ERROR, onConnectionFailed);
                        var _local2:Vector.<URLResource> = pendingDictionary[key];
                        for each (_local3 in _local2) {
                            dispatchEvent(new NetConnectionFactoryEvent(NetConnectionFactoryEvent.CREATION_ERROR, false, false, null, _local3, _arg1.mediaError));
                        };
                        delete pendingDictionary[key];
                    };
                    pendingConnections = new Vector.<URLResource>();
                    pendingConnections.push(resource);
                    this.pendingDictionary[key] = pendingConnections;
                    urlIncludesFMSApplicationInstance = (((resource is StreamingURLResource)) ? StreamingURLResource(resource).urlIncludesFMSApplicationInstance : false);
                    netConnectionURLs = this.createNetConnectionURLs(resource.url, urlIncludesFMSApplicationInstance);
                    netConnections = new Vector.<NetConnection>();
                    j = 0;
                    while (j < netConnectionURLs.length) {
                        netConnections.push(this.createNetConnection());
                        j = (j + 1);
                    };
                    negotiator = new NetNegotiator(this._connectionAttemptInterval, this._timeout);
                    negotiator.addEventListener(NetConnectionFactoryEvent.CREATION_COMPLETE, onConnected);
                    negotiator.addEventListener(NetConnectionFactoryEvent.CREATION_ERROR, onConnectionFailed);
                    negotiator.createNetConnection(resource, netConnectionURLs, netConnections);
                };
            };
        }
        override public function closeNetConnection(_arg1:NetConnection):void{
            var _local2:String;
            var _local3:SharedConnection;
            if (this.shareNetConnections){
                _local2 = (this.keyDictionary[_arg1] as String);
                if (_local2 != null){
                    _local3 = (this.connectionDictionary[_local2] as SharedConnection);
                    _local3.count--;
                    if (_local3.count == 0){
                        _arg1.close();
                        delete this.connectionDictionary[_local2];
                        delete this.keyDictionary[_arg1];
                    };
                };
            } else {
                super.closeNetConnection(_arg1);
            };
        }
        protected function createNetConnectionKey(_arg1:URLResource):String{
            var _local2:FMSURL = new FMSURL(_arg1.url);
            return (((((_local2.protocol + _local2.host) + _local2.port) + _local2.appName) + _local2.instanceName));
        }
        protected function createNetConnection():NetConnection{
            return (new NetConnection());
        }
        protected function createNetConnectionURLs(_arg1:String, _arg2:Boolean=false):Vector.<String>{
            var _local5:PortProtocol;
            var _local3:Vector.<String> = new Vector.<String>();
            var _local4:Vector.<PortProtocol> = this.buildPortProtocolSequence(_arg1);
            for each (_local5 in _local4) {
                _local3.push(this.buildConnectionAddress(_arg1, _arg2, _local5));
            };
            return (_local3);
        }
        private function buildPortProtocolSequence(_arg1:String):Vector.<PortProtocol>{
            var _local9:int;
            var _local10:PortProtocol;
            var _local2:Vector.<PortProtocol> = new Vector.<PortProtocol>();
            var _local3:URL = new URL(_arg1);
            var _local4:String = ((_local3.port)=="") ? DEFAULT_PORTS : _local3.port;
            var _local5 = "";
            switch (_local3.protocol){
                case PROTOCOL_RTMP:
                    _local5 = DEFAULT_PROTOCOLS_FOR_RTMP;
                    break;
                case PROTOCOL_RTMPE:
                    _local5 = DEFAULT_PROTOCOLS_FOR_RTMPE;
                    break;
                case PROTOCOL_RTMPS:
                case PROTOCOL_RTMPT:
                case PROTOCOL_RTMPTE:
                    _local5 = _local3.protocol;
                    break;
            };
            var _local6:Array = _local4.split(",");
            var _local7:Array = _local5.split(",");
            var _local8:int;
            while (_local8 < _local7.length) {
                _local9 = 0;
                while (_local9 < _local6.length) {
                    _local10 = new PortProtocol();
                    _local10.protocol = _local7[_local8];
                    _local10.port = _local6[_local9];
                    _local2.push(_local10);
                    _local9++;
                };
                _local8++;
            };
            return (_local2);
        }
        private function buildConnectionAddress(_arg1:String, _arg2:Boolean, _arg3:PortProtocol):String{
            var _local4:FMSURL = new FMSURL(_arg1, _arg2);
            var _local5:String = (((((((_arg3.protocol + "://") + _local4.host) + ":") + _arg3.port) + "/") + _local4.appName) + ((_local4.useInstance) ? ("/" + _local4.instanceName) : ""));
            if (((!((_local4.query == null))) && (!((_local4.query == ""))))){
                _local5 = (_local5 + ("?" + _local4.query));
            };
            return (_local5);
        }

    }
}//package org.osmf.net 

import flash.net.*;

class SharedConnection {

    public var count:Number;
    public var netConnection:NetConnection;

    public function SharedConnection(){
    }
}
﻿package org.osmf.net.rtmpstreaming {
    import org.osmf.net.*;

    public class SufficientBandwidthRule extends SwitchingRuleBase {

        private static const BANDWIDTH_SAFETY_MULTIPLE:Number = 1.15;
        private static const MIN_DROPPED_FPS:int = 2;

        public function SufficientBandwidthRule(_arg1:RTMPNetStreamMetrics){
            super(_arg1);
        }
        override public function getNewIndex():int{
            var _local2:String;
            var _local3:int;
            var _local1 = -1;
            if (this.rtmpMetrics.averageMaxBytesPerSecond != 0){
                _local3 = (this.rtmpMetrics.resource.streamItems.length - 1);
                while (_local3 >= 0) {
                    if (((this.rtmpMetrics.averageMaxBytesPerSecond * 8) / 0x0400) > (this.rtmpMetrics.resource.streamItems[_local3].bitrate * BANDWIDTH_SAFETY_MULTIPLE)){
                        _local1 = _local3;
                        break;
                    };
                    _local3--;
                };
                if (_local1 > this.rtmpMetrics.currentIndex){
                    _local1 = (((((this.rtmpMetrics.droppedFPS < MIN_DROPPED_FPS)) && ((this.rtmpMetrics.netStream.bufferLength > this.rtmpMetrics.netStream.bufferTime)))) ? _local1 : -1);
                } else {
                    _local1 = -1;
                };
            };
            return (_local1);
        }
        private function get rtmpMetrics():RTMPNetStreamMetrics{
            return ((metrics as RTMPNetStreamMetrics));
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net.rtmpstreaming {
    import org.osmf.media.*;
    import org.osmf.net.*;
    import __AS3__.vec.*;
    import flash.net.*;

    public class RTMPDynamicStreamingNetLoader extends NetLoader {

        public function RTMPDynamicStreamingNetLoader(_arg1:NetConnectionFactoryBase=null){
            super(_arg1);
        }
        override public function canHandleResource(_arg1:MediaResourceBase):Boolean{
            var _local2:DynamicStreamingResource = (_arg1 as DynamicStreamingResource);
            return (((((!((_local2 == null))) && (NetStreamUtils.isRTMPStream(_local2.host)))) || (super.canHandleResource(_arg1))));
        }
        override protected function createNetStreamSwitchManager(_arg1:NetConnection, _arg2:NetStream, _arg3:DynamicStreamingResource):NetStreamSwitchManagerBase{
            var _local4:RTMPNetStreamMetrics = new RTMPNetStreamMetrics(_arg2);
            return (new NetStreamSwitchManager(_arg1, _arg2, _arg3, _local4, this.getDefaultSwitchingRules(_local4)));
        }
        private function getDefaultSwitchingRules(_arg1:RTMPNetStreamMetrics):Vector.<SwitchingRuleBase>{
            var _local2:Vector.<SwitchingRuleBase> = new Vector.<SwitchingRuleBase>();
            _local2.push(new SufficientBandwidthRule(_arg1));
            _local2.push(new InsufficientBandwidthRule(_arg1));
            _local2.push(new DroppedFramesRule(_arg1));
            _local2.push(new InsufficientBufferRule(_arg1));
            return (_local2);
        }
        override protected function reconnectStream(_arg1:NetStreamLoadTrait):void{
            var _local3:NetStreamPlayOptions;
            var _local4:DynamicStreamingItem;
            var _local5:String;
            var _local2:DynamicStreamingResource = (_arg1.resource as DynamicStreamingResource);
            if (_local2 == null){
                super.reconnectStream(_arg1);
            } else {
                _local3 = new NetStreamPlayOptions();
                _arg1.netStream.attach(_arg1.connection);
                _local3.transition = NetStreamPlayTransitions.RESUME;
                _local4 = _local2.streamItems[_arg1.switchManager.currentIndex];
                _local5 = _local4.streamName;
                _local3.streamName = _local5;
                _arg1.netStream.play2(_local3);
            };
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net.rtmpstreaming {
    import org.osmf.net.*;
    import flash.utils.*;

    public class DroppedFramesRule extends SwitchingRuleBase {

        private static const LOCK_INTERVAL:Number = 30000;

        private var downSwitchByOne:int;
        private var downSwitchByTwo:int;
        private var downSwitchToZero:int;
        private var lockLevel:Number;
        private var lastLockTime:Number;

        public function DroppedFramesRule(_arg1:NetStreamMetricsBase, _arg2:int=10, _arg3:int=20, _arg4:int=24){
            super(_arg1);
            this.downSwitchByOne = _arg2;
            this.downSwitchByTwo = _arg3;
            this.downSwitchToZero = _arg4;
            this.lastLockTime = 0;
            this.lockLevel = int.MAX_VALUE;
        }
        override public function getNewIndex():int{
            var _local2:String;
            var _local1 = -1;
            if (metrics.averageDroppedFPS > this.downSwitchToZero){
                _local1 = 0;
                _local2 = ((("Average droppedFPS of " + Math.round(metrics.averageDroppedFPS)) + " > ") + this.downSwitchToZero);
            } else {
                if (metrics.averageDroppedFPS > this.downSwitchByTwo){
                    _local1 = ((((metrics.currentIndex - 2) < 0)) ? 0 : (metrics.currentIndex - 2));
                    _local2 = ((("Average droppedFPS of " + Math.round(metrics.averageDroppedFPS)) + " > ") + this.downSwitchByTwo);
                } else {
                    if (metrics.averageDroppedFPS > this.downSwitchByOne){
                        _local1 = ((((metrics.currentIndex - 1) < 0)) ? 0 : (metrics.currentIndex - 1));
                        _local2 = ((("Average droppedFPS of " + Math.round(metrics.averageDroppedFPS)) + " > ") + this.downSwitchByOne);
                    };
                };
            };
            if (((!((_local1 == -1))) && ((_local1 < metrics.currentIndex)))){
                this.lockIndex(_local1);
            };
            if ((((_local1 == -1)) && (this.isLocked(metrics.currentIndex)))){
                _local1 = metrics.currentIndex;
            };
            return (_local1);
        }
        private function lockIndex(_arg1:int):void{
            if (!this.isLocked(_arg1)){
                this.lockLevel = _arg1;
                this.lastLockTime = getTimer();
            };
        }
        private function isLocked(_arg1:int):Boolean{
            return ((((_arg1 >= this.lockLevel)) && (((getTimer() - this.lastLockTime) < LOCK_INTERVAL))));
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net.rtmpstreaming {
    import org.osmf.net.*;

    public class InsufficientBandwidthRule extends SwitchingRuleBase {

        private var bitrateMultiplier:Number;

        public function InsufficientBandwidthRule(_arg1:RTMPNetStreamMetrics, _arg2:Number=1.15){
            super(_arg1);
            this.bitrateMultiplier = _arg2;
        }
        override public function getNewIndex():int{
            var _local2:String;
            var _local3:int;
            var _local1 = -1;
            if (this.rtmpMetrics.averageMaxBytesPerSecond != 0){
                _local3 = this.rtmpMetrics.currentIndex;
                while (_local3 >= 0) {
                    if (((this.rtmpMetrics.averageMaxBytesPerSecond * 8) / 0x0400) > (this.rtmpMetrics.resource.streamItems[_local3].bitrate * this.bitrateMultiplier)){
                        _local1 = _local3;
                        break;
                    };
                    _local3--;
                };
                _local1 = ((_local1)==this.rtmpMetrics.currentIndex) ? -1 : _local1;
            };
            return (_local1);
        }
        private function get rtmpMetrics():RTMPNetStreamMetrics{
            return ((metrics as RTMPNetStreamMetrics));
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net.rtmpstreaming {
    import flash.events.*;
    import org.osmf.net.*;

    public class InsufficientBufferRule extends SwitchingRuleBase {

        private var _panic:Boolean;
        private var _moreDetail:String;
        private var minBufferLength:Number;

        public function InsufficientBufferRule(_arg1:RTMPNetStreamMetrics, _arg2:Number=2){
            super(_arg1);
            this._panic = false;
            this.minBufferLength = _arg2;
            _arg1.netStream.addEventListener(NetStatusEvent.NET_STATUS, this.monitorNetStatus, false, 0, true);
        }
        override public function getNewIndex():int{
            var _local1 = -1;
            if (((this._panic) || ((((this.rtmpMetrics.netStream.bufferLength < this.minBufferLength)) && ((this.rtmpMetrics.netStream.bufferLength > this.rtmpMetrics.netStream.bufferTime)))))){
                _local1 = 0;
            };
            return (_local1);
        }
        private function monitorNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_BUFFER_FULL:
                    this._panic = false;
                    break;
                case NetStreamCodes.NETSTREAM_BUFFER_EMPTY:
                    if (Math.round(this.rtmpMetrics.netStream.time) != 0){
                        this._panic = true;
                        this._moreDetail = "Buffer was empty";
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_INSUFFICIENTBW:
                    this._panic = true;
                    this._moreDetail = "Stream had insufficient bandwidth";
                    break;
            };
        }
        private function get rtmpMetrics():RTMPNetStreamMetrics{
            return ((metrics as RTMPNetStreamMetrics));
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net.rtmpstreaming {
    import org.osmf.net.*;
    import flash.net.*;

    public class RTMPNetStreamMetrics extends NetStreamMetricsBase {

        private static const DEFAULT_AVG_MAX_BYTES_SAMPLE_SIZE:Number = 50;

        private var _averageMaxBytesPerSecondArray:Array;
        private var _averageMaxBytesPerSecond:Number;

        public function RTMPNetStreamMetrics(_arg1:NetStream){
            super(_arg1);
            this._averageMaxBytesPerSecondArray = new Array();
        }
        public function get averageMaxBytesPerSecond():Number{
            return (this._averageMaxBytesPerSecond);
        }
        override protected function calculateMetrics():void{
            var maxBytesPerSecond:* = NaN;
            var totalMaxBytesPerSecond:* = NaN;
            var peakMaxBytesPerSecond:* = NaN;
            var b:* = 0;
            super.calculateMetrics();
            try {
                maxBytesPerSecond = netStream.info.maxBytesPerSecond;
                this._averageMaxBytesPerSecondArray.unshift(maxBytesPerSecond);
                if (this._averageMaxBytesPerSecondArray.length > DEFAULT_AVG_MAX_BYTES_SAMPLE_SIZE){
                    this._averageMaxBytesPerSecondArray.pop();
                };
                totalMaxBytesPerSecond = 0;
                peakMaxBytesPerSecond = 0;
                b = 0;
                while (b < this._averageMaxBytesPerSecondArray.length) {
                    totalMaxBytesPerSecond = (totalMaxBytesPerSecond + this._averageMaxBytesPerSecondArray[b]);
                    peakMaxBytesPerSecond = (((this._averageMaxBytesPerSecondArray[b] > peakMaxBytesPerSecond)) ? this._averageMaxBytesPerSecondArray[b] : peakMaxBytesPerSecond);
                    b = (b + 1);
                };
                this._averageMaxBytesPerSecond = (((this._averageMaxBytesPerSecondArray.length < DEFAULT_AVG_MAX_BYTES_SAMPLE_SIZE)) ? 0 : ((this.isLive) ? peakMaxBytesPerSecond : (totalMaxBytesPerSecond / this._averageMaxBytesPerSecondArray.length)));
            } catch(error:Error) {
                throw (error);
            };
        }
        private function get isLive():Boolean{
            return (((resource) && ((resource.streamType == StreamType.LIVE))));
        }

    }
}//package org.osmf.net.rtmpstreaming 
﻿package org.osmf.net {
    import flash.events.*;
    import flash.net.*;
    import flash.utils.*;

    public class NetStreamMetricsBase extends EventDispatcher {

        private static const DEFAULT_UPDATE_INTERVAL:Number = 100;
        private static const DEFAULT_AVG_FRAMERATE_SAMPLE_SIZE:Number = 50;

        private var _netStream:NetStream;
        private var _resource:DynamicStreamingResource;
        private var _currentIndex:int;
        private var _maxAllowedIndex:int;
        private var _timer:Timer;
        private var _averageDroppedFPSArray:Array;
        private var _averageDroppedFPS:Number;
        private var _droppedFPS:Number;
        private var _lastFrameDropValue:Number;
        private var _lastFrameDropCounter:Number;
        private var _maxFPS:Number;

        public function NetStreamMetricsBase(_arg1:NetStream){
            this._netStream = _arg1;
            this._droppedFPS = 0;
            this._lastFrameDropCounter = 0;
            this._lastFrameDropValue = 0;
            this._maxFPS = 0;
            this._averageDroppedFPSArray = new Array();
            this._timer = new Timer(DEFAULT_UPDATE_INTERVAL);
            this._timer.addEventListener(TimerEvent.TIMER, this.onTimerEvent);
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatusEvent);
        }
        public function get resource():DynamicStreamingResource{
            return (this._resource);
        }
        public function set resource(_arg1:DynamicStreamingResource):void{
            this._resource = _arg1;
            this._maxAllowedIndex = ((_arg1)!=null) ? (_arg1.streamItems.length - 1) : 0;
        }
        public function get netStream():NetStream{
            return (this._netStream);
        }
        public function get currentIndex():int{
            return (this._currentIndex);
        }
        public function set currentIndex(_arg1:int):void{
            this._currentIndex = _arg1;
        }
        public function get maxAllowedIndex():int{
            return (this._maxAllowedIndex);
        }
        public function set maxAllowedIndex(_arg1:int):void{
            this._maxAllowedIndex = _arg1;
        }
        public function get updateInterval():Number{
            return (this._timer.delay);
        }
        public function set updateInterval(_arg1:Number):void{
            this._timer.delay = _arg1;
            if (_arg1 <= 0){
                this._timer.stop();
            };
        }
        public function get maxFPS():Number{
            return (this._maxFPS);
        }
        public function get droppedFPS():Number{
            return (this._droppedFPS);
        }
        public function get averageDroppedFPS():Number{
            return (this._averageDroppedFPS);
        }
        protected function calculateMetrics():void{
            var totalDroppedFrameRate:* = NaN;
            var f:* = 0;
            try {
                this._maxFPS = (((this.netStream.currentFPS > this._maxFPS)) ? this.netStream.currentFPS : this._maxFPS);
                if ((this._timer.currentCount - this._lastFrameDropCounter) > (1000 / this._timer.delay)){
                    this._droppedFPS = ((this.netStream.info.droppedFrames - this._lastFrameDropValue) / (((this._timer.currentCount - this._lastFrameDropCounter) * this._timer.delay) / 1000));
                    this._lastFrameDropCounter = this._timer.currentCount;
                    this._lastFrameDropValue = this.netStream.info.droppedFrames;
                };
                this._averageDroppedFPSArray.unshift(this._droppedFPS);
                if (this._averageDroppedFPSArray.length > DEFAULT_AVG_FRAMERATE_SAMPLE_SIZE){
                    this._averageDroppedFPSArray.pop();
                };
                totalDroppedFrameRate = 0;
                f = 0;
                while (f < this._averageDroppedFPSArray.length) {
                    totalDroppedFrameRate = (totalDroppedFrameRate + this._averageDroppedFPSArray[f]);
                    f = (f + 1);
                };
                this._averageDroppedFPS = (((this._averageDroppedFPSArray.length < DEFAULT_AVG_FRAMERATE_SAMPLE_SIZE)) ? 0 : (totalDroppedFrameRate / this._averageDroppedFPSArray.length));
            } catch(error:Error) {
                throw (error);
            };
        }
        private function onNetStatusEvent(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_START:
                    if (((!(this._timer.running)) && ((this.updateInterval > 0)))){
                        this._timer.start();
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    this._timer.stop();
                    break;
            };
        }
        private function onTimerEvent(_arg1:TimerEvent):void{
            if (isNaN(this.netStream.time)){
                this._timer.stop();
            } else {
                this.calculateMetrics();
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import __AS3__.vec.*;
    import flash.utils.*;

    public class MulticastResource extends StreamingURLResource {

        private var _groupspec:String;
        private var _streamName:String;

        public function MulticastResource(_arg1:String, _arg2:String=null, _arg3:String=null, _arg4:Vector.<Object>=null, _arg5:Boolean=false, _arg6:ByteArray=null){
            super(_arg1, StreamType.LIVE, NaN, NaN, _arg4, _arg5, _arg6);
            this._groupspec = _arg2;
            this._streamName = _arg3;
        }
        public function get groupspec():String{
            return (this._groupspec);
        }
        public function set groupspec(_arg1:String):void{
            this._groupspec = _arg1;
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function set streamName(_arg1:String):void{
            this._streamName = _arg1;
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import flash.events.*;
    import flash.net.*;
    import org.osmf.utils.*;

    public class NetStreamSwitcher extends EventDispatcher {

        private var oldStreamName:String;
        private var netStream:NetStream = null;
        private var dsResource:DynamicStreamingResource = null;
        private var _currentIndex:uint = 0;
        private var _actualIndex:int = -1;
        private var _switching:Boolean;

        public function NetStreamSwitcher(_arg1:NetStream, _arg2:DynamicStreamingResource){
            if (_arg1 == null){
                throw (new ArgumentError("Invalid netStream"));
            };
            if (_arg2 == null){
                throw (new ArgumentError("Invalid dynamic streaming resource"));
            };
            this.netStream = _arg1;
            this.dsResource = _arg2;
            this._currentIndex = Math.max(0, _arg2.initialIndex);
            _arg1.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            var _local3:NetClient = (_arg1.client as NetClient);
            if (_local3 != null){
                NetClient(_arg1.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus, int.MAX_VALUE);
            } else {
                throw (new Error("The netStream does not have a NetClient associated."));
            };
        }
        public function get currentIndex():uint{
            return (this._currentIndex);
        }
        public function get actualIndex():int{
            return ((((this._actualIndex == -1)) ? this._currentIndex : this._actualIndex));
        }
        public function get switching():Boolean{
            return (this._switching);
        }
        public function switchTo(_arg1:int):void{
            if (_arg1 < 0){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            if (this._actualIndex == -1){
                this.prepareForSwitching();
            };
            this.executeSwitch(_arg1);
        }
        private function setCurrentIndex(_arg1:uint):void{
            var _local2:uint = this._currentIndex;
            this._currentIndex = _arg1;
        }
        private function setActualIndex(_arg1:int):void{
            var _local2:int = this._actualIndex;
            this._actualIndex = _arg1;
        }
        private function executeSwitch(_arg1:int):void{
            var _local2:NetStreamPlayOptions = new NetStreamPlayOptions();
            var _local3:Object = NetStreamUtils.getPlayArgsForResource(this.dsResource);
            _local2.start = _local3.start;
            _local2.len = _local3.len;
            _local2.streamName = this.dsResource.streamItems[_arg1].streamName;
            var _local4:String = this.oldStreamName;
            if (((!((_local4 == null))) && ((_local4.indexOf("?") >= 0)))){
                _local2.oldStreamName = _local4.substr(0, _local4.indexOf("?"));
            } else {
                _local2.oldStreamName = this.oldStreamName;
            };
            _local2.transition = NetStreamPlayTransitions.SWITCH;
            this._switching = true;
            this.netStream.play2(_local2);
            this.oldStreamName = this.dsResource.streamItems[_arg1].streamName;
        }
        private function prepareForSwitching():void{
            this._actualIndex = 0;
            if ((((this.dsResource.initialIndex >= 0)) && ((this.dsResource.initialIndex < this.dsResource.streamItems.length)))){
                this._actualIndex = this.dsResource.initialIndex;
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            var _local2:int;
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_START:
                    if (this._actualIndex == -1){
                        this.prepareForSwitching();
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION:
                    _local2 = this.dsResource.indexFromName(_arg1.info.details);
                    if (_local2 >= 0){
                        this.setActualIndex(_local2);
                        if (this._actualIndex > -1){
                            this._switching = false;
                        };
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                    this._switching = false;
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_NOTIFY:
                    this._switching = false;
                    this.setCurrentIndex(this.actualIndex);
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            var _local2:int;
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE:
                    _local2 = this.dsResource.indexFromName(_arg1.details);
                    if (_local2 >= 0){
                        this.setCurrentIndex(_local2);
                    };
                    break;
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import __AS3__.vec.*;
    import org.osmf.utils.*;

    public class FMSURL extends URL {

        private static const APPNAME_START_INDEX:uint = 0;
        private static const INSTANCENAME_START_INDEX:uint = 2;
        private static const STREAMNAME_START_INDEX:uint = 4;
        private static const DEFAULT_INSTANCE_NAME:String = "_definst_";
        public static const MP4_STREAM:String = "mp4";
        public static const MP3_STREAM:String = "mp3";
        public static const ID3_STREAM:String = "id3";
        public static const QUERY_STRING_STREAM:String = "streamName";
        public static const QUERY_STRING_STREAMTYPE:String = "streamType";

        private var _useInstance:Boolean;
        private var _appName:String;
        private var _instanceName:String;
        private var _streamName:String;
        private var _fileFormat:String;
        private var _origins:Vector.<FMSHost>;
        private var _edges:Vector.<FMSHost>;

        public function FMSURL(_arg1:String, _arg2:Boolean=false){
            super(_arg1);
            this._useInstance = _arg2;
            this._appName = "";
            this._instanceName = "";
            this._streamName = "";
            this._fileFormat = "";
            this.parsePath();
            this.parseQuery();
        }
        public function get useInstance():Boolean{
            return (this._useInstance);
        }
        public function get appName():String{
            return (this._appName);
        }
        public function get instanceName():String{
            return (this._instanceName);
        }
        public function get streamName():String{
            return (this._streamName);
        }
        public function get fileFormat():String{
            return (this._fileFormat);
        }
        public function get edges():Vector.<FMSHost>{
            return (this._edges);
        }
        public function get origins():Vector.<FMSHost>{
            return (this._origins);
        }
        private function parsePath():void{
            var _local7:RegExp;
            var _local8:uint;
            var _local9:int;
            if ((((path == null)) || ((path.length == 0)))){
                this._streamName = getParamValue(QUERY_STRING_STREAM);
                this._fileFormat = getParamValue(QUERY_STRING_STREAMTYPE);
                return;
            };
            var _local1:RegExp = /(\/)/;
            var _local2:Array = path.split(_local1);
            if (_local2 != null){
                this._appName = _local2[APPNAME_START_INDEX];
                this._instanceName = "";
                this._streamName = "";
                _local7 = new RegExp(("^.*/" + DEFAULT_INSTANCE_NAME), "i");
                if (path.search(_local7) > -1){
                    this._useInstance = true;
                };
                _local8 = STREAMNAME_START_INDEX;
                if (this._useInstance){
                    this._instanceName = _local2[INSTANCENAME_START_INDEX];
                } else {
                    _local8 = INSTANCENAME_START_INDEX;
                };
                _local9 = _local8;
                while (_local9 < _local2.length) {
                    this._streamName = (this._streamName + _local2[_local9]);
                    _local9++;
                };
                if ((((this._streamName == null)) || ((this._streamName == "")))){
                    this._streamName = getParamValue(QUERY_STRING_STREAM);
                };
                if (this._streamName.search(/^mp4:/i) > -1){
                    this._fileFormat = MP4_STREAM;
                } else {
                    if (this._streamName.search(/^mp3:/i) > -1){
                        this._fileFormat = MP3_STREAM;
                    } else {
                        if (this._streamName.search(/^id3:/i) > -1){
                            this._fileFormat = ID3_STREAM;
                        };
                    };
                };
                if ((((this._fileFormat == null)) || ((this._fileFormat == "")))){
                    this._fileFormat = getParamValue(QUERY_STRING_STREAMTYPE);
                };
            };
            var _local3:int = this._streamName.indexOf("/mp4:");
            var _local4:int = this._streamName.indexOf("/mp3:");
            var _local5:int = this._streamName.indexOf("/id3:");
            var _local6 = -1;
            if (_local3 > 0){
                _local6 = _local3;
            } else {
                if (_local4 > 0){
                    _local6 = _local4;
                } else {
                    if (_local5 > 0){
                        _local6 = _local5;
                    };
                };
            };
            if (((this.useInstance) && ((_local6 > 0)))){
                this._instanceName = (this._instanceName + "/");
                this._instanceName = (this._instanceName + this._streamName.substr(0, _local6));
                this._streamName = this.streamName.substr((_local6 + 1));
            };
        }
        private function parseQuery():void{
            var _local12:int;
            var _local13:int;
            var _local14:FMSURL;
            if ((((((query == null)) || ((query.length == 0)))) || ((query.search(/:\//) == -1)))){
                return;
            };
            var _local1:Array = query.split("?");
            var _local2:int;
            while (_local2 < _local1.length) {
                _local12 = _local1[_local2].toString().search(/:\//);
                if (_local12 == -1){
                    _local1.splice(_local2, 1);
                };
                _local2++;
            };
            var _local3:Boolean;
            var _local4:int;
            if (_local1.length >= 2){
                _local3 = true;
                _local4 = (_local1.length - 1);
            };
            var _local5 = "";
            var _local6 = "";
            var _local7:int;
            var _local8:int;
            var _local9:int;
            var _local10:int;
            var _local11:int;
            while (_local11 < _local1.length) {
                _local13 = _local1[_local11].toString().search(/:\//);
                _local9 = (_local13 + 2);
                if (_local1[_local11].charAt(_local9) == "/"){
                    _local9++;
                };
                _local7 = _local1[_local11].indexOf(":", _local9);
                _local8 = _local1[_local11].indexOf("/", _local9);
                if ((((_local8 < 0)) && ((_local7 < 0)))){
                    _local5 = _local1[_local11].slice(_local9);
                } else {
                    if ((((_local7 >= 0)) && ((_local7 < _local8)))){
                        _local10 = _local7;
                        _local5 = _local1[_local11].slice(_local9, _local10);
                        _local9 = (_local10 + 1);
                        _local10 = _local8;
                        _local6 = _local1[_local11].slice(_local9, _local10);
                    } else {
                        if (_local1[_local11].indexOf("://") != -1){
                            _local10 = _local8;
                            _local5 = _local1[_local11].slice(_local9, _local10);
                        } else {
                            _local10 = _local1[_local11].indexOf("/");
                            _local5 = "localhost";
                        };
                    };
                };
                if (_local11 == _local4){
                    if (this._origins == null){
                        this._origins = new Vector.<FMSHost>();
                    };
                    this._origins.push(new FMSHost(_local5, _local6));
                    _local14 = new FMSURL(_local1[_local11], this._useInstance);
                    if (this._appName == ""){
                        this._appName = _local14.appName;
                    };
                    if (((this._useInstance) && ((this._instanceName == "")))){
                        this._instanceName = _local14.instanceName;
                    };
                    if (this._streamName == ""){
                        this._streamName = _local14.streamName;
                    };
                } else {
                    if (((!((_local1[_local11] == query))) && (_local3))){
                        if (this._edges == null){
                            this._edges = new Vector.<FMSHost>();
                        };
                        this._edges.push(new FMSHost(_local5, _local6));
                    };
                };
                _local11++;
            };
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {
    import flash.events.*;
    import __AS3__.vec.*;
    import flash.net.*;
    import flash.utils.*;
    import org.osmf.utils.*;
    import flash.errors.*;

    public class NetStreamSwitchManager extends NetStreamSwitchManagerBase {

        private static const RULE_CHECK_INTERVAL:Number = 500;
        private static const DEFAULT_MAX_UP_SWITCHES_PER_STREAM_ITEM:int = 3;
        private static const DEFAULT_WAIT_DURATION_AFTER_DOWN_SWITCH:int = 30000;
        private static const DEFAULT_CLEAR_FAILED_COUNTS_INTERVAL:Number = 300000;

        private var netStream:NetStream;
        private var dsResource:DynamicStreamingResource;
        private var switchingRules:Vector.<SwitchingRuleBase>;
        private var metrics:NetStreamMetricsBase;
        private var checkRulesTimer:Timer;
        private var clearFailedCountsTimer:Timer;
        private var actualIndex:int = -1;
        private var oldStreamName:String;
        private var switching:Boolean;
        private var _currentIndex:int;
        private var lastTransitionIndex:int = -1;
        private var connection:NetConnection;
        private var dsiFailedCounts:Vector.<int>;
        private var failedDSI:Dictionary;
        private var _bandwidthLimit:Number = 0;

        public function NetStreamSwitchManager(_arg1:NetConnection, _arg2:NetStream, _arg3:DynamicStreamingResource, _arg4:NetStreamMetricsBase, _arg5:Vector.<SwitchingRuleBase>, _arg6:Boolean=true){
            this.connection = _arg1;
            this.netStream = _arg2;
            this.dsResource = _arg3;
            this.metrics = _arg4;
            _arg4.resource = _arg3;
            this.switchingRules = ((_arg5) || (new Vector.<SwitchingRuleBase>()));
            this._currentIndex = Math.max(0, Math.min(this.maxAllowedIndex, this.dsResource.initialIndex));
            this.checkRulesTimer = new Timer(RULE_CHECK_INTERVAL);
            this.checkRulesTimer.addEventListener(TimerEvent.TIMER, this.checkRules);
            super.autoSwitch = _arg6;
            this.failedDSI = new Dictionary();
            this.initDSIFailedCounts();
            this._bandwidthLimit = (((1.4 * _arg3.streamItems[(_arg3.streamItems.length - 1)].bitrate) * 1000) / 8);
            _arg2.addEventListener(NetStatusEvent.NET_STATUS, this.onNetStatus);
            NetClient(_arg2.client).addHandler(NetStreamCodes.ON_PLAY_STATUS, this.onPlayStatus, int.MAX_VALUE);
        }
        override public function set autoSwitch(_arg1:Boolean):void{
            super.autoSwitch = _arg1;
            if (_autoSwitch){
                this.checkRulesTimer.start();
            } else {
                this.checkRulesTimer.stop();
            };
        }
        override public function get currentIndex():uint{
            return (this._currentIndex);
        }
        override public function get maxAllowedIndex():int{
            var _local1:int = (this.dsResource.streamItems.length - 1);
            return ((((_local1 < super.maxAllowedIndex)) ? _local1 : super.maxAllowedIndex));
        }
        override public function set maxAllowedIndex(_arg1:int):void{
            if (_arg1 > this.dsResource.streamItems.length){
                throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
            };
            super.maxAllowedIndex = _arg1;
            this.metrics.maxAllowedIndex = _arg1;
        }
        override public function switchTo(_arg1:int):void{
            if (!_autoSwitch){
                if ((((_arg1 < 0)) || ((_arg1 > this.maxAllowedIndex)))){
                    throw (new RangeError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_INVALID_INDEX)));
                };
                if (this.actualIndex == -1){
                    this.prepareForSwitching();
                };
                this.executeSwitch(_arg1);
            } else {
                throw (new IllegalOperationError(OSMFStrings.getString(OSMFStrings.STREAMSWITCH_STREAM_NOT_IN_MANUAL_MODE)));
            };
        }
        protected function canAutoSwitchNow(_arg1:int):Boolean{
            var _local2:int;
            if (this.dsiFailedCounts[_arg1] >= 1){
                _local2 = getTimer();
                if ((_local2 - this.failedDSI[_arg1]) < DEFAULT_WAIT_DURATION_AFTER_DOWN_SWITCH){
                    return (false);
                };
            } else {
                if (this.dsiFailedCounts[_arg1] > DEFAULT_MAX_UP_SWITCHES_PER_STREAM_ITEM){
                    return (false);
                };
            };
            return (true);
        }
        final protected function get bandwidthLimit():Number{
            return (this._bandwidthLimit);
        }
        final protected function set bandwidthLimit(_arg1:Number):void{
            this._bandwidthLimit = _arg1;
        }
        protected function doCheckRules():void{
            this.checkRules(null);
        }
        private function executeSwitch(_arg1:int):void{
            var _local2:NetStreamPlayOptions = new NetStreamPlayOptions();
            var _local3:Object = NetStreamUtils.getPlayArgsForResource(this.dsResource);
            _local2.start = _local3.start;
            _local2.len = _local3.len;
            _local2.streamName = this.dsResource.streamItems[_arg1].streamName;
            var _local4:String = this.oldStreamName;
            if (((!((_local4 == null))) && ((_local4.indexOf("?") >= 0)))){
                _local2.oldStreamName = _local4.substr(0, _local4.indexOf("?"));
            } else {
                _local2.oldStreamName = this.oldStreamName;
            };
            _local2.transition = NetStreamPlayTransitions.SWITCH;
            this.switching = true;
            this.netStream.play2(_local2);
            this.oldStreamName = this.dsResource.streamItems[_arg1].streamName;
            if ((((_arg1 < this.actualIndex)) && (_autoSwitch))){
                this.incrementDSIFailedCount(this.actualIndex);
                this.failedDSI[this.actualIndex] = getTimer();
            };
        }
        private function checkRules(_arg1:TimerEvent):void{
            var _local4:int;
            if ((((((this.switchingRules == null)) || (this.switching))) || ((this.dsResource == null)))){
                return;
            };
            var _local2:int = int.MAX_VALUE;
            var _local3:int;
            while (_local3 < this.switchingRules.length) {
                _local4 = this.switchingRules[_local3].getNewIndex();
                if (((!((_local4 == -1))) && ((_local4 < _local2)))){
                    _local2 = _local4;
                };
                _local3++;
            };
            if (((((!((_local2 == -1))) && (!((_local2 == int.MAX_VALUE))))) && (!((_local2 == this.actualIndex))))){
                _local2 = Math.min(_local2, this.maxAllowedIndex);
            };
            if ((((((_local2 == -1)) || ((_local2 == int.MAX_VALUE)))) && ((this.actualIndex > this.maxAllowedIndex)))){
                _local2 = this.maxAllowedIndex;
            };
            if (((((((((!((_local2 == -1))) && (!((_local2 == int.MAX_VALUE))))) && (!((_local2 == this.actualIndex))))) && (!(this.switching)))) && ((_local2 <= this.maxAllowedIndex)))){
                if (this.actualIndex == -1){
                    this.prepareForSwitching();
                };
                if (this.canAutoSwitchNow(_local2)){
                    this.executeSwitch(_local2);
                };
            };
        }
        private function onNetStatus(_arg1:NetStatusEvent):void{
            switch (_arg1.info.code){
                case NetStreamCodes.NETSTREAM_PLAY_START:
                    if (this.actualIndex == -1){
                        this.prepareForSwitching();
                    } else {
                        if (((_autoSwitch) && ((this.checkRulesTimer.running == false)))){
                            this.checkRulesTimer.start();
                        };
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION:
                    this.actualIndex = this.dsResource.indexFromName(_arg1.info.details);
                    if (this.actualIndex > -1){
                        this.switching = false;
                        this.metrics.currentIndex = this.actualIndex;
                        this.lastTransitionIndex = this.actualIndex;
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_FAILED:
                    this.switching = false;
                    break;
                case NetStreamCodes.NETSTREAM_SEEK_NOTIFY:
                    this.switching = false;
                    if (this.lastTransitionIndex >= 0){
                        this._currentIndex = this.lastTransitionIndex;
                    };
                    break;
                case NetStreamCodes.NETSTREAM_PLAY_STOP:
                    this.checkRulesTimer.stop();
                    break;
            };
        }
        private function onPlayStatus(_arg1:Object):void{
            switch (_arg1.code){
                case NetStreamCodes.NETSTREAM_PLAY_TRANSITION_COMPLETE:
                    if (this.lastTransitionIndex >= 0){
                        this._currentIndex = this.lastTransitionIndex;
                        this.lastTransitionIndex = -1;
                    };
                    break;
            };
        }
        private function prepareForSwitching():void{
            this.initDSIFailedCounts();
            this.metrics.resource = this.dsResource;
            this.actualIndex = 0;
            this.lastTransitionIndex = -1;
            if ((((this.dsResource.initialIndex >= 0)) && ((this.dsResource.initialIndex < this.dsResource.streamItems.length)))){
                this.actualIndex = this.dsResource.initialIndex;
            };
            if (_autoSwitch){
                this.checkRulesTimer.start();
            };
            this.setThrottleLimits((this.dsResource.streamItems.length - 1));
            this.metrics.currentIndex = this.actualIndex;
        }
        private function initDSIFailedCounts():void{
            if (this.dsiFailedCounts != null){
                this.dsiFailedCounts.length = 0;
                this.dsiFailedCounts = null;
            };
            this.dsiFailedCounts = new Vector.<int>();
            var _local1:int;
            while (_local1 < this.dsResource.streamItems.length) {
                this.dsiFailedCounts.push(0);
                _local1++;
            };
        }
        private function incrementDSIFailedCount(_arg1:int):void{
            var _local2 = this.dsiFailedCounts;
            var _local3 = _arg1;
            var _local4 = (_local2[_local3] + 1);
            _local2[_local3] = _local4;
            if (this.dsiFailedCounts[_arg1] > DEFAULT_MAX_UP_SWITCHES_PER_STREAM_ITEM){
                if (this.clearFailedCountsTimer == null){
                    this.clearFailedCountsTimer = new Timer(DEFAULT_CLEAR_FAILED_COUNTS_INTERVAL, 1);
                    this.clearFailedCountsTimer.addEventListener(TimerEvent.TIMER, this.clearFailedCounts);
                };
                this.clearFailedCountsTimer.start();
            };
        }
        private function clearFailedCounts(_arg1:TimerEvent):void{
            this.clearFailedCountsTimer.removeEventListener(TimerEvent.TIMER, this.clearFailedCounts);
            this.clearFailedCountsTimer = null;
            this.initDSIFailedCounts();
        }
        private function setThrottleLimits(_arg1:int):void{
            this.connection.call("setBandwidthLimit", null, this._bandwidthLimit, this._bandwidthLimit);
        }

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public final class NetConnectionCodes {

        public static const CONNECT_CLOSED:String = "NetConnection.Connect.Closed";
        public static const CONNECT_FAILED:String = "NetConnection.Connect.Failed";
        public static const CONNECT_SUCCESS:String = "NetConnection.Connect.Success";
        public static const CONNECT_REJECTED:String = "NetConnection.Connect.Rejected";
        public static const CONNECT_INVALIDAPP:String = "NetConnection.Connect.InvalidApp";
        public static const CONNECT_IDLE_TIME_OUT:String = "NetConnection.Connect.IdleTimeOut";

    }
}//package org.osmf.net 
﻿package org.osmf.net {

    public class SwitchingRuleBase {

        private var _metrics:NetStreamMetricsBase;

        public function SwitchingRuleBase(_arg1:NetStreamMetricsBase){
            this._metrics = _arg1;
        }
        public function getNewIndex():int{
            return (-1);
        }
        protected function get metrics():NetStreamMetricsBase{
            return (this._metrics);
        }

    }
}//package org.osmf.net 
﻿package {
    import org.osmf.events.*;
    import org.osmf.media.*;
    import org.osmf.traits.*;
    import flash.events.*;
    import flash.display.*;
    import flash.net.*;
    import flash.utils.*;
    import flash.system.*;
    import com.neowiz.bugs.player.*;
    import flash.external.*;

    public class BugsNewPlayer extends Sprite {

        private const MAX_PLAYLIST:int = 200;
        private const millisecondsPerMinute:int = 60000;

        private var mod:Number = 0;
        private var volume:int = 50;
        private var path:String = "";
        private var conn:LocalConnection = null;
        private var currTrack:Object;
        private var trackLoader:TrackLoader;
        private var startTime:Number = 0;
        private var eventHandler:String = null;
        private var errorLogCount:int = 0;
        private var so:SharedObject = null;
        private var currentTrackLen:int = 0;
        private var errorRetryCount:int = 0;
        private var isShuffle:Boolean = false;
        private var secureUrl:String = "";
        private var logArr:Array = null;
        private var mediaElement:MediaElement;
        private var usePeeringPortal:Boolean = false;
        private var mediaFactory:DefaultMediaFactory;
        private var urlResource:URLResource;
        private var logType:String = "start";
        private var openType:String = "BUGS";
        private var rtmpe_url_err_cnt:int = 0;
        private var lastMediaPlayTimeLine:Number;
        private var interval_ID:uint = 0;
        private var repeatMode:int = 0;
        private var mediaPlayer:MediaPlayer;
        private var isFirstPlay:Boolean = true;

        public function BugsNewPlayer(){
            this.mediaFactory = new DefaultMediaFactory();
            super();
            Security.allowDomain("*");
            Security.allowInsecureDomain("*");
            if (this.stage){
                this.init();
            } else {
                this.addEventListener(Event.ADDED_TO_STAGE, this.init);
            };
        }
        public function getSavePlayList():String{
            return (this.so.data.playlist);
        }
        public function onMediaErrorHandler(_arg1:MediaErrorEvent):void{
            if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
            };
            this.removeMediaElementErrorEvent(this.mediaPlayer.media);
            this.mediaPlayerErrorHandler(_arg1);
        }
        private function addMediaElementErrorEvent(_arg1:MediaElement):void{
            if (((!((_arg1 == null))) && (!(_arg1.hasEventListener(MediaErrorEvent.MEDIA_ERROR))))){
                _arg1.addEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaErrorHandler);
            };
        }
        private function init():void{
            this.addEventListener(Event.REMOVED_FROM_STAGE, this.clean);
            this.removeEventListener(Event.ADDED_TO_STAGE, this.init);
            this.height = 0;
            this.width = 0;
            if (this.loaderInfo.parameters.eventHandler){
                this.eventHandler = this.loaderInfo.parameters.eventHandler;
            };
            if (this.loaderInfo.parameters.openType){
                this.openType = ((this.loaderInfo.parameters.openType) ? this.loaderInfo.parameters.openType : "BUGS");
            };
            if (this.loaderInfo.parameters.usePeeringPortal){
                this.usePeeringPortal = (((this.loaderInfo.parameters.usePeeringPortal == "Y")) ? true : false);
            };
            this.trackLoader = new TrackLoader(this, ((this.loaderInfo.parameters.requestUrl) ? this.loaderInfo.parameters.requestUrl : "http://localhost:8080/music"), ((this.loaderInfo.parameters.requestOtu) ? this.loaderInfo.parameters.requestOtu : "http://localhost:8080/otu"));
            this.so = SharedObject.getLocal("BugsPlayerPlaylist");
            trace((("SharedObject " + this.so.size) + " bytes"));
            if (this.so.size == 0){
                this.so.data.repeatMode = "0";
                this.so.data.volume = this.volume;
                this.so.flush();
            } else {
                this.isShuffle = this.so.data.isShuffle;
                this.repeatMode = this.so.data.repeatMode;
                this.volume = this.so.data.volume;
            };
            ExternalInterface.addCallback("playTrack", this.playTrack);
            ExternalInterface.addCallback("setVolume", this.setVolume);
            ExternalInterface.addCallback("setRepeatMode", this.setRepeatMode);
            ExternalInterface.addCallback("setShuffle", this.setShuffle);
            ExternalInterface.addCallback("getPlayerInfo", this.getPlayerInfo);
            ExternalInterface.addCallback("playPause", this.playPause);
            ExternalInterface.addCallback("playResume", this.playResume);
            ExternalInterface.addCallback("playSeek", this.playSeek);
            ExternalInterface.addCallback("playSeek2", this.playSeek2);
            ExternalInterface.addCallback("clean", this.clean);
            ExternalInterface.addCallback("duration", this.duration);
            ExternalInterface.addCallback("savePlayList", this.savePlayList);
            ExternalInterface.addCallback("getSavePlayList", this.getSavePlayList);
            ExternalInterface.addCallback("addTrack", this.addTrack);
            this.setMediaPlayer();
            this.addTimeChangeEvent();
            this.conn = new LocalConnection();
            this.conn.allowDomain("*");
            this.conn.allowInsecureDomain("*");
            this.conn.client = this;
            try {
                this.conn.connect("_bugsPlayer");
                trace("[BugsPlayer.initPlaylist] connection open");
                this.fireEvent("init");
            } catch(error:Error) {
                trace("already open");
                fireEvent("alreadyOpen");
            };
        }
        private function removeMediaPlayerErrorEvent():void{
            if (((!((this.mediaPlayer == null))) && (this.mediaPlayer.hasEventListener(MediaErrorEvent.MEDIA_ERROR)))){
                this.mediaPlayer.removeEventListener(MediaErrorEvent.MEDIA_ERROR, this.mediaPlayerErrorHandler);
            };
        }
        private function onCurrentTimeChange(_arg1:TimeEvent):void{
            this.lastMediaPlayTimeLine = _arg1.time;
            this.fireEvent("timepos", _arg1.time, this.mediaPlayer.duration);
            if (this.isFirstPlay){
                this.isFirstPlay = false;
            };
            if (!this.currTrack.paid){
                if (_arg1.time > 60){
                    this.removeMediaPlayerStateChangeEvent();
                    if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                        this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
                    };
                    this.removeMediaElementErrorEvent(this.mediaPlayer.media);
                    this.mediaPlayer.media = null;
                    this.logType = "end";
                    this.playerLog();
                    this.fireEvent("playStop");
                    return;
                };
            };
        }
        public function setVolume(_arg1:int):void{
            this.volume = _arg1;
            this.mediaPlayer.volume = (_arg1 / 100);
            this.so.data.volume = this.volume;
            this.so.flush();
        }
        private function addMediaPlayerStateChangeEvent():void{
            if (((!((this.mediaPlayer == null))) && (!(this.mediaPlayer.hasEventListener(MediaPlayerStateChangeEvent.MEDIA_PLAYER_STATE_CHANGE))))){
                this.mediaPlayer.addEventListener(MediaPlayerStateChangeEvent.MEDIA_PLAYER_STATE_CHANGE, this.mediaPlayerStateChangeEventHandler);
            };
        }
        public function playPause():void{
            if (this.mediaPlayer.canPause){
                this.mediaPlayer.pause();
            };
        }
        private function setMediaPlayer():void{
            this.mediaPlayer = new MediaPlayer();
            this.mediaPlayer.autoPlay = true;
            this.mediaPlayer.autoRewind = false;
            this.mediaPlayer.volume = this.volume;
            this.addMediaPlayerStateChangeEvent();
            this.addMediaplayerErrorEvent();
            this.addTimeCompleteEvent();
            this.addTimeChangeEvent();
        }
        public function fireEvent(_arg1:String, ... _args):void{
            var _local3:Array;
            trace(("[BugsPlayer.fireEvent] " + _arg1));
            if (this.eventHandler){
                _local3 = new Array();
                _local3.push(this.eventHandler);
                _local3.push(_arg1);
                _local3 = _local3.concat(_args);
                ExternalInterface.call.apply(this, _local3);
            };
        }
        private function mediaPlayerPlayStart():void{
            if (this.mediaPlayer.canPlay){
                this.mediaPlayer.play();
            };
        }
        public function addTrack(_arg1:String, _arg2:Boolean=false):void{
            this.addTracks(_arg1, _arg2);
        }
        public function setShuffle(_arg1:Boolean):void{
            trace(("isShuffle : " + _arg1));
            this.so.data.isShuffle = _arg1;
            this.so.flush();
        }
        public function getPlayerInfo():Object{
            var _local1:Object = new Object();
            _local1.isShuffle = this.isShuffle;
            _local1.repeatMode = this.so.data.repeatMode;
            _local1.volume = this.volume;
            _local1.isPlaying = this.mediaPlayer.playing;
            if (!this.usePeeringPortal){
                _local1.timepos = this.timepos();
                _local1.duration = this.duration();
            };
            return (_local1);
        }
        private function onDurationReached(_arg1:TimeEvent):void{
            trace("timeComplete!!");
            if (this.currTrack.paid){
                if ((this.mediaPlayer.duration - this.lastMediaPlayTimeLine) > 15){
                    trace("p => media duration len err");
                    this.fireEvent("mediaDurationError", "trackId");
                };
            } else {
                if (this.currentTrackLen < 60){
                    if ((this.currentTrackLen - this.lastMediaPlayTimeLine) > 15){
                        this.fireEvent("mediaDurationError", "trackId");
                    };
                } else {
                    if ((60 - this.lastMediaPlayTimeLine) > 15){
                        trace("np => media duration len err");
                        this.fireEvent("mediaDurationError", "trackId");
                    };
                };
            };
            if (this.currTrack.paid){
                ExternalInterface.call(this.eventHandler, "listenLog");
            };
            this.logType = "end";
            this.playerLog();
            if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
            };
            this.removeMediaPlayerStateChangeEvent();
            this.removeMediaElementErrorEvent(this.mediaPlayer.media);
            this.mediaPlayer.media = null;
            this.fireEvent("playStop");
        }
        public function clean():void{
            if (!this.usePeeringPortal){
                if (this.logType == "start"){
                    this.logType = "end";
                    if (this.currTrack != null){
                        this.playerLog();
                    };
                };
            };
            if (this.conn){
                try {
                    this.conn.close();
                } catch(e:Error) {
                };
            };
        }
        private function removeLoadTraitEvent(_arg1:LoadTrait):void{
            if (((!((_arg1 == null))) && (_arg1.hasEventListener(LoadEvent.LOAD_STATE_CHANGE)))){
                _arg1.removeEventListener(LoadEvent.LOAD_STATE_CHANGE, this.onLoadStateChange);
            };
        }
        private function removeMediaPlayerStateChangeEvent():void{
            if (((!((this.mediaPlayer == null))) && (this.mediaPlayer.hasEventListener(MediaPlayerStateChangeEvent.MEDIA_PLAYER_STATE_CHANGE)))){
                this.mediaPlayer.removeEventListener(MediaPlayerStateChangeEvent.MEDIA_PLAYER_STATE_CHANGE, this.mediaPlayerStateChangeEventHandler);
            };
        }
        public function getURLResource(_arg1:String):void{
            this.trackLoader.getSecureUrl(_arg1, this.callLoadMedia);
        }
        public function timepos():int{
            return (((this.mediaPlayer)!=null) ? this.mediaPlayer.currentTime : 0);
        }
        private function addTimeCompleteEvent():void{
            if (((!((this.mediaPlayer == null))) && (!(this.mediaPlayer.hasEventListener(TimeEvent.COMPLETE))))){
                this.mediaPlayer.addEventListener(TimeEvent.COMPLETE, this.onDurationReached);
            };
        }
        public function playTrack(_arg1:String):void{
            var trackId:* = _arg1;
            trace(("=======> playTrack = " + trackId));
            if (((!(this.isFirstPlay)) && ((this.logType == "start")))){
                this.logType = "end";
                this.playerLog();
            };
            if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
                this.removeMediaElementErrorEvent(this.mediaPlayer.media);
                this.mediaElement = null;
                this.mediaPlayer.media = null;
            };
            this.removeMediaPlayerStateChangeEvent();
            this.trackLoader.getTrack(trackId, function (_arg1:Object):void{
                var _local2:String;
                trace(("trackStrRights : " + _arg1.track.trackStrRights));
                currTrack = _arg1;
                currentTrackLen = 0;
                _local2 = _arg1.track.len.split(":");
                if (_local2.length == 1){
                    currentTrackLen = int(_local2[0]);
                } else {
                    if (_local2.length == 2){
                        currentTrackLen = (int(_local2[0]) * 60);
                        currentTrackLen = (currentTrackLen + int(_local2[1]));
                    };
                };
                if (!_arg1.track.trackStrRights){
                    return;
                };
                getURLResource(_arg1.track.track_id);
            });
        }
        public function ping():void{
        }
        public function playResume():void{
            if (this.mediaPlayer.playing){
                this.mediaPlayer.pause();
            } else {
                if (this.mediaPlayer.media == null){
                    this.playTrack(this.currTrack.track.track_id);
                } else {
                    this.mediaPlayerPlayStart();
                };
            };
        }
        public function loadMediaInterval():void{
            clearTimeout(this.interval_ID);
            this.loadMedia(arguments[0]);
        }
        public function addTracks(_arg1:String, _arg2:Boolean=false):void{
            this.fireEvent("playlistAdded", _arg1, _arg2);
        }
        public function savePlayList(_arg1:String):Boolean{
            this.so.data.playlist = _arg1;
            this.so.flush();
            return (true);
        }
        public function duration():int{
            if (this.currTrack == null){
                return (60);
            };
            if (!this.currTrack.paid){
                return (60);
            };
            return (this.mediaPlayer.duration);
        }
        private function removeTimeChangeEvent():void{
            if (((!((this.mediaPlayer == null))) && (this.mediaPlayer.hasEventListener(TimeEvent.CURRENT_TIME_CHANGE)))){
                this.mediaPlayer.removeEventListener(TimeEvent.CURRENT_TIME_CHANGE, this.onCurrentTimeChange);
            };
        }
        public function playerLog():void{
            this.logArr = null;
            this.logArr = [];
            if (this.logType == "start"){
                this.logArr.push("start");
            } else {
                this.logArr.push("end");
            };
            this.logArr.push(this.currTrack.msrl);
            this.mod = (Number(this.currTrack.track.track_id) % 1000);
            if (this.mod < 10){
                this.path = ("00" + this.mod);
            } else {
                if (this.mod < 100){
                    this.path = ("0" + this.mod);
                } else {
                    this.path = this.mod.toString();
                };
            };
            this.logArr.push((((("aod.bugs.gscdn.com/mp3/" + this.path) + "/") + this.currTrack.track.track_id) + ".mp3"));
            this.logArr.push(this.currTrack.svcId);
            if (this.currTrack.msrl == "0"){
                this.logArr.push("F");
            } else {
                this.logArr.push((((((this.currTrack.svcId.indexOf("E") > -1)) || ((this.currTrack.svcId.indexOf("F") > -1)))) ? "F" : "B"));
            };
            this.logArr.push("#clientIp#");
            this.logArr.push("#clientIp#");
            if (this.logType == "start"){
                this.startTime = (getTimer() + this.millisecondsPerMinute);
                this.logArr.push("0");
            } else {
                this.logArr.push(((getTimer() + this.millisecondsPerMinute) - this.startTime));
            };
            this.logArr.push((this.currentTrackLen * 1000).toString());
            this.logArr.push("");
            this.logArr.push(this.openType);
            this.logArr.push(this.currTrack.pssrl);
            if (this.logType != "start"){
                if (!isNaN(this.currentTrackLen)){
                    this.trackLoader.setLog(this.logArr.join("\t"));
                };
            };
            if (this.logType != "start"){
                this.startTime = 0;
            };
        }
        public function loadMedia(_arg1:String):void{
            trace("===============================================>>      loadMedia!!!!!!!!!  ");
            this.secureUrl = _arg1;
            this.addMediaPlayerStateChangeEvent();
            if (this.urlResource != null){
                this.urlResource = null;
            };
            if (((!((this.mediaPlayer == null))) && (this.mediaPlayer.canPause))){
                this.mediaPlayer.stop();
            };
            this.urlResource = new URLResource(_arg1);
            if (this.mediaElement != null){
                this.mediaElement = null;
            };
            this.mediaElement = this.mediaFactory.createMediaElement(this.urlResource);
            this.addLoadTraitEvent((this.mediaElement.getTrait(MediaTraitType.LOAD) as LoadTrait));
            if (this.mediaElement == null){
                trace("RTMPE URL ERROR!!!");
                this.logType = "end";
                this.playerLog();
                this.removeMediaPlayerStateChangeEvent();
                if (this.rtmpe_url_err_cnt < 9){
                    this.rtmpe_url_err_cnt++;
                    this.getURLResource(this.currTrack.track.track_id);
                } else {
                    this.rtmpe_url_err_cnt = 0;
                };
                ExternalInterface.call(this.eventHandler, "rtmpe_url_error");
                return;
            };
            this.mediaPlayer.media = this.mediaElement;
            this.addMediaElementErrorEvent(this.mediaPlayer.media);
            this.mediaElement = null;
            this.urlResource = null;
        }
        private function mediaPlayerErrorHandler(_arg1:MediaErrorEvent=null):void{
            trace("=======================================================");
            trace("            mediaPlayerErrorHandler");
            if (_arg1 != null){
                trace(("mediaPlayerErrorHandler : " + _arg1.error.errorID));
                trace(("mediaPlayerErrorHandler : " + _arg1.error.message));
                trace(("mediaPlayerErrorHandler : " + _arg1.error.detail));
                trace(("mediaPlayerErrorHandler : " + _arg1.error.getStackTrace()));
            };
            trace("=======================================================");
            this.logType = "end";
            this.errorRetryCount++;
            if (((this.eventHandler) && ((this.errorRetryCount >= 2)))){
                this.errorRetryCount = 0;
                if (_arg1 != null){
                    this.fireEvent("mediaError", _arg1.error.errorID);
                };
                this.errorLogCount++;
                this.cleanMediaPlayer();
                this.setMediaPlayer();
                if (this.errorLogCount >= 9){
                    this.errorLogCount = 0;
                    return;
                };
                this.fireEvent(this.eventHandler, "playStop");
            } else {
                this.cleanMediaPlayer();
                this.setMediaPlayer();
                this.interval_ID = setTimeout(this.loadMediaInterval, 500, this.secureUrl);
            };
        }
        private function addLoadTraitEvent(_arg1:LoadTrait):void{
            if (((!((_arg1 == null))) && (!(_arg1.hasEventListener(LoadEvent.LOAD_STATE_CHANGE))))){
                _arg1.addEventListener(LoadEvent.LOAD_STATE_CHANGE, this.onLoadStateChange);
            };
        }
        private function removeMediaElementErrorEvent(_arg1:MediaElement):void{
            if (((!((_arg1 == null))) && (_arg1.hasEventListener(MediaErrorEvent.MEDIA_ERROR)))){
                _arg1.removeEventListener(MediaErrorEvent.MEDIA_ERROR, this.onMediaErrorHandler);
            };
        }
        public function playSeek(_arg1:Number):void{
            var _local2:Number;
            if ((((this.mediaPlayer == null)) || (!(this.mediaPlayer.canSeek)))){
                return;
            };
            if (this.mediaPlayer.media != null){
                this.mediaPlayer.currentTime;
                this.mediaPlayer.duration;
                if (this.mediaPlayer.duration == -1){
                    return;
                };
                if (this.currTrack.paid){
                    _local2 = this.mediaPlayer.duration;
                    if ((_local2 - 1.5) <= (_local2 * _arg1)){
                        this.mediaPlayer.seek((_local2 - 1.5));
                    } else {
                        this.mediaPlayer.seek((_local2 * _arg1));
                    };
                } else {
                    if (58 <= (60 * _arg1)){
                        this.mediaPlayer.seek(58.5);
                    } else {
                        this.mediaPlayer.seek((60 * _arg1));
                    };
                };
            };
        }
        private function cleanMediaPlayer():void{
            if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
            };
            if (this.mediaPlayer != null){
                this.removeMediaElementErrorEvent(this.mediaPlayer.media);
            };
            this.removeMediaPlayerStateChangeEvent();
            this.removeTimeCompleteEvent();
            this.removeTimeChangeEvent();
            this.removeMediaPlayerErrorEvent();
            this.urlResource = null;
            this.mediaElement = null;
            this.mediaPlayer.media = null;
            if (this.mediaPlayer != null){
                this.mediaPlayer = null;
            };
        }
        public function callLoadMedia(_arg1:String):void{
            if (_arg1 == ""){
            } else {
                this.fireEvent("playTrackChange");
                this.loadMedia(_arg1);
            };
        }
        private function addTimeChangeEvent():void{
            if (((!((this.mediaPlayer == null))) && (!(this.mediaPlayer.hasEventListener(TimeEvent.CURRENT_TIME_CHANGE))))){
                this.mediaPlayer.addEventListener(TimeEvent.CURRENT_TIME_CHANGE, this.onCurrentTimeChange);
            };
        }
        public function playSeek2(_arg1:Number):void{
            var _local2:Number;
            if ((((this.mediaPlayer == null)) || (!(this.mediaPlayer.canSeek)))){
                return;
            };
            if (this.mediaPlayer.media != null){
                this.mediaPlayer.currentTime;
                this.mediaPlayer.duration;
                if (this.mediaPlayer.duration == -1){
                    return;
                };
                if (this.currTrack.paid){
                    _local2 = this.mediaPlayer.duration;
                    if ((_local2 - 1.5) <= _arg1){
                        this.mediaPlayer.seek((_arg1 - 1.5));
                    } else {
                        this.mediaPlayer.seek(_arg1);
                    };
                } else {
                    if (60 >= _arg1){
                        this.mediaPlayer.seek(58.5);
                    } else {
                        this.mediaPlayer.seek(60);
                    };
                };
            };
        }
        public function setRepeatMode(_arg1:int):void{
            trace(("repeatMode : " + _arg1));
            this.so.data.repeatMode = _arg1;
            this.so.flush();
        }
        private function removeTimeCompleteEvent():void{
            if (((!((this.mediaPlayer == null))) && (this.mediaPlayer.hasEventListener(TimeEvent.COMPLETE)))){
                this.mediaPlayer.removeEventListener(TimeEvent.COMPLETE, this.onDurationReached);
            };
        }
        private function mediaPlayerStateChangeEventHandler(_arg1:MediaPlayerStateChangeEvent):void{
            switch (_arg1.state){
                case MediaPlayerState.READY:
                    break;
                case MediaPlayerState.PLAYING:
                    this.mediaPlayer.bufferTime = 7;
                    this.currentTrackLen = (int((this.currTrack.track.len.substr(0, 2) * 60)) + int(this.currTrack.track.len.substr(3, 5)));
                    this.logType = "start";
                    this.playerLog();
                    break;
                case MediaPlayerState.PAUSED:
                    break;
                case MediaPlayerState.BUFFERING:
                    break;
                case MediaPlayerState.LOADING:
                    break;
                case MediaPlayerState.PLAYBACK_ERROR:
                    trace("MediaplayerState.PLAYBACK_ERROR!!!!!!!!!!!!!!!!!!");
                    break;
            };
        }
        private function addMediaplayerErrorEvent():void{
            if (((!((this.mediaPlayer == null))) && (!(this.mediaPlayer.hasEventListener(MediaErrorEvent.MEDIA_ERROR))))){
                this.mediaPlayer.addEventListener(MediaErrorEvent.MEDIA_ERROR, this.mediaPlayerErrorHandler);
            };
        }
        public function onLoadStateChange(_arg1:LoadEvent):void{
            if (_arg1.loadState == LoadState.READY){
                if (this.mediaPlayer.canPlay){
                    this.mediaPlayer.play();
                    this.mediaPlayer.bufferTime = 5;
                };
                if (((!((this.mediaPlayer == null))) && (!((this.mediaPlayer.media == null))))){
                    this.removeLoadTraitEvent((this.mediaPlayer.media.getTrait(MediaTraitType.LOAD) as LoadTrait));
                };
                this.removeMediaElementErrorEvent(this.mediaPlayer.media);
                this.removeMediaPlayerStateChangeEvent();
            };
            trace(("onLoadStateChange " + _arg1.loadState));
        }

    }
}//package 
﻿package com.adobe.serialization.json {

    public class JSONToken {

        private var _value:Object;
        private var _type:int;

        public function JSONToken(_arg1:int=-1, _arg2:Object=null){
            _type = _arg1;
            _value = _arg2;
        }
        public function get value():Object{
            return (_value);
        }
        public function get type():int{
            return (_type);
        }
        public function set type(_arg1:int):void{
            _type = _arg1;
        }
        public function set value(_arg1:Object):void{
            _value = _arg1;
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {
    import flash.utils.*;

    public class JSONEncoder {

        private var jsonString:String;

        public function JSONEncoder(_arg1){
            jsonString = convertToString(_arg1);
        }
        private function escapeString(_arg1:String):String{
            var _local3:String;
            var _local6:String;
            var _local7:String;
            var _local2 = "";
            var _local4:Number = _arg1.length;
            var _local5:int;
            while (_local5 < _local4) {
                _local3 = _arg1.charAt(_local5);
                switch (_local3){
                    case "\"":
                        _local2 = (_local2 + "\\\"");
                        break;
                    case "\\":
                        _local2 = (_local2 + "\\\\");
                        break;
                    case "\b":
                        _local2 = (_local2 + "\\b");
                        break;
                    case "\f":
                        _local2 = (_local2 + "\\f");
                        break;
                    case "\n":
                        _local2 = (_local2 + "\\n");
                        break;
                    case "\r":
                        _local2 = (_local2 + "\\r");
                        break;
                    case "\t":
                        _local2 = (_local2 + "\\t");
                        break;
                    default:
                        if (_local3 < " "){
                            _local6 = _local3.charCodeAt(0).toString(16);
                            _local7 = (((_local6.length == 2)) ? "00" : "000");
                            _local2 = (_local2 + (("\\u" + _local7) + _local6));
                        } else {
                            _local2 = (_local2 + _local3);
                        };
                };
                _local5++;
            };
            return ((("\"" + _local2) + "\""));
        }
        private function arrayToString(_arg1:Array):String{
            var _local2 = "";
            var _local3:int;
            while (_local3 < _arg1.length) {
                if (_local2.length > 0){
                    _local2 = (_local2 + ",");
                };
                _local2 = (_local2 + convertToString(_arg1[_local3]));
                _local3++;
            };
            return ((("[" + _local2) + "]"));
        }
        public function getString():String{
            return (jsonString);
        }
        private function objectToString(_arg1:Object):String{
            var value:* = null;
            var key:* = null;
            var v:* = null;
            var o:* = _arg1;
            var s:* = "";
            var classInfo:* = describeType(o);
            if (classInfo.@name.toString() == "Object"){
                for (key in o) {
                    value = o[key];
                    if ((value is Function)){
                    } else {
                        if (s.length > 0){
                            s = (s + ",");
                        };
                        s = (s + ((escapeString(key) + ":") + convertToString(value)));
                    };
                };
            } else {
                for each (v in classInfo..*.(((name() == "variable")) || ((name() == "accessor")))) {
                    if (s.length > 0){
                        s = (s + ",");
                    };
                    s = (s + ((escapeString(v.@name.toString()) + ":") + convertToString(o[v.@name])));
                };
            };
            return ((("{" + s) + "}"));
        }
        private function convertToString(_arg1):String{
            if ((_arg1 is String)){
                return (escapeString((_arg1 as String)));
            };
            if ((_arg1 is Number)){
                return (((isFinite((_arg1 as Number))) ? _arg1.toString() : "null"));
            };
            if ((_arg1 is Boolean)){
                return (((_arg1) ? "true" : "false"));
            };
            if ((_arg1 is Array)){
                return (arrayToString((_arg1 as Array)));
            };
            if ((((_arg1 is Object)) && (!((_arg1 == null))))){
                return (objectToString(_arg1));
            };
            return ("null");
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONParseError extends Error {

        private var _location:int;
        private var _text:String;

        public function JSONParseError(_arg1:String="", _arg2:int=0, _arg3:String=""){
            super(_arg1);
            name = "JSONParseError";
            _location = _arg2;
            _text = _arg3;
        }
        public function get location():int{
            return (_location);
        }
        public function get text():String{
            return (_text);
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONTokenizer {

        private var loc:int;
        private var ch:String;
        private var obj:Object;
        private var jsonString:String;

        public function JSONTokenizer(_arg1:String){
            jsonString = _arg1;
            loc = 0;
            nextChar();
        }
        private function skipComments():void{
            if (ch == "/"){
                nextChar();
                switch (ch){
                    case "/":
                        do  {
                            nextChar();
                        } while (((!((ch == "\n"))) && (!((ch == "")))));
                        nextChar();
                        break;
                    case "*":
                        nextChar();
                        while (true) {
                            if (ch == "*"){
                                nextChar();
                                if (ch == "/"){
                                    nextChar();
                                    break;
                                };
                            } else {
                                nextChar();
                            };
                            if (ch == ""){
                                parseError("Multi-line comment not closed");
                            };
                        };
                        break;
                    default:
                        parseError((("Unexpected " + ch) + " encountered (expecting '/' or '*' )"));
                };
            };
        }
        private function isDigit(_arg1:String):Boolean{
            return ((((_arg1 >= "0")) && ((_arg1 <= "9"))));
        }
        private function readString():JSONToken{
            var _local3:String;
            var _local4:int;
            var _local1:JSONToken = new JSONToken();
            _local1.type = JSONTokenType.STRING;
            var _local2 = "";
            nextChar();
            while (((!((ch == "\""))) && (!((ch == ""))))) {
                if (ch == "\\"){
                    nextChar();
                    switch (ch){
                        case "\"":
                            _local2 = (_local2 + "\"");
                            break;
                        case "/":
                            _local2 = (_local2 + "/");
                            break;
                        case "\\":
                            _local2 = (_local2 + "\\");
                            break;
                        case "b":
                            _local2 = (_local2 + "\b");
                            break;
                        case "f":
                            _local2 = (_local2 + "\f");
                            break;
                        case "n":
                            _local2 = (_local2 + "\n");
                            break;
                        case "r":
                            _local2 = (_local2 + "\r");
                            break;
                        case "t":
                            _local2 = (_local2 + "\t");
                            break;
                        case "u":
                            _local3 = "";
                            _local4 = 0;
                            while (_local4 < 4) {
                                if (!isHexDigit(nextChar())){
                                    parseError((" Excepted a hex digit, but found: " + ch));
                                };
                                _local3 = (_local3 + ch);
                                _local4++;
                            };
                            _local2 = (_local2 + String.fromCharCode(parseInt(_local3, 16)));
                            break;
                        default:
                            _local2 = (_local2 + ("\\" + ch));
                    };
                } else {
                    _local2 = (_local2 + ch);
                };
                nextChar();
            };
            if (ch == ""){
                parseError("Unterminated string literal");
            };
            nextChar();
            _local1.value = _local2;
            return (_local1);
        }
        private function nextChar():String{
            return ((ch = jsonString.charAt(loc++)));
        }
        public function getNextToken():JSONToken{
            var _local2:String;
            var _local3:String;
            var _local4:String;
            var _local1:JSONToken = new JSONToken();
            skipIgnored();
            switch (ch){
                case "{":
                    _local1.type = JSONTokenType.LEFT_BRACE;
                    _local1.value = "{";
                    nextChar();
                    break;
                case "}":
                    _local1.type = JSONTokenType.RIGHT_BRACE;
                    _local1.value = "}";
                    nextChar();
                    break;
                case "[":
                    _local1.type = JSONTokenType.LEFT_BRACKET;
                    _local1.value = "[";
                    nextChar();
                    break;
                case "]":
                    _local1.type = JSONTokenType.RIGHT_BRACKET;
                    _local1.value = "]";
                    nextChar();
                    break;
                case ",":
                    _local1.type = JSONTokenType.COMMA;
                    _local1.value = ",";
                    nextChar();
                    break;
                case ":":
                    _local1.type = JSONTokenType.COLON;
                    _local1.value = ":";
                    nextChar();
                    break;
                case "t":
                    _local2 = ((("t" + nextChar()) + nextChar()) + nextChar());
                    if (_local2 == "true"){
                        _local1.type = JSONTokenType.TRUE;
                        _local1.value = true;
                        nextChar();
                    } else {
                        parseError(("Expecting 'true' but found " + _local2));
                    };
                    break;
                case "f":
                    _local3 = (((("f" + nextChar()) + nextChar()) + nextChar()) + nextChar());
                    if (_local3 == "false"){
                        _local1.type = JSONTokenType.FALSE;
                        _local1.value = false;
                        nextChar();
                    } else {
                        parseError(("Expecting 'false' but found " + _local3));
                    };
                    break;
                case "n":
                    _local4 = ((("n" + nextChar()) + nextChar()) + nextChar());
                    if (_local4 == "null"){
                        _local1.type = JSONTokenType.NULL;
                        _local1.value = null;
                        nextChar();
                    } else {
                        parseError(("Expecting 'null' but found " + _local4));
                    };
                    break;
                case "\"":
                    _local1 = readString();
                    break;
                default:
                    if (((isDigit(ch)) || ((ch == "-")))){
                        _local1 = readNumber();
                    } else {
                        if (ch == ""){
                            return (null);
                        };
                        parseError((("Unexpected " + ch) + " encountered"));
                    };
            };
            return (_local1);
        }
        private function skipWhite():void{
            while (isWhiteSpace(ch)) {
                nextChar();
            };
        }
        public function parseError(_arg1:String):void{
            throw (new JSONParseError(_arg1, loc, jsonString));
        }
        private function isWhiteSpace(_arg1:String):Boolean{
            return ((((((((_arg1 == " ")) || ((_arg1 == "\t")))) || ((_arg1 == "\n")))) || ((_arg1 == "\r"))));
        }
        private function skipIgnored():void{
            var _local1:int;
            do  {
                _local1 = loc;
                skipWhite();
                skipComments();
            } while (_local1 != loc);
        }
        private function isHexDigit(_arg1:String):Boolean{
            var _local2:String = _arg1.toUpperCase();
            return (((isDigit(_arg1)) || ((((_local2 >= "A")) && ((_local2 <= "F"))))));
        }
        private function readNumber():JSONToken{
            var _local1:JSONToken = new JSONToken();
            _local1.type = JSONTokenType.NUMBER;
            var _local2 = "";
            if (ch == "-"){
                _local2 = (_local2 + "-");
                nextChar();
            };
            if (!isDigit(ch)){
                parseError("Expecting a digit");
            };
            if (ch == "0"){
                _local2 = (_local2 + ch);
                nextChar();
                if (isDigit(ch)){
                    parseError("A digit cannot immediately follow 0");
                };
            } else {
                while (isDigit(ch)) {
                    _local2 = (_local2 + ch);
                    nextChar();
                };
            };
            if (ch == "."){
                _local2 = (_local2 + ".");
                nextChar();
                if (!isDigit(ch)){
                    parseError("Expecting a digit");
                };
                while (isDigit(ch)) {
                    _local2 = (_local2 + ch);
                    nextChar();
                };
            };
            if ((((ch == "e")) || ((ch == "E")))){
                _local2 = (_local2 + "e");
                nextChar();
                if ((((ch == "+")) || ((ch == "-")))){
                    _local2 = (_local2 + ch);
                    nextChar();
                };
                if (!isDigit(ch)){
                    parseError("Scientific notation number needs exponent value");
                };
                while (isDigit(ch)) {
                    _local2 = (_local2 + ch);
                    nextChar();
                };
            };
            var _local3:Number = Number(_local2);
            if (((isFinite(_local3)) && (!(isNaN(_local3))))){
                _local1.value = _local3;
                return (_local1);
            };
            parseError((("Number " + _local3) + " is not valid!"));
            return (null);
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONTokenType {

        public static const NUMBER:int = 11;
        public static const FALSE:int = 8;
        public static const RIGHT_BRACKET:int = 4;
        public static const NULL:int = 9;
        public static const TRUE:int = 7;
        public static const RIGHT_BRACE:int = 2;
        public static const UNKNOWN:int = -1;
        public static const COMMA:int = 0;
        public static const LEFT_BRACKET:int = 3;
        public static const STRING:int = 10;
        public static const LEFT_BRACE:int = 1;
        public static const COLON:int = 6;

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSONDecoder {

        private var value;
        private var tokenizer:JSONTokenizer;
        private var token:JSONToken;

        public function JSONDecoder(_arg1:String){
            tokenizer = new JSONTokenizer(_arg1);
            nextToken();
            value = parseValue();
        }
        private function parseObject():Object{
            var _local2:String;
            var _local1:Object = new Object();
            nextToken();
            if (token.type == JSONTokenType.RIGHT_BRACE){
                return (_local1);
            };
            if (token.type == JSONTokenType.STRING){
                _local2 = String(token.value);
                nextToken();
                if (token.type == JSONTokenType.COLON){
                    nextToken();
                    _local1[_local2] = parseValue();
                    nextToken();
                    if (token.type == JSONTokenType.RIGHT_BRACE){
                        return (_local1);
                    };
                    if (token.type == JSONTokenType.COMMA){
                        nextToken();
                    } else {
                        tokenizer.parseError(("Expecting } or , but found " + token.value));
                    };
                } else {
                    tokenizer.parseError(("Expecting : but found " + token.value));
                };
            } else {
                tokenizer.parseError(("Expecting string but found " + token.value));
            };
            //unresolved jump
        }
        private function parseValue():Object{
            if (token == null){
                tokenizer.parseError("Unexpected end of input");
            };
            switch (token.type){
                case JSONTokenType.LEFT_BRACE:
                    return (parseObject());
                case JSONTokenType.LEFT_BRACKET:
                    return (parseArray());
                case JSONTokenType.STRING:
                case JSONTokenType.NUMBER:
                case JSONTokenType.TRUE:
                case JSONTokenType.FALSE:
                case JSONTokenType.NULL:
                    return (token.value);
                default:
                    tokenizer.parseError(("Unexpected " + token.value));
            };
            return (null);
        }
        private function nextToken():JSONToken{
            return ((token = tokenizer.getNextToken()));
        }
        public function getValue(){
            return (value);
        }
        private function parseArray():Array{
            var _local1:Array = new Array();
            nextToken();
            if (token.type == JSONTokenType.RIGHT_BRACKET){
                return (_local1);
            };
            _local1.push(parseValue());
            nextToken();
            if (token.type == JSONTokenType.RIGHT_BRACKET){
                return (_local1);
            };
            if (token.type == JSONTokenType.COMMA){
                nextToken();
            } else {
                tokenizer.parseError(("Expecting ] or , but found " + token.value));
            };
            //unresolved jump
        }

    }
}//package com.adobe.serialization.json 
﻿package com.adobe.serialization.json {

    public class JSON {

        public static function decode(_arg1:String){
            var _local2:JSONDecoder = new JSONDecoder(_arg1);
            return (_local2.getValue());
        }
        public static function encode(_arg1:Object):String{
            var _local2:JSONEncoder = new JSONEncoder(_arg1);
            return (_local2.getString());
        }

    }
}//package com.adobe.serialization.json 
﻿package com.neowiz.bugs.player {
    import flash.events.*;
    import flash.net.*;
    import com.adobe.serialization.json.*;

    public class TrackLoader {

        private var size:int = 0;
        private var retryCount:int = 0;
        private var logUrl:String = "http://stlog.bugs.co.kr/newPlayer/log";
        private var request:URLRequest;
        private var loader:URLLoader;
        private var secureUrlCallbackFunction:Function;
        private var requestUrl:String;
        private var player:Object;
        private var secureUrlLoader:URLLoader;
        private var secureUrlRequet:URLRequest;
        private var data:String = "";
        private var logRequest:URLRequest;
        private var logLoader:URLLoader;
        private var secureUrl:String = "http://localhost:8080/otu/newPlayer/secureUrl";
        private var isSuccess:Boolean = true;
        private var logData:URLVariables;
        private var callbackFunction:Function;
        private var obj:Object;

        public function TrackLoader(_arg1:Object, _arg2:String, _arg3:String){
            var player:* = _arg1;
            var requestUrl:* = _arg2;
            var requestOtu:* = _arg3;
            this.request = new URLRequest();
            this.loader = new URLLoader();
            this.secureUrlRequet = new URLRequest();
            this.secureUrlLoader = new URLLoader();
            this.logRequest = new URLRequest();
            this.logLoader = new URLLoader();
            this.logData = new URLVariables();
            super();
            this.player = player;
            this.requestUrl = (requestUrl + "/player");
            this.secureUrl = (requestOtu + "/newPlayer/secureUrl");
            if (!this.loader.hasEventListener(HTTPStatusEvent.HTTP_STATUS)){
                this.loader.addEventListener(HTTPStatusEvent.HTTP_STATUS, function (_arg1:HTTPStatusEvent):void{
                    trace(("http status " + _arg1.status));
                });
            };
            if (!this.loader.hasEventListener(IOErrorEvent.IO_ERROR)){
                this.loader.addEventListener(IOErrorEvent.IO_ERROR, function (_arg1:Event):void{
                    trace("IO_ERROR");
                });
            };
            if (!this.logLoader.hasEventListener(HTTPStatusEvent.HTTP_STATUS)){
                this.logLoader.addEventListener(HTTPStatusEvent.HTTP_STATUS, function (_arg1:HTTPStatusEvent):void{
                    trace(("http status loaderLog" + _arg1.status));
                });
            };
            if (!this.logLoader.hasEventListener(IOErrorEvent.IO_ERROR)){
                this.logLoader.addEventListener(IOErrorEvent.IO_ERROR, function (_arg1:Event):void{
                    trace("IO_ERROR loaderLog");
                });
            };
            if (!this.secureUrlLoader.hasEventListener(HTTPStatusEvent.HTTP_STATUS)){
                this.secureUrlLoader.addEventListener(HTTPStatusEvent.HTTP_STATUS, function (_arg1:HTTPStatusEvent):void{
                    trace(("http status loader secureUrl" + _arg1.status));
                });
            };
            if (!this.secureUrlLoader.hasEventListener(IOErrorEvent.IO_ERROR)){
                this.secureUrlLoader.addEventListener(IOErrorEvent.IO_ERROR, function (_arg1:Event):void{
                    (player as BugsNewPlayer).fireEvent("otuIOError");
                    trace("IO_ERROR loader secureUrl");
                });
            };
        }
        public function getSecureUrl(_arg1:String, _arg2:Function=null):void{
            this.secureUrlRequet.url = ((this.secureUrl + "?track_id=") + _arg1);
            this.secureUrlRequet.method = URLRequestMethod.GET;
            trace(("*********************** getSecureUrl ***********************" + _arg1));
            this.loadSecureUrl(_arg2);
        }
        public function setLog(_arg1:String):void{
            var logStr:* = _arg1;
            try {
                this.logRequest.url = this.logUrl;
                this.logRequest.method = URLRequestMethod.POST;
                this.logData.logStr = logStr;
                this.logRequest.data = this.logData;
                this.logLoader.load(this.logRequest);
            } catch(e:Error) {
                trace("log error");
            };
        }
        public function loadSecureUrl(_arg1:Function=null):void{
            this.secureUrlCallbackFunction = _arg1;
            if (!this.secureUrlLoader.hasEventListener(Event.COMPLETE)){
                this.secureUrlLoader.addEventListener(Event.COMPLETE, this.loadSecureUrlHandler);
            };
            this.secureUrlLoader.load(this.secureUrlRequet);
        }
        public function getTrack(_arg1:String, _arg2:Function=null):void{
            this.request.url = ((this.requestUrl + "/track/") + _arg1);
            this.request.method = URLRequestMethod.GET;
            trace(("*********************** getTrack ***********************" + _arg1));
            this.loadTrackData(this.request, _arg2);
        }
        public function loadTrackData(_arg1:URLRequest, _arg2:Function=null):void{
            this.callbackFunction = _arg2;
            if (!this.loader.hasEventListener(Event.COMPLETE)){
                this.loader.addEventListener(Event.COMPLETE, this.loadTrackDataHandler);
            };
            this.loader.load(_arg1);
        }
        public function loadTrackDataHandler(_arg1:Event):void{
            var e:* = _arg1;
            trace("getTrack Event.COMPLETE");
            try {
                this.obj = JSON.decode((e.target as URLLoader).data);
                if (this.callbackFunction != null){
                    this.callbackFunction.call(this.player, this.obj);
                };
                this.isSuccess = true;
            } catch(error:Error) {
                retryCount++;
                isSuccess = false;
                if (retryCount < 3){
                    loader.load(request);
                } else {
                    callbackFunction = null;
                    loader.close();
                    (player as BugsNewPlayer).fireEvent("jsonDataError");
                };
                trace(error.message);
                trace("JSON parse error");
            } finally {
                this.obj = null;
                if (this.isSuccess){
                    this.callbackFunction = null;
                    this.retryCount = 0;
                    this.loader.close();
                };
                trace("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
                trace("                            finally!!!!!");
                trace("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-");
            };
        }
        public function loadSecureUrlHandler(_arg1:Event):void{
            trace("getSecureUrl Event.COMPLETE");
            if (this.secureUrlCallbackFunction != null){
                this.secureUrlCallbackFunction.call(this.player, (_arg1.target as URLLoader).data);
            };
        }

    }
}//package com.neowiz.bugs.player